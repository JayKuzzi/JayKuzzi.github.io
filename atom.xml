<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Woobo&#39;Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jaykuzzi.github.io/"/>
  <updated>2017-06-27T12:13:38.000Z</updated>
  <id>https://jaykuzzi.github.io/</id>
  
  <author>
    <name>汪博</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安卓知识复习</title>
    <link href="https://jaykuzzi.github.io/2017/03/02/Review/"/>
    <id>https://jaykuzzi.github.io/2017/03/02/Review/</id>
    <published>2017-03-02T09:13:19.000Z</published>
    <updated>2017-06-27T12:13:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/03/02/Review/Review.jpg" alt=""><br><a id="more"></a><br>【此文章仅供作者复习使用，表达含糊，看不懂正常～】</p>
<h1 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a><center>系统架构</center></h1><h2 id="linux-内核层"><a href="#linux-内核层" class="headerlink" title="linux 内核层"></a>linux 内核层</h2><p>为安卓设备提供了底层的驱动 ——– 显示、音频、蓝牙驱动。电源管理</p>
<h2 id="系统运行库层"><a href="#系统运行库层" class="headerlink" title="系统运行库层"></a>系统运行库层</h2><p>通过C++库为安卓提供主要特性支持。——– 如SQLite提供数据库支持、OpenGL库提供了3D绘图功能、webkit库提供浏览器内核。<br>还有安卓运行时库 ——– 允许运用java语言开发android、运行时库包含了Dalvik虚拟机（5.0之后改为art运行环境）使得每个app运行在独立进程中，并拥有自己的虚拟机实例。（防止在虚拟机崩溃的时候所有程序都被关闭。）<br>（art相对dalvik  在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）而在ART 环境中，应用在第一次安装的时候预编译，这样的话，应用的启动首次和执行都会变得更加快速。<br>【应用启动更快、运行更快、体验更流畅、触感反馈更及时。3、更长的电池续航能力。4、支持更低的硬件。】<br>（Dalvik相比jvm dalvik是专门为移动设备定制，针对内存 cpu进行优化。Dalvik运行dex文件，而JVM运行java字节码  Dalvik是基于寄存器的，而JVM是基于栈的）</p>
<h2 id="应用框架层"><a href="#应用框架层" class="headerlink" title="应用框架层"></a>应用框架层</h2><p>提供了编写app时可能用到的api android自带核心应用就是靠它们完成。<br>（<a href="https://developer.android.com/reference/classes.html）" target="_blank" rel="external">https://developer.android.com/reference/classes.html）</a></p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>所有app。 自带的 开发的。</p>
<h1 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a><center>Gradle</center></h1><p><strong>项目采用Gradle来构建项目。</strong><br><strong>Gradle：</strong>是先进构建，配置简单。<br><strong>jcenter：</strong>开源项目可以直接引用（比如app需要依赖下面这个远程库 就去jcenter里找）<br><strong>apply plugin：</strong>可声明是库（依附于别的应用程序模块运行）还是app（可直接运行）。<br><strong>buildTypes：</strong>子包debug（生成测试版安装文件相关配置） 子包release（正式版） minifyEnabled 是否对项目代码进行混淆。<br><strong>本地库：</strong>compile fileTree(include: [‘<em>.jar’], dir: ‘libs’)<br><strong>远程库：</strong>compile ‘com.android.support:design:24.2.1’<br><strong>库依赖：</strong>可是是compile projece（‘：help‘）—–比如在apply plugin：中声明的<br><strong>testCompile：</strong>用于测试用例库 用不大到。<br><em>*logi 比sysout高级：</em></em>可分等级，可控制，可添加过滤，级别</p>
<h1 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a><center>Intent</center></h1><p><strong>Intent组件之间交互的重要方式</strong></p>
<h2 id="1、可指明动作（启动活动、服务，发广播）"><a href="#1、可指明动作（启动活动、服务，发广播）" class="headerlink" title="1、可指明动作（启动活动、服务，发广播）"></a>1、可指明动作（启动活动、服务，发广播）</h2><h2 id="2、还可传递数据。"><a href="#2、还可传递数据。" class="headerlink" title="2、还可传递数据。"></a>2、还可传递数据。</h2><h2 id="3、PendingIntent将要发生的意图-可以看（通知Demo）"><a href="#3、PendingIntent将要发生的意图-可以看（通知Demo）" class="headerlink" title="3、PendingIntent将要发生的意图 可以看（通知Demo）"></a>3、PendingIntent将要发生的意图 可以看（通知Demo）</h2><h2 id="4、intentfilter（动态注册广播-强制下线Demo）"><a href="#4、intentfilter（动态注册广播-强制下线Demo）" class="headerlink" title="4、intentfilter（动态注册广播 强制下线Demo）"></a>4、intentfilter（动态注册广播 强制下线Demo）</h2><h2 id="5、Activity数据交互：（博客）"><a href="#5、Activity数据交互：（博客）" class="headerlink" title="5、Activity数据交互：（博客）"></a>5、Activity数据交互：（博客）</h2><p><strong>1、startActivity()【putExtra(“”,””)、putExtra(Bundle对象)、Intent传递Object对象 Bundle.putSerializable、Parcelable】</strong><br>1.1、 Serializable序列化（java自带）表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地、又可以进程间传递对象。  简单 在对象上直接实现这个接口。并给他一个serialVersionUID<br>1.2、Parcelable（android 专用）：原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。<br>1.3、内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。内存开销小缺点是不能持久化（也就是不能存本地磁盘）。<br><strong>2、startActivityForResult()  重写onActivityResult</strong><br><strong>3、Activity四种状态</strong><br>运行状态 暂停状态 停止状态 销毁状态<br>onCreate：活动初始化：布局加载 绑定事件<br>onPause：释放消耗cpu资源、以及保存关键数据，速度要快 不然会影响新栈顶活动的使用<br><strong>4、三种生存期</strong><br>①: 完整生存期，即Activity在onCreate()方法和onDestroy();方法之间所经历的。一般情况下，一个Activity在onCreate();方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。<br>②: 可见生存期，即Activity在onStart();方法和onStop();方法之间所经历的。此阶段即便有可能无法和用户进行交互，但Activity总数可见的。我们应该通过这两个方法中合理的管理那些对用户可见的资源，比如在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放，从而保证处于停止状态的Activity不会对系统占用过多的内存。<br>③: 前台生存期，级活动在onResume()方法和onPause()方法之间所经历的。在此生存期Activity总数处于运行状态的,此时的Activity可以和用户进行交互，平时我们看的最多的也就是该生存期的Activity<br>【onSaveInstanceState 在按home键（长时间返回会执行onRestoreInstanceState进行恢复）、屏幕旋转（回会执行onRestoreInstanceState进行恢复）、处于后台被杀死（要自己写onCreate中的Bundle变量） 都会执行这个方法】<br><strong>5、单例启动模式举例：启动支付宝付款页面 退出栈后直接返回应用。</strong></p>
<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a><center>布局</center></h1><h2 id="常见布局"><a href="#常见布局" class="headerlink" title="常见布局"></a>常见布局</h2><p>线性布局：（独有layout_weight）(weight=原来宽+屏幕剩余宽度所占百分、layout_gravity中如果现行布局为水平，则只有垂直方向生效（top、bottom、center_vertical）因为水平长度不固定<br>相对布局：（无layout_weight、无layout_gravity）属性多。但相对好控制。<br>针布局：（有layout_gravity、无weight）<br>绝对布局：废弃 不同设备兼容性差劲<br>表格布局<br>百分比布局：因为相对布局无weight 从而生出来 app：layout_widthpercent<br>项目中老多布局了<br>自定义布局（Demo 项目app）<br>布局优化：引入布局 include  限定符PadDemo （Demo）</p>
<h2 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h2><p>适配器，加载数据源，试图加载适配器（ArrayAdapter、SimpleAdapter都继承baseAdapter）<br>适配器：ArrayAdapter分析源码：只能有一个定义了id的TextView data);//data既可以是数组，也可以是List集合<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">SimpleAdapternew <span class="title">SimpleAdapter</span><span class="params">(<span class="keyword">this</span>,mData,R.layout.item,new String[]&#123;<span class="string">"image"</span>,<span class="string">"title"</span>,<span class="string">"text"</span>&#125;, new <span class="keyword">int</span>[]&#123;R.id.image,R.id.title,R.id.text&#125;)</span></span>;</div></pre></td></tr></table></figure></p>
<p>可以显示比较复杂的列表，包括每行显示图片、文字等<br>若都不满足你 可以继承baseAdapter进行自定义<br>listview中每滑动出来一个item，就会走一个getview方法，且重新加载布局，重新获取控件实例<br>// convertView为布局缓存，通过以下设置可以避免重新加载布局，提高效率.<br>//通过ViewHolder来进行优化，可以避免每次都加载控件实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListViewAdapter</span> <span class="keyword">extends</span> <span class="title">ArrayAdapter</span>&lt;<span class="title">ItemBean</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> resource;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyListViewAdapter</span><span class="params">(@NonNull Context context, @LayoutRes <span class="keyword">int</span> resource, @NonNull List&lt;ItemBean&gt; objects)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(context, resource, objects);</div><div class="line">		<span class="keyword">this</span>.resource = resource;</div><div class="line">	&#125;</div><div class="line">	<span class="meta">@NonNull</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="comment">//listview中每滑动出来一个item，就会走一个getview方法，且重新加载布局，重新获取控件实例</span></div><div class="line">	<span class="comment">// convertView为布局缓存，通过以下设置可以避免重新加载布局，提高效率.</span></div><div class="line">	<span class="comment">//通过ViewHolder来进行优化，可以避免每次都加载空间实例。</span></div><div class="line">	<span class="comment">//    public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123;</span></div><div class="line">	<span class="comment">//        Log.i("getview","getview");</span></div><div class="line">	<span class="comment">//        ItemBean itemBean=getItem(position);</span></div><div class="line">	<span class="comment">//        View view= LayoutInflater.from(getContext()).inflate(resource,parent,false);</span></div><div class="line">	<span class="comment">//        ImageView imageView= (ImageView) view.findViewById(R.id.ImageView);</span></div><div class="line">	<span class="comment">//        TextView textView= (TextView) view.findViewById(R.id.TextView);</span></div><div class="line">	<span class="comment">//        imageView.setImageResource(itemBean.getImageId());</span></div><div class="line">	<span class="comment">//        textView.setText(itemBean.getName());</span></div><div class="line">	<span class="comment">//        return view;</span></div><div class="line">	<span class="comment">//    &#125;</span></div><div class="line">	<span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, @Nullable View convertView, @NonNull ViewGroup parent)</span> </span>&#123;</div><div class="line">	<span class="comment">//        Log.i("getview","getview");</span></div><div class="line">		ItemBean itemBean=getItem(position);</div><div class="line">		View view;</div><div class="line">		ViewHolder viewHolder ;</div><div class="line">		<span class="keyword">if</span>(convertView==<span class="keyword">null</span>)&#123;</div><div class="line">			view= LayoutInflater.from(getContext()).inflate(resource,parent,<span class="keyword">false</span>);</div><div class="line">			viewHolder =<span class="keyword">new</span> ViewHolder();</div><div class="line">			viewHolder.imageView=(ImageView) view.findViewById(R.id.ImageView);</div><div class="line">			viewHolder.textView= (TextView) view.findViewById(R.id.TextView);</div><div class="line">			view.setTag(viewHolder);</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			view=convertView;</div><div class="line">			viewHolder= (ViewHolder) view.getTag();</div><div class="line">		&#125;</div><div class="line">		viewHolder.imageView.setImageResource(itemBean.getImageId());</div><div class="line">		viewHolder.textView.setText(itemBean.getName());</div><div class="line">		<span class="keyword">return</span> view;</div><div class="line">	&#125;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">ViewHolder</span></span>&#123;</div><div class="line">		ImageView imageView;</div><div class="line">		TextView textView;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="RecycleView"><a href="#RecycleView" class="headerlink" title="RecycleView"></a>RecycleView</h2><p>listview若不优化效率差，扩展性不好，只能实现纵向滚动，实现item内部view点击很麻烦，recyc油然而生使用需要添加远程依赖</p>
<h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a><center>Fragment</center></h1><h2 id="添加方式"><a href="#添加方式" class="headerlink" title="添加方式"></a>添加方式</h2><p>1、静态添加：继承Fragment 把布局转换成view  在布局中可以通过完整包名添加Fragment的类<br>2、动态添加：继承Fragment 把布局转换成view  在布局中建立FragmentLayout ———在代码中1、通过getSupportFragmrntManager（）获取FragmentManaager———-2、开启事物。在代码中1、通过getSupportFragmrntManager（）获取FragmentTransaction ft = fm.beginTransaction 3、replace 等操作Fragment的类实例 4、commit<br>AddToBackStack()将碎片添加到返回栈</p>
<h2 id="碎片与活动通信"><a href="#碎片与活动通信" class="headerlink" title="碎片与活动通信"></a>碎片与活动通信</h2><p>1、活动中用碎片实例 RightFragment rf =（RightFragment）findFragmentById（R.id.right_frag）；<br>2、碎片用活动 MainActivity activity = (MainActivity)getActivity();<br>3、碎片用碎片 得到相关活动，然后通过活动取得另一个碎片实例。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>运行状态 暂停状态（同activity） 停止状态（不可见、或通过调用FragmentTransaction的remove、replace将并添加到了返回栈，有可能被系统回收） 销毁状态：通过调用FragmentTransaction的remove、replace将没添加到返回栈<br>onAttach():碎片与活动建立关联<br>oncreate（Bundle savedInstance）<br>onCreateView（Bundle savedInstance）：为碎片初始化布局、控件<br>onActivityCreated（Bundle savedInstance）：确保碎片相关联活动已经创建完毕<br>onStart（）<br>onResume（）<br>———–run————-<br>onpause（）<br>onstop（）<br>onDestoryView：碎片被移除 ：【从返回栈中回到上一个碎片走onDestoryView — onCreateView（）】<br>onDestory（）<br>onDetach（）：碎片与活动解除<br><img src="/2017/03/02/Review/life.png" alt="与Activity生命周期Log"></p>
<h1 id="广播（可IPC）"><a href="#广播（可IPC）" class="headerlink" title="广播（可IPC）"></a><center>广播（可IPC）</center></h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>1.标准广播：完全异步<br>2。有序广播：同步，同一时刻只有一个可接，可处理或截断。<br>3。系统广播：开机 电池<br>4、本地广播：安全高效。 在app内部传递。LocalBroadcastManager m=LocalBroadcastManager。getInstance（this）【无法通过静态注册接收，也正因为无需接收外部广播】</p>
<h2 id="广播接收者"><a href="#广播接收者" class="headerlink" title="广播接收者"></a>广播接收者</h2><p>静态注册：关闭程序也能收到，  无需指定category<br>动态注册：registerReceiver（receive，intentFilter） 一定要在onDestory中取消注册。（手机内存是有限的，一个优秀的APP懂得在适当的时期释放自己所占的资源，如果不回收一般有两种结果，一种是系统强行回收，二是内存溢出。）<br>【不可开启线程，不可做耗时操作，因为生命周期短10秒】【扮演打开程序 、创建通知、启动服务等操作】</p>
<h1 id="数据存储（持久化技术）"><a href="#数据存储（持久化技术）" class="headerlink" title="数据存储（持久化技术）"></a><center>数据存储（持久化技术）</center></h1><h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>openFileOutout（文件名不可包含路径，操作模式）方法【mode_private 默认覆盖、mode_append】<br>【mode_world_readable writeable被遗弃 因为危险容易引起安全漏洞】</p>
<h2 id="SharedPreference"><a href="#SharedPreference" class="headerlink" title="SharedPreference"></a>SharedPreference</h2><p>使用键值对的方式。支持多种不同数据类型【mode_private只有这一种模式 表示当前app可操作 其他被废除】 获得对象三种方式：1、上下文.getSharedPreferences（文件名，mode）2、Activity.getSharedPreferences（mode）文件名为活动名 3、PreferencesManager中的getDefaultSharedPreferences（this）当前包名为文件名</p>
<h2 id="数据库存储-【123全都保存在data／data／packagename／1、2、3中】"><a href="#数据库存储-【123全都保存在data／data／packagename／1、2、3中】" class="headerlink" title="数据库存储 【123全都保存在data／data／packagename／1、2、3中】"></a>数据库存储 【123全都保存在data／data／packagename／1、2、3中】</h2><p>sqlite 运行速度快 占资源少 存大量数据 可用sql语言 遵循数据库事务<br>1、SQLiteDatabase类直接操作数据库<br>2、继承SQLiteOpenHelper帮助类，用于对数据库进行创建和升级。：getReadableDatabase、getWritaableDatabase打开或创建一个现有数据库，如果存在则打开，不存在则创建新的，如果磁盘已满 前者打开 后者报错<br>3、开源LitePal 数据库框架  采用对象关系映射（OMR）原理：我们使用oo语言，而使用数据库则是关系型数据库，在两者之间简历一种映射关系<br>3.1、引入远程依赖 3.2、在mian中创建assets目录中配置一个litepal。xml文件 配置数据库名 跟版本号及映射关系 3.3、在修改app配置文件 在application标签中添加name。 3.4、创建数据库记录对象类 3.5、创建记录对象类 直接进行操作 可以连缀。方便</p>
<h1 id="运行时权限"><a href="#运行时权限" class="headerlink" title="运行时权限"></a><center>运行时权限</center></h1><p>（Demo更换壁纸）6.0之前权限强制安装。 6.0之后可以让用户选择权限：并不是所有权限都在运行时申请。普通权限危险权限（运行时申请，如联系人 照相机 位置 外存,一旦同意申请，则该权限组下的权限全部自动同意）、特殊权限</p>
<h1 id="跨进程数据"><a href="#跨进程数据" class="headerlink" title="跨进程数据"></a><center>跨进程数据</center></h1><h2 id="被废除的方式"><a href="#被废除的方式" class="headerlink" title="被废除的方式"></a>被废除的方式</h2><p>1、文件存储、SharedPreference 都被废弃</p>
<h2 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h2><p>创建自己的provider：<br>1、继承contentprovider 复写创建（对数据进行创建升级等操作 当外部使用reslover时调用） 查增删改获得类型操作<br>2、用UriMatch 添加用来匹配Uri要操作的表和匹配码<br>3、筛选匹配码对“对应表”进行操作<br>4、外部那完整uri进行获取<br>【保护数据隐私：通过uri来访问，如果我们不在urimatch中添加受保护的uri 外界也就拿不到这些数据】</p>
<h1 id="多媒体运用"><a href="#多媒体运用" class="headerlink" title="多媒体运用"></a><center>多媒体运用</center></h1><p>1、通知：1、获取NotificationManager ：context.getSystemService(Context.NOTIFICATION_SERVICE);2、读取相册</p>
<h1 id="网络访问"><a href="#网络访问" class="headerlink" title="网络访问"></a><center>网络访问</center></h1><h2 id="HttpURLConnection"><a href="#HttpURLConnection" class="headerlink" title="HttpURLConnection"></a>HttpURLConnection</h2><p>（博客Demo）HttpURLConnection HttpClient(6.0之后被废弃)之前一直使用HttClient是由于HttpURLConnection不稳定导致，那么现在谷歌虽然修复了HttpURLConnection之前存在的一些问题。<br>1、HttpUrlConnection是Android SDK的标准实现，而HttpClient是apache的开源实现；<br>2、HttpUrlConnection直接支持GZIP压缩；HttpClient也支持，但要自己写代码处理；<br>3、HttpUrlConnection直接在系统层面做了缓存策略处理，加快重复请求的速度。<br>4、HttpUrlConnection直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用；HttpClient当然也能做到，但毕竟不如官方直接系统底层支持好；</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><p>开源库（大demo）：<br>1、新建一个OKHttpClient实例<br>2、用连缀方式build一个Request对象，<br>3、通过response的newCall创建一个call对象，传入request并。execute<br>4、通过response。body拿到数据okhttp中enqueue可以为我们自动开子自线程去做耗时访问</p>
<h1 id="数据解析"><a href="#数据解析" class="headerlink" title="数据解析"></a><center>数据解析</center></h1><p>xml：pull方式 sax方式  jason：（Demo）、gson开源库</p>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a><center>Service</center></h1><p>（大Demo 后台下载东西前台服务通知）</p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>后台不需跟用户交互需长期运行。进程被杀掉服务也断掉。要做耗时操作必须开启子线程。（广播不可开，因为life短）<br>若果不stopService或者stopSelf（） 服务将一直运行 </p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>继承Service 重写OnBind（抽象）</p>
<h2 id="活动与进程之间进行通信"><a href="#活动与进程之间进行通信" class="headerlink" title="活动与进程之间进行通信"></a>活动与进程之间进行通信</h2><p>1、写内部类继承Binder 在里面实现要调用方法<br>2、创建内部类实例 并在Onbind内返回<br>3、在活动中创建ServiceConnect实例 重写连接方法 将参数内的回掉的Ibinder进行强转<br>4、就可以调用服务中的方法了 5、通过bindService启用service（intent，connect，BIND_AUTO_CREATE）</p>
<h2 id="前台服务"><a href="#前台服务" class="headerlink" title="前台服务"></a>前台服务</h2><p>类似通知样式，因为服务优先级低在后台运行 若想不让GC回收 则用到前台服务 比如彩云天气<br>用法：在继承了服务类中重写Oncreate ：内部创建一个通知 并通过StartForegroud（）调用</p>
<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>在service中做耗时操作需要开启子线程 并。start并且完事后stopSelf。很麻烦，IntentService就可以实现对这些事的封装。只需继承它，重写OnHandleIntent（其运行在子线程并且自动结束）</p>
<h2 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h2><p>使用AIDL定义进程间的通信接口. AIDL文件必须以.aidl作为后缀名.接口名需要和文件名相同.方法的参数或返回值是自定义类型时, 该自定义的类型必须实现了Parcelable接口.<br>远程service的作用只是重新建立一个新进程执行，可以独立出去。其他app可以调用这个service。因为是一个新的进程，所以也不能用bindService来建立关联了，用startService<br><strong>使用：</strong><br>1、两个app中都建立一个文件 IPerson.aidl 在里面写接口 ，build一下就变成了接口文件<br>2、服务端创建<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">IPerson.Stub stub = <span class="keyword">new</span> IPerson.Stub() &#123;</div><div class="line">   <span class="meta">@Override</span></div><div class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(String someone)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">   Log.i(TAG, <span class="string">"greet() called"</span>);</div><div class="line">   <span class="keyword">return</span> <span class="string">"hello, "</span> + someone;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p>并且在onBind中return出去，<br>3、在服务端startService(startIntent);<br>4、在服务端注册<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".AIDLService"</span><span class="attr">android:process</span>=<span class="string">":remote"</span> 开启独立进程暴露出去&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.AIDLService"</span> /&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>5、接收端创建ServiceConnect实例 重写连接方法 将参数内的回掉的Ibinder进行强转<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">IPerson person = IPerson.Stub.asInterface(binder);就可以person。方法名调用了</div></pre></td></tr></table></figure></p>
<p>6、接收端启动<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent mIntent = <span class="keyword">new</span> Intent(); </div><div class="line">mIntent.setAction(<span class="string">"android.intent.action.AIDLService"</span>);</div><div class="line">Intent eintent = <span class="keyword">new</span> Intent(getExplicitIntent(<span class="keyword">this</span>,mIntent));</div><div class="line">bindService(eintent, conn, Context.BIND_AUTO_CREATE);</div></pre></td></tr></table></figure></p>
<h1 id="ANR"><a href="#ANR" class="headerlink" title="ANR"></a><center>ANR</center></h1><p>activity 5秒 、BroadcastReceiver（一般为10秒）、Service—–&gt;20秒</p>
<h1 id="IPC-1"><a href="#IPC-1" class="headerlink" title="IPC"></a><center>IPC</center></h1><p>四大组件都是运行在主线程中，均能IPC.<br>方式 ：Activity 在Intent中使用Bubdle activity（博客），<br>      广播reciver本身就能接收外部程序的发来的广播。<br>      service AIDL这是需要跨进程调用服务端的方法 用到AIDL实现（Demo）<br>      Content URI 实现跨进程<br>      Messenger方式通过Messenger对象在不同进程中以串行的方式进行传递数据。它是AIDL的轻量级表现 底层是AIDL，如果是大量消息同时请求 服务端只能一个个处理，IDL这是需要跨进程调用服务端的方法 用到AIDL实现<br>      使用socket：网络通信，它分为 流式套接字 和  用户数据报套接字两种 对应网络传输控制层中tcp udp协议 ，<br>      tcp面向连接 提供稳定双向通讯，三次握手，为了提高稳定的数据传输，本身提供了超时重传机制，稳定性高。<br>      Udp捂脸的，提供不稳定单向通信。<br>      性能上udp更好效率缺点不能保证数据一定能传输正确。</p>
<h1 id="view"><a href="#view" class="headerlink" title="view"></a><center>view</center></h1><p>view三大过程都是通过viewroot来完成的。ViewRoot 对应viewrootImpl类，它是连接windowsmanager 和decorview 的纽带，在ActivityThread中 activity对象被创建完毕后 将Decorview添加到windows中 同时<br>创建viewrootImpl对象，将viewrootImpl和Decorview 关联起来。<br>view 绘制流程是从viewroot的performTraversals方法开始。经过了measure layout draw方式。（手机 相册。  看view动画）</p>
<h1 id="activity工作原理模式"><a href="#activity工作原理模式" class="headerlink" title="activity工作原理模式"></a><center>activity工作原理模式</center></h1><p>Activity构造的时候，调用了attach，绑定了一个window；<br>Activity的setContentView()，是window.setContentView();<br>每个Activity内部都有一个Window对象， Window对象包含了一个DecorView（顶级view）(继承FrameLayout)，我们通过setContentView给Activity设置显示的View实际上都是加到了DecorView中。Activity—&gt;Window—&gt;DecorView。 </p>
<h1 id="事件处理机制"><a href="#事件处理机制" class="headerlink" title="事件处理机制"></a><center>事件处理机制</center></h1><p>: android开发艺术140页（手机相册  view demo）</p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/03/02/Review/Review.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="知识复习" scheme="https://jaykuzzi.github.io/categories/Android/%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="知识复习" scheme="https://jaykuzzi.github.io/tags/%E7%9F%A5%E8%AF%86%E5%A4%8D%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 网络请求及数据解析</title>
    <link href="https://jaykuzzi.github.io/2017/02/12/Json/"/>
    <id>https://jaykuzzi.github.io/2017/02/12/Json/</id>
    <published>2017-02-12T05:09:33.000Z</published>
    <updated>2017-06-27T12:13:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/02/12/Json/json.png" alt=""><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><center>前言</center></h1><p>大部分andriod应用需要与服务器进行数据交互，<strong>HTTP、FTP、SMTP</strong>或者是直接基于<strong>SOCKET编程</strong>都可以进行数据交互，但是<strong>HTTP必然是使用最广泛的协议</strong>。<br><strong>在总结之前先来了解一下Http协议，也是对技术支持的一些补充。</strong></p>
<h2 id="1、http协议定义"><a href="#1、http协议定义" class="headerlink" title="1、http协议定义"></a>1、http协议定义</h2><p>HTTP协议是基于TCP/IP协议之上的协议，是<strong>客户端</strong>和<strong>服务器</strong>之间的应用层的协议，是通用的、无状态的面向对象的协议。 </p>
<h2 id="2、客户端连接服务器实现内部的原理"><a href="#2、客户端连接服务器实现内部的原理" class="headerlink" title="2、客户端连接服务器实现内部的原理"></a>2、客户端连接服务器实现内部的原理</h2><p><img src="http://upload-images.jianshu.io/upload_images/4821697-d453b9ea47d0b83b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>分析上图，步骤如下：<br>第一步：在浏览器客户端中得到用户输入的内容。<br>第二步：浏览器得到这个网址之后，内部会将这个域名发送到DNS上，进行域名解析。得到它的IP之后就会链接到指定的服务器上，假如服务器的地址是：221.104.13.32:80，从浏览器到服务器端口它使用到最底层的TCP/IP协议。<br>第三步：实现TCP/IP协议用Socket来完成，使用了Socket的套接字。<br>第四步：服务器端的80端口监听客户端的链接，这样客户端到服务器就链接上了。<br><strong>通俗一点讲，用户在浏览器输入网址，通过http协议发出去，网址经过DNS域名解析，解析成指定的ip地址，并在80端口上监听用户的请求。服务器监听到请求之后，会以三种方式返回给客户端：HTML、XML、JASON。</strong></p>
<h2 id="3、Http请求方式、区别"><a href="#3、Http请求方式、区别" class="headerlink" title="3、Http请求方式、区别"></a>3、Http请求方式、区别</h2><p>根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。<br>区别：<br><strong>在客户端，GET方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTML HEADER内提交。</strong><br><strong>对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器用Request.Form获取提交的数据。</strong><br><strong>GET方式提交的数据不能大于2KB（主要是URL长度限制），而POST则没有此限制。</strong><br><strong>安全性问题。使用GET的时候，参数会显示在地址栏上，而POST不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用GET；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用POST为好。</strong></p>
<h2 id="4、HTTP返回请求数据的三种方式"><a href="#4、HTTP返回请求数据的三种方式" class="headerlink" title="4、HTTP返回请求数据的三种方式:"></a>4、HTTP返回请求数据的三种方式:</h2><p><strong>以HTML代码内容返回。 </strong><br><strong>以XML字符串的形式返回，在以后的android开发中这种形式返回数据比较多。 </strong><br><strong>以JSON对象形式返回，在网络流量上考虑JSON要比XML方式要好一些，便于解析。</strong><br><strong>在Android当中，一般使用xml和Json数据解析。</strong></p>
<h1 id="Android中的网络请求方式"><a href="#Android中的网络请求方式" class="headerlink" title="Android中的网络请求方式"></a><center>Android中的网络请求方式</center></h1><p>Android中的WebView控件已经在后台帮我们处理好了发送HTTP请求、接收服务响应、解析返回数据，以及最终的页面展示这几步工作，不过由于它封装得太好了，反而不能直观地看出HTTP协议是如何工作的。因此接下来我们通过手动发送HTTP请求的方式，来更加深入的了解这一过程。</p>
<h2 id="1、在Android上发送HTTP请求的方式"><a href="#1、在Android上发送HTTP请求的方式" class="headerlink" title="1、在Android上发送HTTP请求的方式"></a>1、在Android上发送HTTP请求的方式</h2><p>一般有两种：HttpURLConnection、HttpCient</p>
<h2 id="2、关于HttpClient的废除在android-6-0-api-23-SDK，不再提供org-apache-http-只保留几个类-，HttpClient相关类移除，推荐使用HTTPURLConnection。"><a href="#2、关于HttpClient的废除在android-6-0-api-23-SDK，不再提供org-apache-http-只保留几个类-，HttpClient相关类移除，推荐使用HTTPURLConnection。" class="headerlink" title="2、关于HttpClient的废除在android 6.0(api 23) SDK，不再提供org.apache.http.*(只保留几个类)，HttpClient相关类移除，推荐使用HTTPURLConnection。"></a>2、关于HttpClient的废除在android 6.0(api 23) SDK，不再提供org.apache.http.*(只保留几个类)，HttpClient相关类移除，推荐使用HTTPURLConnection。</h2><p>废除原因：<strong>之前一直使用HttClient是由于HttpURLConnection不稳定导致，那么现在谷歌虽然修复了HttpURLConnection之前存在的一些问题。</strong><br>若还需使用该类，点击查看<a href="http://blog.csdn.net/yangqingqo/article/details/48214865" target="_blank" rel="external">解决办法</a>。</p>
<h2 id="3、HttpURLConnection、HttpCient介绍。-HttpCient废除之前"><a href="#3、HttpURLConnection、HttpCient介绍。-HttpCient废除之前" class="headerlink" title="3、HttpURLConnection、HttpCient介绍。(HttpCient废除之前)"></a>3、HttpURLConnection、HttpCient介绍。(HttpCient废除之前)</h2><p>HttpClient是apache的开源框架，封装了访问http的请求头，参数，内容体，响应等等，使用起来比较方便，而HttpURLConnection是java的标准类，什么都没封装，用起来太原始，不方便，比如重访问的自定义，以及一些高级功能等。<br>从稳定性方面来说的话，HttpClient很稳定，功能强，BUG少，容易控制细节，而之前的HttpURLConnection一直存在着版本兼容的问题，不过在后续的版本中已经相继修复掉了。</p>
<h2 id="4、HttpURLConnection和HttpCient区别-HttpURLConnection优势"><a href="#4、HttpURLConnection和HttpCient区别-HttpURLConnection优势" class="headerlink" title="4、HttpURLConnection和HttpCient区别(HttpURLConnection优势)"></a>4、HttpURLConnection和HttpCient区别(HttpURLConnection优势)</h2><p>1、HttpUrlConnection是Android SDK的标准实现，而HttpClient是apache的开源实现；<br>2、HttpUrlConnection直接支持GZIP压缩；HttpClient也支持，但要自己写代码处理；<br>3、HttpUrlConnection直接在系统层面做了缓存策略处理，加快重复请求的速度。<br>4、HttpUrlConnection直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用；HttpClient当然也能做到，但毕竟不如官方直接系统底层支持好；</p>
<h2 id="5、Android配置网络权限"><a href="#5、Android配置网络权限" class="headerlink" title="5、Android配置网络权限"></a>5、Android配置网络权限</h2><p>因为需要访问网络，需在AndroidManifest.xml中添加如下权限<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="HttpURLConnection-Demo"><a href="#HttpURLConnection-Demo" class="headerlink" title="HttpURLConnection(Demo)"></a><center>HttpURLConnection(Demo)</center></h1><h2 id="1、Get请求实现（Demo）"><a href="#1、Get请求实现（Demo）" class="headerlink" title="1、Get请求实现（Demo）"></a>1、Get请求实现（Demo）</h2><p>由于网络请求可能造成耗时操作（网络环境差的情况下）对ui线程的阻塞，我们开启子线程去操作网络请求。<br>【关于UI线程，请看<a href="http://www.jianshu.com/p/0c6939e41681" target="_blank" rel="external">《Android实习生 —— 异步处理之Handler》</a>】<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectWithHttpURLConnection</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread( <span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Message msg =<span class="keyword">new</span> Message();</div><div class="line">				HttpURLConnection connection = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="comment">// 调用URL对象的openConnection方法获取HttpURLConnection的实例</span></div><div class="line">					URL url = <span class="keyword">new</span> URL(<span class="string">"http://www.baidu.com"</span>);</div><div class="line">					connection = (HttpURLConnection) url.openConnection();</div><div class="line">					<span class="comment">// 设置请求方式，GET或POST</span></div><div class="line">					connection.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">					<span class="comment">// 设置连接超时、读取超时的时间，单位为毫秒（ms）</span></div><div class="line">					connection.setConnectTimeout(<span class="number">8000</span>);</div><div class="line">					connection.setReadTimeout(<span class="number">8000</span>);</div><div class="line">					<span class="comment">// 设置是否使用缓存  默认是true</span></div><div class="line">					connection.setUseCaches(<span class="keyword">true</span>);</div><div class="line">					<span class="comment">//设置请求头里面的属性</span></div><div class="line">					<span class="comment">//connection.setRequestProperty();</span></div><div class="line">					<span class="comment">// 开始连接</span></div><div class="line">					Log.i(<span class="string">"HttpURLConnection.GET"</span>,<span class="string">"开始连接"</span>);</div><div class="line">					connection.connect();</div><div class="line">					<span class="keyword">if</span> (connection.getResponseCode() == <span class="number">200</span>) &#123;</div><div class="line">						Log.i(<span class="string">"HttpURLConnection.GET"</span>, <span class="string">"请求成功"</span>);</div><div class="line">						InputStream in = connection.getInputStream();</div><div class="line">						<span class="comment">// 使用BufferedReader对象读取返回的数据流</span></div><div class="line">						<span class="comment">// 按行读取，存储在StringBuider对象response中</span></div><div class="line">						BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line">						StringBuilder response = <span class="keyword">new</span> StringBuilder();</div><div class="line">						String line;</div><div class="line">						<span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">							response.append(line);</div><div class="line">						&#125;</div><div class="line">						<span class="comment">// 此处省略处理数据的代码,通过handler直接将返回的结果消息发送给UI线程列队</span></div><div class="line">						Bundle bundle =<span class="keyword">new</span> Bundle();</div><div class="line">						bundle.putString(<span class="string">"data"</span>, String.valueOf(response));</div><div class="line">						msg.setData(bundle);</div><div class="line">						handler.sendMessage(msg);</div><div class="line">					&#125;<span class="keyword">else</span>&#123;</div><div class="line">						Log.i(<span class="string">"HttpURLConnection.GET"</span>, <span class="string">"请求失败"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e)&#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					<span class="keyword">if</span> (connection != <span class="keyword">null</span>)&#123;</div><div class="line">						<span class="comment">// 结束后，关闭连接</span></div><div class="line">						connection.disconnect();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-02f7676c93afa928.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Get请求效果"><br><strong>打印消息</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-90e380713a9f13b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印消息"></p>
<h2 id="2、Post请求实现（Demo）"><a href="#2、Post请求实现（Demo）" class="headerlink" title="2、Post请求实现（Demo）"></a>2、Post请求实现（Demo）</h2><p><strong>正如前言中第3条所述，在客户端，GET方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTML HEADER内提交。</strong><br>在Get方法中请求参数可以直接写到地址栏中，如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//用“&amp;”隔开不同参数</span></div><div class="line"> String path = <span class="string">"https://reg.163.com/logins.jsp?id=helloworld&amp;pwd=android"</span>;</div></pre></td></tr></table></figure></p>
<p>但在Post方式中要把“请求的参数”转换为byte数组，然后通过DataOutputStream(urlConn.getOutputStream())把参数写入。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectWithHttpURLConnectionPOST</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				Message msg = <span class="keyword">new</span> Message();</div><div class="line">				String path = <span class="string">"https://reg.163.com/logins.jsp"</span>;</div><div class="line">				<span class="comment">// 请求的参数转换为byte数组</span></div><div class="line">				String params = <span class="keyword">null</span>;</div><div class="line">				HttpURLConnection urlConn = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					params = <span class="string">"id="</span> + URLEncoder.encode(<span class="string">"helloworld"</span>, <span class="string">"UTF-8"</span>)</div><div class="line">							+ <span class="string">"&amp;pwd="</span> + URLEncoder.encode(<span class="string">"android"</span>, <span class="string">"UTF-8"</span>);</div><div class="line">					<span class="keyword">byte</span>[] postData = params.getBytes();</div><div class="line">					<span class="comment">// 新建一个URL对象</span></div><div class="line">					URL url = <span class="keyword">new</span> URL(path);</div><div class="line">					<span class="comment">// 打开一个HttpURLConnection连接</span></div><div class="line">					urlConn = (HttpURLConnection) url.openConnection();</div><div class="line">					<span class="comment">// 设置连接超时时间</span></div><div class="line">					urlConn.setConnectTimeout(<span class="number">8</span> * <span class="number">1000</span>);</div><div class="line">					<span class="comment">// Post请求必须设置允许输出</span></div><div class="line">					urlConn.setDoOutput(<span class="keyword">true</span>);</div><div class="line">					<span class="comment">// Post请求不能使用缓存</span></div><div class="line">					urlConn.setUseCaches(<span class="keyword">false</span>);</div><div class="line">					<span class="comment">// 设置为Post请求</span></div><div class="line">					urlConn.setRequestMethod(<span class="string">"POST"</span>);</div><div class="line">					urlConn.setInstanceFollowRedirects(<span class="keyword">true</span>);</div><div class="line">					<span class="comment">// 配置请求Content-Type</span></div><div class="line">					urlConn.setRequestProperty(<span class="string">"Content-Type"</span>,</div><div class="line">							<span class="string">"application/x-www-form-urlencode"</span>);</div><div class="line">					<span class="comment">// 开始连接</span></div><div class="line">					urlConn.connect();</div><div class="line">					Log.i(<span class="string">"HttpURLConnection.POST"</span>, <span class="string">"开始连接"</span>);</div><div class="line">					<span class="comment">// 发送请求参数</span></div><div class="line">					DataOutputStream dos = <span class="keyword">new</span> DataOutputStream(urlConn.getOutputStream());</div><div class="line">					dos.write(postData);</div><div class="line">					dos.flush();</div><div class="line">					dos.close();</div><div class="line">					<span class="comment">// 判断请求是否成功</span></div><div class="line">					<span class="keyword">if</span> (urlConn.getResponseCode() == <span class="number">200</span>) &#123;</div><div class="line">						<span class="comment">// 获取返回的数据</span></div><div class="line">						InputStream in = urlConn.getInputStream();</div><div class="line">						<span class="comment">// 使用BufferedReader对象读取返回的数据流</span></div><div class="line">						<span class="comment">// 按行读取，存储在StringBuider对象response中</span></div><div class="line">						BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line">						StringBuilder response = <span class="keyword">new</span> StringBuilder();</div><div class="line">						String line;</div><div class="line">						<span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">							response.append(line);</div><div class="line">						&#125;</div><div class="line">						Log.i(<span class="string">"HttpURLConnection.POST"</span>, <span class="string">"请求成功"</span>);</div><div class="line">						<span class="comment">// 此处省略处理数据的代码,直接将返回的结果消息发送给UI线程列队</span></div><div class="line">						Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">						bundle.putString(<span class="string">"data"</span>, String.valueOf(response));</div><div class="line">						msg.setData(bundle);</div><div class="line">						handler.sendMessage(msg);</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						Log.i(<span class="string">"HttpURLConnection.POST"</span>, <span class="string">"请求失败"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					<span class="keyword">if</span> (urlConn != <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="comment">// 结束后，关闭连接</span></div><div class="line">						urlConn.disconnect();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-fbe0c0aeb7172bb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Post请求效果"></p>
<h1 id="HttpCient-Demo"><a href="#HttpCient-Demo" class="headerlink" title="HttpCient(Demo)"></a><center>HttpCient(Demo)</center></h1><h2 id="1、关于-HttpCient废除"><a href="#1、关于-HttpCient废除" class="headerlink" title="1、关于 HttpCient废除"></a>1、关于 HttpCient废除</h2><p>在android 6.0(api 23) SDK，不再提供org.apache.http.<em>(只保留几个类)，HttpClient相关类移除，推荐使用HTTPURLConnection。<br>废除原因：<em>*之前一直使用HttClient是由于HttpURLConnection不稳定导致，那么现在谷歌虽然修复了HttpURLConnection之前存在的一些问题。</em></em><br>若还需使用该类，点击查看<a href="http://blog.csdn.net/yangqingqo/article/details/48214865" target="_blank" rel="external">解决办法</a>。</p>
<h2 id="2、HttpCient介绍"><a href="#2、HttpCient介绍" class="headerlink" title="2、HttpCient介绍"></a>2、HttpCient介绍</h2><p>HttpClient其实是一个interface类型，HttpClient封装了对象需要执行的Http请求、身份验证、连接管理和其它特性。<strong>既然HttpClient是一个接口，因此无法创建它的实例。</strong>从文档上看，HttpClient有三个已知的实现类分别是：<strong>AbstractHttpClient, AndroidHttpClient, DefaultHttpClient</strong>，会发现有一个专门为Android应用准备的实现类<strong>AndroidHttpClient</strong>，当然使用常规的<strong>DefaultHttpClient</strong>也可以实现功能。</p>
<h2 id="3、HttpCient实现步骤"><a href="#3、HttpCient实现步骤" class="headerlink" title="3、HttpCient实现步骤"></a>3、HttpCient实现步骤</h2><p>（i）创建代表客户端的HttpClient对象。<br>（ii）创建代表请求的对象，如果需要发送GET请求，则创建HttpGet对象，如果需要发送POST请求，则创建HttpPost对象。<br><strong>【对于发送请求的参数，GET和POST使用的方式不同，GET方式可以使用拼接字符串的方式，把参数拼接在URL结尾；POST方式需要使用setEntity(HttpEntity entity)方法来设置请求参数。】</strong><br>（iii）调用HttpClient对象的execute（HttpUriRequest request）发送请求，执行该方法后，将获得服务器返回的HttpResponse对象。服务器发还给我们的数据就在这个HttpResponse相应当中。调用HttpResponse的对应方法获取服务器的响应头、响应内容等。<br>（iv）检查相应状态是否正常。服务器发给客户端的相应，有一个相应码：相应码为200，正常；相应码为404，客户端错误；相应码为505，服务器端错误。<br>（v）获得相应对象当中的数据。</p>
<h2 id="4、HttpCient实现实例（GET）（Demo）"><a href="#4、HttpCient实现实例（GET）（Demo）" class="headerlink" title="4、HttpCient实现实例（GET）（Demo）"></a>4、HttpCient实现实例（GET）（Demo）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithHttpClient</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">//用HttpClient发送请求，分为五步</span></div><div class="line">				<span class="comment">//第一步：创建HttpClient对象</span></div><div class="line">				HttpClient httpCient = <span class="keyword">new</span> DefaultHttpClient();</div><div class="line">				<span class="comment">//第二步：创建代表请求的对象,参数是访问的服务器地址</span></div><div class="line">				HttpGet httpGet = <span class="keyword">new</span> HttpGet(<span class="string">"http://www.baidu.com"</span>);</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="comment">//第三步：执行请求，获取服务器发还的相应对象</span></div><div class="line">					HttpResponse httpResponse = httpCient.execute(httpGet);</div><div class="line">					<span class="comment">//第四步：检查相应的状态是否正常：检查状态码的值是200表示正常</span></div><div class="line">					<span class="keyword">if</span> (httpResponse.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</div><div class="line">						<span class="comment">//第五步：从相应对象当中取出数据，放到entity当中</span></div><div class="line">						HttpEntity entity = httpResponse.getEntity();</div><div class="line">						String response = EntityUtils.toString(entity, <span class="string">"utf-8"</span>);<span class="comment">//将entity当中的数据转换为字符串</span></div><div class="line">						<span class="comment">//在子线程中将Message对象发出去</span></div><div class="line">						Message message = <span class="keyword">new</span> Message();</div><div class="line">						message.what = SHOW_RESPONSE;</div><div class="line">						message.obj = response.toString();</div><div class="line">						handler.sendMessage(message);</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-5d88369641f05659.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Get请求效果"></p>
<h2 id="5、HttpCient实现实例（POST）（Demo）"><a href="#5、HttpCient实现实例（POST）（Demo）" class="headerlink" title="5、HttpCient实现实例（POST）（Demo）"></a>5、HttpCient实现实例（POST）（Demo）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendRequestWithHttpClientPOST</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">//用HttpClient发送请求，分为五步</span></div><div class="line">				<span class="comment">//第一步：创建HttpClient对象</span></div><div class="line">				HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</div><div class="line">				<span class="comment">//第二步：创建代表请求的对象,参数是访问的服务器地址</span></div><div class="line">				HttpPost httpPost= <span class="keyword">new</span> HttpPost(<span class="string">"https://reg.163.com/logins.jsp"</span>);</div><div class="line">				<span class="comment">// 使用NameValuePair（键值对）存放参数</span></div><div class="line">				List&lt;NameValuePair&gt; data = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</div><div class="line">				<span class="comment">// 添加键值对</span></div><div class="line">				data.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"id"</span>, <span class="string">"helloworld"</span>));</div><div class="line">				data.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"pwd"</span>, <span class="string">"android"</span>));</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="comment">// 使用setEntity方法传入编码后的参数</span></div><div class="line">					httpPost.setEntity(<span class="keyword">new</span> UrlEncodedFormEntity(data, <span class="string">"utf-8"</span>));</div><div class="line">					<span class="comment">//第三步：执行请求，获取服务器发还的相应对象</span></div><div class="line">					HttpResponse httpResponse = httpClient.execute(httpPost);</div><div class="line">					<span class="comment">//第四步：检查相应的状态是否正常：检查状态码的值是200表示正常</span></div><div class="line">					<span class="keyword">if</span> (httpResponse.getStatusLine().getStatusCode() == <span class="number">200</span>) &#123;</div><div class="line">						Log.i(<span class="string">"mm"</span>,<span class="string">"success"</span>);</div><div class="line">						<span class="comment">//第五步：从相应对象当中取出数据，放到entity当中</span></div><div class="line">						HttpEntity entity = httpResponse.getEntity();</div><div class="line">						String response = EntityUtils.toString(entity, <span class="string">"utf-8"</span>);<span class="comment">//将entity当中的数据转换为字符串</span></div><div class="line">						<span class="comment">//在子线程中将Message对象发出去</span></div><div class="line">						Message message = <span class="keyword">new</span> Message();</div><div class="line">						message.what = <span class="number">1</span>;</div><div class="line">						message.obj = response.toString();</div><div class="line">						handler.sendMessage(message);</div><div class="line">					&#125;<span class="keyword">else</span>&#123;</div><div class="line">						Log.i(<span class="string">"mm"</span>,<span class="string">"fail"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-06de65cffbe1899c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="POST效果"></p>
<h1 id="HttpURLConnection抽象请求方法（Demo）"><a href="#HttpURLConnection抽象请求方法（Demo）" class="headerlink" title="HttpURLConnection抽象请求方法（Demo）"></a><center>HttpURLConnection抽象请求方法（Demo）</center></h1><h2 id="1、JQuery"><a href="#1、JQuery" class="headerlink" title="1、JQuery"></a>1、JQuery</h2><p>如果你使用过JQuery（一个javasript库），你一定对JQuery的网路编程印象深刻，比如一个HTTP请求只需以下几行代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// JQuery的post方法</span></div><div class="line">$.post(<span class="string">"http://www.cnblogs.com/gzdaijie"</span>,&#123;</div><div class="line">		<span class="string">"stu_no"</span>:<span class="number">12345</span>,</div><div class="line">		<span class="string">"stu_name"</span>:<span class="string">"Tom"</span>,</div><div class="line">	&#125;).done(function()&#123;</div><div class="line">		<span class="comment">//...请求成功的代码</span></div><div class="line">	&#125;).fail(function()&#123;</div><div class="line">		<span class="comment">//...请求失败的代码</span></div><div class="line">	&#125;).always(function()&#123;</div><div class="line">		<span class="comment">//...总会执行的代码</span></div><div class="line">	&#125;)</div></pre></td></tr></table></figure></p>
<p>我们当然不希望每次网络请求都写下“二”中那么繁琐的代码，那么android的HTTP请求能否像JQuery那么简单呢？当然可以！下面的代码实现了HttpURLConnection的HTTP请求方法封装</p>
<h2 id="2、定义接口HttpCallbackListener，为了实现回调"><a href="#2、定义接口HttpCallbackListener，为了实现回调" class="headerlink" title="2、定义接口HttpCallbackListener，为了实现回调"></a>2、定义接口HttpCallbackListener，为了实现回调</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义HttpCallbackListener接口</span></div><div class="line"><span class="comment">// 包含两个方法，成功和失败的回调函数定义</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpCallbackListener</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(String response)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、创建HttpTool类，抽象请求方法（GET）"><a href="#3、创建HttpTool类，抽象请求方法（GET）" class="headerlink" title="3、创建HttpTool类，抽象请求方法（GET）"></a>3、创建HttpTool类，抽象请求方法（GET）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpTool</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(<span class="keyword">final</span> String address,</span></span></div><div class="line">								   <span class="keyword">final</span> HttpCallbackListener listener) &#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				HttpURLConnection connection = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					<span class="comment">// 调用URL对象的openConnection方法获取HttpURLConnection的实例</span></div><div class="line">					URL url = <span class="keyword">new</span> URL(address);</div><div class="line">					connection = (HttpURLConnection) url.openConnection();</div><div class="line">					<span class="comment">// 设置请求方式，GET或POST</span></div><div class="line">					connection.setRequestMethod(<span class="string">"GET"</span>);</div><div class="line">					<span class="comment">// 设置连接超时、读取超时的时间，单位为毫秒（ms）</span></div><div class="line">					connection.setConnectTimeout(<span class="number">8000</span>);</div><div class="line">					connection.setReadTimeout(<span class="number">8000</span>);</div><div class="line">					<span class="comment">// 设置是否使用缓存  默认是true</span></div><div class="line">					connection.setUseCaches(<span class="keyword">true</span>);</div><div class="line">					<span class="comment">//设置请求头里面的属性</span></div><div class="line">					<span class="comment">//connection.setRequestProperty();</span></div><div class="line">					<span class="comment">// 开始连接</span></div><div class="line">					Log.i(<span class="string">"HttpURLConnection.GET"</span>,<span class="string">"开始连接"</span>);</div><div class="line">					connection.connect();</div><div class="line">					<span class="keyword">if</span> (connection.getResponseCode() == <span class="number">200</span>) &#123;</div><div class="line">						Log.i(<span class="string">"HttpURLConnection.GET"</span>, <span class="string">"请求chenggong"</span>);</div><div class="line">						InputStream in = connection.getInputStream();</div><div class="line">						BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</div><div class="line">						StringBuilder response = <span class="keyword">new</span> StringBuilder();</div><div class="line">						String line;</div><div class="line">						<span class="keyword">while</span> ((line = reader.readLine()) != <span class="keyword">null</span>) &#123;</div><div class="line">							response.append(line);</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</div><div class="line">							<span class="comment">// 回调方法 onFinish()</span></div><div class="line">							listener.onFinish(response.toString());</div><div class="line">						&#125;</div><div class="line">					&#125; <span class="keyword">else</span> &#123;</div><div class="line">						Log.i(<span class="string">"HttpURLConnection.GET"</span>, <span class="string">"请求失败"</span>);</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">					<span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="comment">// 回调方法 onError()</span></div><div class="line">						listener.onError(e);</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					<span class="keyword">if</span> (connection != <span class="keyword">null</span>) &#123;</div><div class="line">						connection.disconnect();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4、调用示例"><a href="#4、调用示例" class="headerlink" title="4、调用示例"></a>4、调用示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="comment">//使用该HttpTool发起GET请求</span></div><div class="line">				String url = <span class="string">"http://www.jianshu.com"</span>;</div><div class="line">				HttpTool.sendRequest(url,<span class="keyword">new</span> HttpCallbackListener()&#123;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinish</span><span class="params">(String response)</span> </span>&#123;</div><div class="line">						<span class="comment">// ...省略对返回结果的处理代码</span></div><div class="line">						Message message = <span class="keyword">new</span> Message();</div><div class="line">						message.what = <span class="number">0</span>;</div><div class="line">						message.obj = response.toString();</div><div class="line">						handler.sendMessage(message);</div><div class="line">					&#125;</div><div class="line">					<span class="meta">@Override</span></div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span> </span>&#123;</div><div class="line">						<span class="comment">// ...省略请求失败的处理代码</span></div><div class="line">					&#125;</div><div class="line">				&#125;);</div><div class="line">		&#125;</div><div class="line">		&#125;);</div></pre></td></tr></table></figure>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-e0595ce0b9d0014b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h2 id="5、抽象请求方法（POST）"><a href="#5、抽象请求方法（POST）" class="headerlink" title="5、抽象请求方法（POST）"></a>5、抽象请求方法（POST）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 在GET方法实现的基础上增加一个参数params即可，</span></div><div class="line"> * 将参数转换为字符串后传入</div><div class="line"> * 也可以传入键值对集合，再处理 */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendRequest</span><span class="params">(<span class="keyword">final</span> String address,</span></span></div><div class="line">	<span class="keyword">final</span> String params, <span class="keyword">final</span> HttpCallbackListener listener)&#123;</div><div class="line">		<span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="文件下载（Demo）"><a href="#文件下载（Demo）" class="headerlink" title="文件下载（Demo）"></a><center>文件下载（Demo）</center></h1><h2 id="1、DownLoadManager简介"><a href="#1、DownLoadManager简介" class="headerlink" title="1、DownLoadManager简介"></a>1、DownLoadManager简介</h2><p>虽然我们可以通过HTTP请求的方式下载文件，在api level 9之后，android系统为我们提供了DownLoadManager类，这是android提供的系统服务，我们通过这个服务完成文件下载。整个下载过程全部交给系统负责，不需要我们过多的处理。<br>其包含两个内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">DownLoadManager.Query:主要用于查询下载信息。</div><div class="line">DownLoadManager.Request:主要用于发起一个下载请求。</div></pre></td></tr></table></figure></p>
<h2 id="2、功能实现"><a href="#2、功能实现" class="headerlink" title="2、功能实现"></a>2、功能实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用系统下载器下载</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">downloadAPK</span><span class="params">(String versionUrl, String versionName)</span> </span>&#123;</div><div class="line">	<span class="comment">//创建下载任务</span></div><div class="line">	DownloadManager.Request request = <span class="keyword">new</span> DownloadManager.Request(Uri.parse(versionUrl));</div><div class="line">	request.setAllowedOverRoaming(<span class="keyword">false</span>);<span class="comment">//漫游网络是否可以下载</span></div><div class="line">	request.setTitle(<span class="string">"jar包下载"</span>);<span class="comment">//下载是通知栏标题</span></div><div class="line">	<span class="comment">//request.setAllowedNetworkTypes() 设置制定网络下下载，传入系统常量值。</span></div><div class="line">	<span class="comment">//提供的网络常量有：NETWORK_BLUETOOTH、NETWORK_MOBILE、NETWORK_WIFI。</span></div><div class="line">	<span class="comment">//设置文件类型，可以在下载结束后自动打开该文件</span></div><div class="line">	MimeTypeMap mimeTypeMap = MimeTypeMap.getSingleton();</div><div class="line">	String mimeString = mimeTypeMap.getMimeTypeFromExtension(MimeTypeMap.getFileExtensionFromUrl(versionUrl));</div><div class="line">	request.setMimeType(mimeString);</div><div class="line">	<span class="comment">//在通知栏中显示，默认就是显示的</span></div><div class="line">	request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE);</div><div class="line">	request.setVisibleInDownloadsUi(<span class="keyword">true</span>);</div><div class="line">	<span class="comment">//sdcard的目录下的download文件夹，必须设置</span></div><div class="line">	request.setDestinationInExternalPublicDir(<span class="string">"/download/"</span>, versionName);</div><div class="line">	<span class="comment">//request.setDestinationInExternalFilesDir(),也可以自己制定下载路径</span></div><div class="line">	<span class="comment">//将下载请求加入下载队列</span></div><div class="line">	downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE);</div><div class="line">	<span class="comment">//加入下载队列后会给该任务返回一个long型的id，</span></div><div class="line">	<span class="comment">//通过该id可以取消任务，重启任务等等，看上面源码中框起来的方法</span></div><div class="line">	mTaskId = downloadManager.enqueue(request);</div><div class="line">	<span class="comment">//注册广播接收者，监听下载状态</span></div><div class="line">	registerReceiver(receiver,</div><div class="line">			<span class="keyword">new</span> IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>广播接收器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> BroadcastReceiver receiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">			checkDownloadStatus();<span class="comment">//检查下载状态</span></div><div class="line">		&#125;</div><div class="line">	&#125;;</div></pre></td></tr></table></figure></p>
<p> 检查下载状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkDownloadStatus</span><span class="params">()</span> </span>&#123;</div><div class="line">		DownloadManager.Query query = <span class="keyword">new</span> DownloadManager.Query();</div><div class="line">		query.setFilterById(mTaskId);<span class="comment">//筛选下载任务，传入任务ID，可变参数</span></div><div class="line">		Cursor c = downloadManager.query(query);</div><div class="line">		<span class="keyword">if</span> (c.moveToFirst()) &#123;</div><div class="line">			<span class="keyword">int</span> status = c.getInt(c.getColumnIndex(DownloadManager.COLUMN_STATUS));</div><div class="line">			<span class="keyword">switch</span> (status) &#123;</div><div class="line">				<span class="keyword">case</span> DownloadManager.STATUS_SUCCESSFUL:</div><div class="line">					Toast.makeText(<span class="keyword">this</span>,<span class="string">"下载完成"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> DownloadManager.STATUS_FAILED:</div><div class="line">					Toast.makeText(<span class="keyword">this</span>,<span class="string">"下载失败"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">					<span class="keyword">break</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-594ff4334e0749ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载效果"><br>文件下载路径<br><img src="http://upload-images.jianshu.io/upload_images/4821697-330a39205ab155e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件下载路径"></p>
<h1 id="JSON数据解析（Demo）"><a href="#JSON数据解析（Demo）" class="headerlink" title="JSON数据解析（Demo）"></a><center>JSON数据解析（Demo）</center></h1><h2 id="1、解析单条Json数据"><a href="#1、解析单条Json数据" class="headerlink" title="1、解析单条Json数据"></a>1、解析单条Json数据</h2><p><img src="http://upload-images.jianshu.io/upload_images/4821697-c5955f2768594479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单条数据"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//单条数据</span></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">parseItemJSONWithJSONObject</span><span class="params">(String jsonData)</span> </span>&#123;</div><div class="line">		String status=<span class="keyword">null</span>;</div><div class="line">		String message=<span class="keyword">null</span>;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//第一步：将从网络字符串jsonData字符串装入JSONObject</span></div><div class="line">			JSONObject jsonObject = <span class="keyword">new</span> JSONObject(jsonData);</div><div class="line">			<span class="comment">//第二步：因为单条数据，所以用jsonObject.getString方法直接取出对应键值</span></div><div class="line">			status = jsonObject.getString(<span class="string">"status"</span>);</div><div class="line">			message = jsonObject.getString(<span class="string">"message"</span>);</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="string">"status: "</span>+ status+<span class="string">"\n"</span>+<span class="string">"message: "</span> + message;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h2 id="2、解析多条Json数据"><a href="#2、解析多条Json数据" class="headerlink" title="2、解析多条Json数据"></a>2、解析多条Json数据</h2><p><img src="http://upload-images.jianshu.io/upload_images/4821697-25e7e6e9f747aa94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多条数据"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//多条数据</span></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">parseJSONWithJSONObject</span><span class="params">(String jsonData)</span> </span>&#123;</div><div class="line">		StringBuffer sb =<span class="keyword">new</span> StringBuffer();</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//第一步：将从网络字符串jsonData字符串装入JSONObject，即JSONObject</span></div><div class="line">			JSONObject jsonObject = <span class="keyword">new</span> JSONObject(jsonData);</div><div class="line">			<span class="comment">//第二步：因为多条数据，所以将"取出来的、要遍历的"字段装入JSONArray（这里要遍历data字段）</span></div><div class="line">			JSONArray jsonArray = jsonObject.getJSONArray(<span class="string">"data"</span>);</div><div class="line">			<span class="comment">//第三步：循环遍历，依次取出JSONObject对象</span></div><div class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jsonArray.length(); i++) &#123;</div><div class="line">				JSONObject jsonObject2 = jsonArray.getJSONObject(i);</div><div class="line">				String time = jsonObject2.getString(<span class="string">"time"</span>);</div><div class="line">				String ftime = jsonObject2.getString(<span class="string">"ftime"</span>);</div><div class="line">				String context = jsonObject2.getString(<span class="string">"context"</span>);</div><div class="line">				sb.append(<span class="string">"time: "</span> + time+<span class="string">"  "</span>+<span class="string">"ftime: "</span> + ftime+<span class="string">"\n"</span>+<span class="string">"context: "</span> + context+<span class="string">"\n\n"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> sb.toString();</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-ad25678b2163488b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单条"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-a3eafe8a7d865dc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多条"></p>
<h1 id="图片数据解析（Demo）"><a href="#图片数据解析（Demo）" class="headerlink" title="图片数据解析（Demo）"></a><center>图片数据解析（Demo）</center></h1><p>使用Http请求下载网络图片并通过handler机制更新系统ui。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String PATH = <span class="string">"https://www.baidu.com/img/bdlogo.png"</span>;</div><div class="line">	<span class="keyword">private</span> Button button;</div><div class="line">	<span class="keyword">private</span> ImageView imageView;</div><div class="line">	<span class="keyword">public</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">			<span class="keyword">if</span> (msg.what == RESULT_OK) &#123;</div><div class="line">				<span class="keyword">byte</span>[] data = (<span class="keyword">byte</span>[]) msg.obj;</div><div class="line">				<span class="comment">//使用Bitmap类解析图片</span></div><div class="line">				Bitmap bitmap = BitmapFactory.decodeByteArray(data, <span class="number">0</span>,</div><div class="line">						data.length);</div><div class="line">				imageView.setImageBitmap(bitmap);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		imageView = (ImageView) findViewById(R.id.imageView1);</div><div class="line">		button = (Button) findViewById(R.id.btn);</div><div class="line">		button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				picDown();</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">picDown</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">				HttpClient httpClient = <span class="keyword">new</span> DefaultHttpClient();</div><div class="line">				HttpGet httpGet = <span class="keyword">new</span> HttpGet(PATH);</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					HttpResponse httpResponse = httpClient.execute(httpGet);</div><div class="line">					<span class="keyword">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;</div><div class="line">						<span class="keyword">byte</span>[] data = EntityUtils.toByteArray(httpResponse</div><div class="line">								.getEntity());</div><div class="line">						Message message = Message.obtain();</div><div class="line">						message.obj = data;</div><div class="line">						message.what = RESULT_OK;</div><div class="line">						handler.sendMessage(message);</div><div class="line">					&#125;</div><div class="line">				&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; <span class="keyword">finally</span> &#123;</div><div class="line">					<span class="keyword">if</span> (httpClient != <span class="keyword">null</span></div><div class="line">							&amp;&amp; httpClient.getConnectionManager() != <span class="keyword">null</span>) &#123;</div><div class="line">						httpClient.getConnectionManager().shutdown();</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a>【附录】</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/JayKuzzi/Android/tree/master/HttpURLConnectionDemo" target="_blank" rel="external">HttpURLConnection</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/HttpCientDemo" target="_blank" rel="external">HttpCient</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/HttpURLConnectionListenerDemo" target="_blank" rel="external">HttpURLConnection抽象请求方法</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/FileDownload" target="_blank" rel="external">文件下载</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/JsonDemo" target="_blank" rel="external">JSON数据解析</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/PicDemo" target="_blank" rel="external">图片数据解析</a></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/02/12/Json/json.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="数据处理" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="数据处理" scheme="https://jaykuzzi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 异步处理之AsyncTask</title>
    <link href="https://jaykuzzi.github.io/2016/12/27/AsyncTask/"/>
    <id>https://jaykuzzi.github.io/2016/12/27/AsyncTask/</id>
    <published>2016-12-27T03:50:25.000Z</published>
    <updated>2017-06-27T12:12:07.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/12/27/AsyncTask/Asyn.jpeg" alt=""><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><center>前言</center></h1><p>在【<a href="http://www.jianshu.com/p/0c6939e41681" target="_blank" rel="external">异步处理之Handler</a>】中我们已经了解了<strong>关于线程</strong>的相关知识，明白<strong>为什么要进行异步处理</strong>以及使用Handler进行异步处理的方式，今天我们就来了解一下异步处理的另一种方式 —— <strong> AsyncTask。</strong></p>
<h1 id="AsyncTask简介"><a href="#AsyncTask简介" class="headerlink" title="AsyncTask简介"></a><center>AsyncTask简介</center></h1><p>Android应用的主线程（UI 线程）肩负着绘制用户界面和及时响应用户操作的重任，为了避免在主线程中做耗时操作而产生的ANR提示，我们就要把耗时的任务移出主线程，交给工作者线程去做。工作者线程主要有<a href="http://www.jianshu.com/p/9413ebc80381" target="_blank" rel="external">AsyncTask</a>、<a href="http://www.jianshu.com/p/eeb2bd59853f" target="_blank" rel="external">IntentService</a>、<a href="http://www.jianshu.com/p/0c6939e41681" target="_blank" rel="external">HandlerThread</a>，它们本质上都是对线程或线程池的封装。</p>
<h1 id="AsyncTask和Handler对比"><a href="#AsyncTask和Handler对比" class="headerlink" title="AsyncTask和Handler对比"></a><center>AsyncTask和Handler对比</center></h1><h2 id="1、AsyncTask实现的原理和适用的优缺点"><a href="#1、AsyncTask实现的原理和适用的优缺点" class="headerlink" title="1、AsyncTask实现的原理和适用的优缺点"></a>1、AsyncTask实现的原理和适用的优缺点</h2><p>AsyncTask提供的<strong>轻量级的异步类</strong>,可以<strong>直接继承AsyncTask</strong>,在类中<strong>实现异步操作</strong>,并<strong>提供接口反馈当前异步执行的程度</strong>(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.<br><strong>优点:简单快捷 、过程可控。</strong><br><strong>缺点:</strong><br><strong>在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来。</strong><br><strong>只是代码上轻量一些，而实际上要比handler更耗资源。</strong></p>
<h2 id="2、Handler异步实现的原理和适用的优缺点"><a href="#2、Handler异步实现的原理和适用的优缺点" class="headerlink" title="2、Handler异步实现的原理和适用的优缺点"></a>2、Handler异步实现的原理和适用的优缺点</h2><p>在Handler 异步实现时,涉及到 <strong>Handler, Looper, Message,Thread</strong>四个对象，实现异步的流程是<strong>主线程启动Thread（子线程）运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。</strong><br><strong>优点：结构清晰，功能定义明确，适于处理多个后台任务。</strong><br><strong>缺点： 在单个后台异步处理时，显得代码过多，结构过于复杂（相对性）。</strong><br><strong>【总的来说为了简化操作，Android1.5提供了工具类android.os.AsyncTask，它使创建异步任务变得更加简单，不再需要编写任务线程和Handler实例即可完成相同的任务。】</strong></p>
<h1 id="AsyncTask使用方式"><a href="#AsyncTask使用方式" class="headerlink" title="AsyncTask使用方式"></a><center>AsyncTask使用方式</center></h1><h2 id="1、三种泛型"><a href="#1、三种泛型" class="headerlink" title="1、三种泛型"></a>1、三种泛型</h2><p>AsyncTask直接继承于Object类，位置为android.os.AsyncTask。要使用AsyncTask工作我们要提供三个泛型参数，并重载几个方法。<br><strong>AsyncTask定义了三种泛型类型 Params、Progress、Result</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Params ：启动任务执行的输入参数，比如HTTP请求的URL。</div><div class="line">Progress ：后台任务执行的百分比。</div><div class="line">Result ：后台执行任务最终返回的结果，比如String。</div></pre></td></tr></table></figure></p>
<h2 id="2、必要"><a href="#2、必要" class="headerlink" title="2、必要"></a>2、必要</h2><p><strong>一个异步加载数据最少要重写以下这两个方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">doInBackground(Params…) </div><div class="line"><span class="comment">//后台(非主线程)执行比较耗时的操作,注意这里不能直接操作UI。</span></div><div class="line"><span class="comment">//doInBackground在执行过程中可以调用publishProgress(Progress…)来更新任务的进度。</span></div><div class="line">onPostExecute(Result)  </div><div class="line"><span class="comment">//(主线程执行)，相当于Handler处理UI的方式，可以使用在doInBackground 得到的结果处理操作UI。</span></div></pre></td></tr></table></figure></p>
<h2 id="3、非必要"><a href="#3、非必要" class="headerlink" title="3、非必要"></a>3、非必要</h2><p><strong>有必要的话你还得重写以下这三个方法，但不是必须的</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">onProgressUpdate(Progress…)   </div><div class="line"><span class="comment">//(主线程执行)可以使用进度条显示任务执行的进度。</span></div><div class="line">onPreExecute()        </div><div class="line"><span class="comment">//(主线程执行)当任务执行之前开始调用此方法，可以在这里显示进度对话框。</span></div><div class="line">onCancelled()             </div><div class="line"><span class="comment">//用户调用取消时，要做的操作。</span></div></pre></td></tr></table></figure></p>
<h2 id="4、准则"><a href="#4、准则" class="headerlink" title="4、准则"></a>4、准则</h2><p><strong>使用AsyncTask类，以下是几条必须遵守的准则</strong><br>1.Task的实例必须在UI thread中创建；<br>2.execute方法必须在UI thread中调用；<br>3.不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法；<br>4.该task只能被执行一次，否则多次调用时将会出现异常；</p>
<h1 id="AsyncTask小实例"><a href="#AsyncTask小实例" class="headerlink" title="AsyncTask小实例"></a><center>AsyncTask小实例</center></h1><h2 id="1、新建一个MyAsyncTask"><a href="#1、新建一个MyAsyncTask" class="headerlink" title="1、新建一个MyAsyncTask"></a>1、新建一个MyAsyncTask</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAsyncTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>, <span class="title">String</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ASYNC_TASK"</span>;</div><div class="line">	<span class="comment">//MainActivity的进度条</span></div><div class="line">	ProgressBar myprogressbar = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">//MainActivity的文本</span></div><div class="line">	TextView textView = <span class="keyword">null</span>;</div><div class="line">	<span class="comment">// MainActivity的上下文</span></div><div class="line">	Context mycontext = <span class="keyword">null</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyAsyncTask</span><span class="params">(ProgressBar progressbar, TextView textview, Context context)</span> </span>&#123;</div><div class="line">		myprogressbar = progressbar;</div><div class="line">		mycontext = context;</div><div class="line">		textView = textview;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//onPreExecute方法用于在执行后台任务前做一些UI操作</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPreExecute</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onPreExecute();</div><div class="line">		Log.i(TAG, <span class="string">"onPreExecute() called"</span>);</div><div class="line">		textView.setText(<span class="string">"正在加载..."</span>);</div><div class="line">		myprogressbar.setProgress(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//doInBackground方法内部执行后台任务,不可在此方法内修改UI</span></div><div class="line">	<span class="comment">//params 由UI线程调用execute()方法传入</span></div><div class="line">	<span class="comment">//返回的String类型参数被onPostExecute()方法调用。</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"doInBackground(Params... params) called"</span>);</div><div class="line">		String ret = <span class="keyword">null</span>;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 通过Begin,End演示多参数传值</div><div class="line">		 */</div><div class="line">		String Begin = params[<span class="number">0</span>];<span class="comment">//取出值Begin</span></div><div class="line">		String End = params[<span class="number">1</span>];<span class="comment">//取出值End</span></div><div class="line">		Log.i(TAG, <span class="string">"doInBackground"</span> + Begin);</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 模拟耗时步骤</div><div class="line">		 */</div><div class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">			<span class="comment">/**</span></div><div class="line">			 * 后台线程向UI线程发布进度状态i</div><div class="line">			 */</div><div class="line">			publishProgress(i);</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				Thread.sleep(<span class="number">500</span>);</div><div class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		Log.i(TAG, <span class="string">"doInBackground"</span> + End);</div><div class="line">		ret = <span class="string">"更新完毕"</span>;</div><div class="line">		<span class="keyword">return</span> ret;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//onPostExecute方法用于在执行完后台任务后更新UI,显示结果</span></div><div class="line">	<span class="comment">//result为doInBackground()返回的参数</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onPostExecute(result);</div><div class="line">		Log.i(TAG, <span class="string">"onPostExecute(Result result) called"</span>);</div><div class="line">		textView.setText(result);</div><div class="line">	 &#125;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="comment">//onProgressUpdate方法用于更新进度信息</span></div><div class="line">	<span class="comment">//values为doInBackground()中publishProgress()返回的参数</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onProgressUpdate</span><span class="params">(Integer... values)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onProgressUpdate(values);</div><div class="line">		Log.i(TAG, <span class="string">"onProgressUpdate(Progress... progresses) called"</span>);</div><div class="line">		<span class="keyword">int</span> progress = myprogressbar.getMax() / <span class="number">10</span> * (values[<span class="number">0</span>] + <span class="number">1</span>);</div><div class="line">		myprogressbar.setProgress(progress);</div><div class="line">		textView.setText(<span class="string">"正在加载..."</span> + progress + <span class="string">"%"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//onCancelled方法用于在取消执行中的任务时更改UI</span></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCancelled</span><span class="params">()</span> </span>&#123;</div><div class="line">		Log.i(TAG, <span class="string">"onCancelled() called"</span>);</div><div class="line">		textView.setText(<span class="string">"已被取消"</span>);</div><div class="line">		myprogressbar.setProgress(<span class="number">0</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、MainActivity代码"><a href="#2、MainActivity代码" class="headerlink" title="2、MainActivity代码"></a>2、MainActivity代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> ProgressBar myProgressBar;</div><div class="line">	<span class="keyword">private</span> Button start, cancel;</div><div class="line">	<span class="keyword">private</span> TextView textView;</div><div class="line">	<span class="keyword">private</span> MyAsyncTask mTask;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		myProgressBar = (ProgressBar) findViewById(R.id.progressBar);</div><div class="line">		start = (Button) findViewById(R.id.start);</div><div class="line">		cancel = (Button) findViewById(R.id.cancel);</div><div class="line">		textView = (TextView) findViewById(R.id.tv);</div><div class="line">		start.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="comment">//注意每次需new一个实例,新建的任务只能执行一次,否则会出现异常</span></div><div class="line">				<span class="comment">//启动异步任务，并传入"Begin","End"值演示UI线程向后端线程传值的情况</span></div><div class="line">				mTask = <span class="keyword">new</span> MyAsyncTask(myProgressBar, textView, getApplicationContext());</div><div class="line">				mTask.execute(<span class="string">"Begin"</span>, <span class="string">"End"</span>);</div><div class="line">				start.setEnabled(<span class="keyword">false</span>);</div><div class="line">				cancel.setEnabled(<span class="keyword">true</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">		cancel.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				mTask.cancel(<span class="keyword">true</span>);</div><div class="line">				start.setEnabled(<span class="keyword">true</span>);</div><div class="line">				cancel.setEnabled(<span class="keyword">false</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3、效果"><a href="#3、效果" class="headerlink" title="3、效果"></a>3、效果</h2><p><strong>点击开始</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-0d07871c9156e3df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击开始"><br><strong>执行完毕</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-3759676023cd0060.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="执行完毕"><br><strong>打印结果，注意执行顺序</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-603be85ceb429075.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印结果，注意执行顺序"><br><strong>执行取消</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-3285aae13999c07f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="取消"><br><strong>打印结果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-165470f94ce0fce9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印结果"></p>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a>【附录】</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/JayKuzzi/Android/tree/master/AsyncTaskDemo" target="_blank" rel="external">AsyncTaskDemo</a></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/12/27/AsyncTask/Asyn.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="异步处理" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="异步处理" scheme="https://jaykuzzi.github.io/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 异步处理之Handler</title>
    <link href="https://jaykuzzi.github.io/2016/10/27/Handler/"/>
    <id>https://jaykuzzi.github.io/2016/10/27/Handler/</id>
    <published>2016-10-27T02:38:09.000Z</published>
    <updated>2017-06-27T12:12:37.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/10/27/Handler/handler.jpg" alt=""><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><center>前言</center></h1><p>在学习Handler之前，我们要先了解一下<strong>ActivityThread（主线程或UI线程）。</strong></p>
<h2 id="1、简介特点"><a href="#1、简介特点" class="headerlink" title="1、简介特点"></a>1、简介特点</h2><p><strong>管理应用进程的主线程的执行</strong>(相当于普通Java程序的main入口函数)，并根据AMS的要求负责调度和执行activities、broadcasts和其它操作。<br>默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的<strong>【主线程】</strong>负责执行。 <strong>如果有特别指定(通过android:process)，也可以让特定组件在不同的进程中运行。</strong></p>
<h2 id="2、主要责任"><a href="#2、主要责任" class="headerlink" title="2、主要责任"></a>2、主要责任</h2><p><strong>责任1: 快速处理UI事件</strong><br>只有它才处理UI事件， 其它线程还不能存取UI画面上的对象(如TextView等)，所以， 主线程也叫做UI线程。<br><strong>责任2: 快速处理Broadcast消息</strong><br>在BroadcastReceiver的onReceive()函数中，不宜占用太长的时间，否则导致【主线程】无法处理其它的Broadcast消息或UI事件。</p>
<h2 id="3、特别规定（必须遵循）"><a href="#3、特别规定（必须遵循）" class="headerlink" title="3、特别规定（必须遵循）"></a>3、特别规定（必须遵循）</h2><p><strong>规定1：不可以在UI线程做耗时操作</strong><br>Android要求UI线程能根据用户的要求做出快速响应，如果<strong>UI事件让用户等待时间超过5秒而未处理</strong>，或者在<strong>广播接收者操作占用时间超过10秒</strong>， Android系统就会给用户显示<strong>ANR（Application is not responding）</strong>提示信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//产生耗时操作</span></div><div class="line">bt1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">								<span class="keyword">try</span> &#123;</div><div class="line">										<span class="comment">// 让UI线程睡上20s</span></div><div class="line">										Thread.sleep(<span class="number">20000</span>);</div><div class="line">								&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">										e.printStackTrace();</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;);</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4821697-3af56c3e38d556c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ANR"><br><strong>规定2：不可以子线程中更新UI</strong><br>Android要求在创建了ViewRootImpl之后不可在非UI线程中更新UI。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">bt1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">		<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">			bt1.setText(<span class="string">"子线程操作UI"</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;).start();</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Process: com.bb.handlerdemo, PID: <span class="number">2531</span></div><div class="line">android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views.</div></pre></td></tr></table></figure></p>
<h2 id="4、知识扩展"><a href="#4、知识扩展" class="headerlink" title="4、知识扩展"></a>4、知识扩展</h2><p>如果我们把子线程操作UI的代码这样写，反而没有报异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				bt1= (Button) findViewById(R.id.bt1);</div><div class="line"><span class="comment">//        bt1.setOnClickListener(new View.OnClickListener() &#123;</span></div><div class="line"><span class="comment">//            @Override</span></div><div class="line"><span class="comment">//            public void onClick(View view) &#123;</span></div><div class="line"><span class="comment">//                new Thread(new Runnable() &#123;</span></div><div class="line"><span class="comment">//                    @Override</span></div><div class="line"><span class="comment">//                    public void run() &#123;</span></div><div class="line"><span class="comment">//                        bt1.setText("子线程操作UI");</span></div><div class="line"><span class="comment">//                    &#125;</span></div><div class="line"><span class="comment">//                &#125;).start();</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//        &#125;);	</span></div><div class="line">				<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">						bt1.setText(<span class="string">"子线程操作UI1"</span>);</div><div class="line">						&#125;</div><div class="line">				&#125;).start();				</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>解释：在onCreate方法中创建的子线程访问UI是一种极端的情况。<br>ViewRootImpl的创建是在onResume方法回调之后，而我们是在onCreate方法中创建了子线程并访问UI，在那个时刻，ViewRootImpl是没有创建的，无法通过checkThread方法检查当前线程，所以程序没有崩溃一样能跑起来。<br>如果我们在线程里睡眠1秒钟，程序就崩了。很明显1秒后ViewRootImpl已经创建了。</p>
<h1 id="Handler简述"><a href="#Handler简述" class="headerlink" title="Handler简述"></a><center>Handler简述</center></h1><h2 id="Handler是什么"><a href="#Handler是什么" class="headerlink" title="Handler是什么"></a>Handler是什么</h2><p>若把一些类似于下载的功能（既耗时且不一定有结果）写在Activity(主线程)里，会违背<strong>“前言中写到特别规定”</strong>从而导致Activity线程阻塞，产生ANR提示。因此，需要把这些耗时的操作放在单独的子线程中。<strong>这就是Handler的使命，Handler提供异步处理的功能，接受子线程发送的数据，并用此数据配合主线程更新UI。</strong><br>【android在设计的时候就封装了一套消息创建、传递、处理的Handler机制。如果不遵循就不能更新UI信息，就会报出异常。】</p>
<h2 id="两个作用"><a href="#两个作用" class="headerlink" title="两个作用"></a>两个作用</h2><p>(1)安排消息或Runnable 在某个主线程中某个地方执行；<br>(2)安排一个动作在不同的线程中执行。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//post类方法允许你排列一个Runnable对象到主线程队列中</span></div><div class="line">post(Runnable)<span class="comment">//将Runnable直接添加入队列</span></div><div class="line">postAtTime(Runnable，<span class="keyword">long</span>)<span class="comment">//延迟一定时间后，将Runnable添加入队列</span></div><div class="line">postDelayed(Runnable <span class="keyword">long</span>)<span class="comment">//定时将Runnable添加入队列</span></div><div class="line"><span class="comment">//sendMessage类方法， 允许你安排一个带数据的Message对象到队列中，等待更新。</span></div><div class="line">sendEmptyMessage(<span class="keyword">int</span> what)<span class="comment">//向队列添加直接添加消息, 与sendMessage相比一个传</span></div><div class="line"><span class="comment">//Message类型的msg，一个传int类型的what，传what的，最终会转为msg。</span></div><div class="line">sendMessage(Message)<span class="comment">//向队列添加直接添加消息</span></div><div class="line">sendMessageAtTime(Message，<span class="keyword">long</span>)<span class="comment">//定时将消息发送到消息队列</span></div><div class="line">sendMessageDelayed(Message，<span class="keyword">long</span>)<span class="comment">//延迟一定时间后，将消息发送到消息队列</span></div></pre></td></tr></table></figure>
<h1 id="Handler实现原理"><a href="#Handler实现原理" class="headerlink" title="Handler实现原理"></a><center>Handler实现原理</center></h1><h2 id="1、相关概念"><a href="#1、相关概念" class="headerlink" title="1、相关概念"></a>1、相关概念</h2><p><strong>Message</strong><br>消息，理解为线程间通讯的数据单元。例如后台线程在处理数据完毕后需要更新UI，则可发送一条包含更新信息的Message给UI线程。<br><strong>Message Queue</strong><br>消息队列，由Looper管理，用来存放通过Handler发布的消息，按照先进先出执行。<br><strong>Handler</strong><br>Handler是Message的主要处理者，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给他的消息。<br>每个Handler实例，都会绑定到创建他的线程中(<strong>一般是位于主线程</strong>)。<br><strong>Looper</strong><br>循环器，每个线程只有一个Looper，他负责管理MessageQueue，会<strong>不断的从MessageQueue取出消息</strong>，分发给对象的handler。<br><strong>为了保证当前线程有Looper对象，可以有两种情况处理。</strong><br>（1）主ui线程启动，系统就初始化了一个Looper对象，只要在程序中直接创建handler，它就会和Looper自动绑定，然后用handler发送和处理消息。<br>（2）我们自己创建的线程要自己手动创建一个Looper对象了，因为除主线程外，Android中的线程默认是没有开启Looper的。创建Looper对象调用它的prepare()方法 是为了保证每个线程最多一个Looper对象。然后用Looper.loop()启动它。此时loop()方法就会使用一个死循环不断地取出MessageQueue()中的消息，并将消息分给所对应的Handler处理。<br>【注意】写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。<br><strong>线程</strong><br>UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。<br><strong>总结</strong><br><strong> Handler负责发送消息，Loop负责接收到Message Queue容器中</strong><br><strong>一个线程里只有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义多个Handler实例</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-8234c68d54c9573e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="流程"></p>
<h2 id="2、为什么要用handler机制更新UI"><a href="#2、为什么要用handler机制更新UI" class="headerlink" title="2、为什么要用handler机制更新UI"></a>2、为什么要用handler机制更新UI</h2><p>最根本的目的就是为了<strong>解决多线程并发的问题！</strong>如果在一个activity中有多个线程去更新UI，并且没有加锁，就会出现界面错乱的问题。但是如果对这些更新UI的操作都加锁处理，又会导致性能下降。<br><strong>处于对性能的问题考虑</strong>，不用再去关系多线程的问题，所有的更新UI的操作，都是在主线程的<strong>消息队列中去轮训</strong>的。</p>
<h2 id="3、handler实现流程"><a href="#3、handler实现流程" class="headerlink" title="3、handler实现流程"></a>3、handler实现流程</h2><p><img src="http://upload-images.jianshu.io/upload_images/4821697-87f0b1e5592912e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="协作关系"></p>
<p><center>Handler实例（Demo）</center></p>
<h2 id="1、安排消息或Runnable-在某个主线程中某个地方执行；"><a href="#1、安排消息或Runnable-在某个主线程中某个地方执行；" class="headerlink" title="1、安排消息或Runnable 在某个主线程中某个地方执行；"></a>1、安排消息或Runnable 在某个主线程中某个地方执行；</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">		<span class="comment">//Handler安排 Runnable 在某个主线程中某个地方执行</span></div><div class="line">		Handler handler = <span class="keyword">new</span> Handler();</div><div class="line">		Runnable thread = <span class="keyword">new</span> Runnable() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">						System.out.println(<span class="string">"HandlerThread:"</span> + Thread.currentThread().getId());</div><div class="line">				&#125;</div><div class="line">		&#125;;</div><div class="line">		<span class="keyword">private</span> Button start;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				start = (Button) findViewById(R.id.start);</div><div class="line">				start.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">								handler.post(thread);</div><div class="line">						&#125;</div><div class="line">				&#125;);</div><div class="line">				System.out.println(<span class="string">"Activity Thread:"</span> + Thread.currentThread().getId());</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个程序看上去似乎实现了Handler的异步机制，handler.post(thread)似乎实现了新启线程的作用，不过通过执行我们发现，两个线程的ID相同！也就是说，实际上thread还是原来 的主线程，由此可见，handler.post()方法并未真正新建线程，只是在原线程上执行而已，我们并未实现异步机制。我们再看下面这个Demo。</p>
<h2 id="2、安排一个动作在其他的线程中执行。（其他线程通过Handler机制UI线程中Button的内容）"><a href="#2、安排一个动作在其他的线程中执行。（其他线程通过Handler机制UI线程中Button的内容）" class="headerlink" title="2、安排一个动作在其他的线程中执行。（其他线程通过Handler机制UI线程中Button的内容）"></a>2、安排一个动作在其他的线程中执行。（其他线程通过Handler机制UI线程中Button的内容）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">		Button button;</div><div class="line">		MyHandler myHandler;</div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				button = (Button) findViewById(R.id.start);</div><div class="line">				<span class="comment">//打印主线程id</span></div><div class="line">				Log.d(<span class="string">"ThreadId"</span>, <span class="string">"MainThreadId:"</span>+Thread.currentThread().getId()+<span class="string">""</span>);</div><div class="line">				<span class="comment">// 当创建一个新的Handler实例时，它会绑定到当前线程和消息的队列中，开始分发数据</span></div><div class="line">				myHandler = <span class="keyword">new</span> MyHandler();				</div><div class="line">				<span class="comment">//开启子线程</span></div><div class="line">				MyThread m = <span class="keyword">new</span> MyThread();</div><div class="line">				<span class="keyword">new</span> Thread(m).start();</div><div class="line">		&#125;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 接收消息，处理消息 ，此Handler会与当前主线程一块运行</div><div class="line">		 * */</div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">()</span> </span>&#123;</div><div class="line">				&#125;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Looper L)</span> </span>&#123;</div><div class="line">						<span class="keyword">super</span>(L);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// 子类必须重写此方法，接收数据</span></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">						Log.d(<span class="string">"MyHandler"</span>, <span class="string">"handleMessage。。。。。。"</span>);</div><div class="line">						<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">						<span class="comment">// 此处可以更新UI</span></div><div class="line">						Bundle b = msg.getData();</div><div class="line">						String color = b.getString(<span class="string">"color"</span>);</div><div class="line">						MainActivity.<span class="keyword">this</span>.button.setText(color);</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">								<span class="comment">//6秒执行完毕</span></div><div class="line">								Thread.sleep(<span class="number">6000</span>);</div><div class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">								e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">						Log.d(<span class="string">"ThreadId"</span>,<span class="string">"MainThreadId:"</span>+Thread.currentThread().getId()+<span class="string">""</span>);</div><div class="line">						Message msg = <span class="keyword">new</span> Message();</div><div class="line">						Bundle b = <span class="keyword">new</span> Bundle();<span class="comment">// 存放数据</span></div><div class="line">						b.putString(<span class="string">"color"</span>,<span class="string">"我的名字"</span>);</div><div class="line">						msg.setData(b);</div><div class="line">						MainActivity.<span class="keyword">this</span>.myHandler.sendMessage(msg); <span class="comment">// 向Handler发送消息，更新UI</span></div><div class="line"></div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/4821697-5574c20eaad1681e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="打印不同线程id"><br>通过打印我们可以看到，两个ID是不同的，新的线程启动了！</p>
<h2 id="3、HandlerThread-总结使用"><a href="#3、HandlerThread-总结使用" class="headerlink" title="3、HandlerThread 总结使用"></a>3、HandlerThread 总结使用</h2><p>（1）引言：我们为一个非主线程开启一个Handler时候需要这么做<br><img src="http://upload-images.jianshu.io/upload_images/4821697-78d010ad620a00bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>很明显的一点就是，我们要在子线程中调用Looper.prepare() 为一个线程开启一个消息循环，默认情况下Android中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建Looper对象，开启消息循环。） Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。 然后通过Looper.loop() 让Looper开始工作，从消息队列里取消息，处理消息。<br><strong><em>注意：写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。</em></strong><br><strong>「其实这一切都可以用HandlerThread类来帮我们做。」</strong><br>（2）常规用法<br>创建一个HandlerThread<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"handler_thread"</span>);</div></pre></td></tr></table></figure></p>
<p>启动一个HandlerThread<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mThread.start();</div></pre></td></tr></table></figure></p>
<p>（3）小实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> HandlerThread myHandlerThread;</div><div class="line">		<span class="keyword">private</span> Handler handler;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				<span class="comment">//创建一个线程,线程名字：handler-thread</span></div><div class="line">				myHandlerThread = <span class="keyword">new</span> HandlerThread(<span class="string">"handler-thread"</span>);</div><div class="line">				<span class="comment">//开启一个线程</span></div><div class="line">				myHandlerThread.start();</div><div class="line">				<span class="comment">//在这个线程中创建一个handler对象</span></div><div class="line">				handler = <span class="keyword">new</span> Handler(myHandlerThread.getLooper()) &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</div><div class="line">								<span class="keyword">super</span>.handleMessage(msg);</div><div class="line">								<span class="comment">//这个方法是运行在 handler-thread 线程中的 ，可以执行耗时操作</span></div><div class="line">								Log.d(<span class="string">"handler "</span>, <span class="string">"消息： "</span> + msg.what + <span class="string">"  线程： "</span> + Thread.currentThread().getName());</div><div class="line">						&#125;</div><div class="line">				&#125;;</div><div class="line">				<span class="comment">//在主线程给handler发送消息</span></div><div class="line">				handler.sendEmptyMessage(<span class="number">1</span>);</div><div class="line">				<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">								<span class="comment">//在子线程给handler发送数据</span></div><div class="line">								handler.sendEmptyMessage(<span class="number">2</span>);</div><div class="line">						&#125;</div><div class="line">				&#125;).start();</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onDestroy();</div><div class="line">				<span class="comment">//释放资源</span></div><div class="line">				myHandlerThread.quit();</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行效果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/com.app D/handler: 消息： <span class="number">1</span>  线程： handler-thread</div><div class="line">/com.app D/handler: 消息： <span class="number">2</span>  线程： handler-thread</div></pre></td></tr></table></figure></p>
<p>（4）HandlerThread的特点<br>HandlerThread将loop转到子线程中处理，说白了就是将分担MainLooper的工作量，降低了主线程的压力，使主界面更流畅。<br>HandlerThread拥有自己的消息队列，它不会干扰或阻塞UI线程。<br>对于网络IO操作，HandlerThread并不适合，因为它只有一个线程，还得排队一个一个等着。</p>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a>【附录】</h1><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><a href="https://github.com/JayKuzzi/Android/tree/master/HandlerDemo01" target="_blank" rel="external">1、安排消息或Runnable 在某个主线程中某个地方执行；</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/HandlerDemo02" target="_blank" rel="external">2、安排一个动作在其他的线程中执行。（其他线程通过Handler机制UI线程中Button的内容）</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/HandlerDemo03" target="_blank" rel="external">3、HandlerThread 总结使用</a></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/10/27/Handler/handler.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="异步处理" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="异步处理" scheme="https://jaykuzzi.github.io/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 屏幕适配及布局优化</title>
    <link href="https://jaykuzzi.github.io/2016/08/27/ScreenAdaptation/"/>
    <id>https://jaykuzzi.github.io/2016/08/27/ScreenAdaptation/</id>
    <published>2016-08-27T02:15:24.000Z</published>
    <updated>2017-06-27T12:14:02.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/08/27/ScreenAdaptation/ScreenAdaptation.jpeg" alt=""><br><a id="more"></a></p>
<h1 id="为什么要进行屏幕适配"><a href="#为什么要进行屏幕适配" class="headerlink" title="为什么要进行屏幕适配"></a><center>为什么要进行屏幕适配</center></h1><p><strong>为什么要进行屏幕适配、对哪些设备进行适配？</strong><br>在近几年的发展当中，安卓设备数量逐渐增长，由于安卓设备的开放性，导致安卓设备的屏幕尺寸大小碎片化极为严重。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-1bb40c6ad800aab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Android设备分辨率"><br>从<a href="http://tip.umeng.com/uploads/data_report/2016phone.pdf?spm=0.0.0.0.OcsHmH&amp;file=2016phone.pdf" target="_blank" rel="external">【友盟+】2016年手机生态发展报告H1 </a>中看截止16年手机分辨率使用情况：Android设备720p和1080p是主流，如果对前5中Android设备分辨率进行适配就能让app在90%的安卓设备上比较美观的兼容。</p>
<h1 id="涉及重要概念及关系"><a href="#涉及重要概念及关系" class="headerlink" title="涉及重要概念及关系"></a><center>涉及重要概念及关系</center></h1><h2 id="1-硬件属性-──-屏幕尺寸、屏幕分辨率、屏幕像素密度"><a href="#1-硬件属性-──-屏幕尺寸、屏幕分辨率、屏幕像素密度" class="headerlink" title="1.硬件属性 ── 屏幕尺寸、屏幕分辨率、屏幕像素密度"></a>1.硬件属性 ── 屏幕尺寸、屏幕分辨率、屏幕像素密度</h2><p>【屏幕尺寸】：屏幕对角线长度。单位是英寸，1英寸=2.54厘米。<br>【屏幕分辨率】：屏幕横纵向上的像素点数。单位是px，1px=1像素点。<br>【像素密度】：屏幕每英寸上的像素点数，单位是dpi，即dot per inch缩写。<br>【关系及总结】：屏幕同尺寸分辨率越高(像素点越多),像素密度越大,显示效果越好。<br><strong>像素密度=横向像素点数^2+纵向像素点数^2然后开方取得值,除以屏幕尺寸。</strong><br>【举例】：【Nexus 5 ：4.95英寸、1920*1080、445dpi】<br>445dpi=（√(1080^2+1920^2)）px／4.95 inch</p>
<h2 id="2-计量单位-──-dp、dip、dpi、sp、px。"><a href="#2-计量单位-──-dp、dip、dpi、sp、px。" class="headerlink" title="2.计量单位 ── dp、dip、dpi、sp、px。"></a>2.计量单位 ── dp、dip、dpi、sp、px。</h2><p>【dpi】：屏幕每英寸上的像素点数，单位是dpi，即dot per inch缩写。<br>【px】：像素，构成图像的最小单位。（进行ui设计、官方原生api返回的数值都是以px作为计量单位的，比如获取屏幕的宽和高。）<br>【dp、dip】：密度无关像素。即Density Independent Pixels缩写。（dp等同于dip，以160dpi为基准，1dp=1px。dp意义在于：你可以根据看到的实际大小，在应用中设置对应的dp值，而使得不同的设备上看起来一样大。）<br>【sp】：即Scale-Independent Pixels。可以根据文字大小首选项进行缩放。推荐使用12sp以上大小的文字；推荐使用12sp、14sp、18sp、22sp；字体大小不要使用奇数和小数，在字体放缩的时候可能导致精度的丢失。<br>【举例】：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-b5b5ff703135bb74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dp与px"></p>
<h2 id="3-像素密度-──-mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi。"><a href="#3-像素密度-──-mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi。" class="headerlink" title="3.像素密度 ── mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi。"></a>3.像素密度 ── mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi。</h2><p>不同的设备上实现非常好的显示效果，因此有多种像素密，主流的5种像素：mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi，以2:3:4:6:8的比例缩放，可修饰drawable和values。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-32018220f069aa96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>AndroidManifest.xml设置在中Menifest中添加子元素android:anyDensity=”true”时，应用程序安装在不同密度的终端上时，程序会分别加载xxhdpi、xhdpi、hdpi、mdpi、ldpi文件夹中的资源。相反，如果设为false，即使在文件夹下拥有相同资源，应用不会自动地去相应文件夹下寻找资源。</p>
<h1 id="解决方案及布局优化适配各种屏幕尺寸"><a href="#解决方案及布局优化适配各种屏幕尺寸" class="headerlink" title="解决方案及布局优化适配各种屏幕尺寸"></a><center>解决方案及布局优化适配各种屏幕尺寸</center></h1><h2 id="I-线性布局中使用：wrap-content、match-parent、weight属性。"><a href="#I-线性布局中使用：wrap-content、match-parent、weight属性。" class="headerlink" title="(I)线性布局中使用：wrap_content、match_parent、weight属性。"></a>(I)线性布局中使用：wrap_content、match_parent、weight属性。</h2><p>在设置控件长宽的时候一般有三种方案：<br>1.直接用dp属性将控件写死。<br>2.wrap_content内容自适应。<br>3.match_parent填充父布局。<br>以下如图为使用wrap_content、match_parent、weight属性实现的小例子：<br>用weight属性将tittle栏中间控件进行拉伸适配，左右控件大小不变。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-adb884560a3a4352.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="用weight属性将tittle栏中间控件进行拉伸适配"><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--实现原理：将中间控件权重设为1--&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">				<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">				<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line">				<span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">						<span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">						<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">						<span class="attr">android:text</span>=<span class="string">"左侧控件"</span> /&gt;</div><div class="line">				<span class="tag">&lt;<span class="name">TextView</span></span></div><div class="line">						<span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">						<span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">						<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">						<span class="attr">android:text</span>=<span class="string">"Hello World!"</span></div><div class="line">						<span class="attr">android:textSize</span>=<span class="string">"25sp"</span></div><div class="line">						<span class="attr">android:background</span>=<span class="string">"#f5f5f5"</span>/&gt;</div><div class="line">				<span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">						<span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">						<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">						<span class="attr">android:text</span>=<span class="string">"右侧控件 右侧控件"</span> /&gt;</div><div class="line">		<span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>[weight属性扩展]<br>将一排所有控件都加上权重比例时，此时可以将宽度 wrap_content 改为0dp<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span></span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">		<span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">				<span class="attr">android:layout_weight</span>=<span class="string">"1"</span></div><div class="line">				<span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">				<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:text</span>=<span class="string">"左侧控件"</span></div><div class="line">				/&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">				<span class="attr">android:layout_weight</span>=<span class="string">"2"</span></div><div class="line">				<span class="attr">android:layout_width</span>=<span class="string">"0dp"</span></div><div class="line">				<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:text</span>=<span class="string">"右侧控件"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4821697-8cc23c7fc72e74ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将一排所有控件都加上权重"><br>若将layout_width属性设为match_parent的话，比例将会颠倒。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-b19ffcbf7ddc1e1a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="将layout_width属性设为match_parent"><br><strong>[原因]</strong><br>weight等式为：<br>weight计算出的宽度＝原来的宽度＋屏幕剩余控件宽度所占的百分比<br><strong>[解释]</strong><br>假设屏幕宽度为L<br>则左侧控件宽度=L(match_parent)+[L-2L(两个控件总宽)]<em>1/3=2/3L<br>同理右侧控件宽度=L(match_parent)+[L-2L(两个控件总宽)]</em>2/3=1/3L<br>为了证明等式成立，将宽度改为0dp再算一次<br>则左侧控件宽度=0dp+[L-0-0]<em>1/3=1/3L<br>则左侧控件宽度=0dp+[L-0-0]</em>2/3=2/3L</p>
<h2 id="II-使用相对布局、禁用绝对布局。"><a href="#II-使用相对布局、禁用绝对布局。" class="headerlink" title="(II)使用相对布局、禁用绝对布局。"></a>(II)使用相对布局、禁用绝对布局。</h2><p>绝对布局以一坐标的方式来定位在屏幕上的位置，此布局难维护，一旦屏幕分辨率发生变化，<br>由于相对位置绝对性，控件将不会自动适配宽高，如图。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-642fd0489e45b5d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="绝对布局在不同分辨率下适配情况"><br>线性布局优势可以用weight去适配屏幕的比例大小，但是一些比较复杂的布局，线性布局使用起来就比较麻烦，<br>这个时候我们可以使用相对布局来适配优化，如图为官方demo，第二排的ok按钮，我们只需要让它紧贴父布局右侧。<br>Cancel按钮只需位于OK按钮左侧。（若用线性布局去实现，则至少需要两次嵌套。）<br><img src="http://upload-images.jianshu.io/upload_images/4821697-f4d271514472cd72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手机和平板适配"><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">RelativeLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span></div><div class="line">	 &gt;</div><div class="line">		<span class="tag">&lt;<span class="name">EditText</span></span></div><div class="line">				<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">				<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:id</span>=<span class="string">"@+id/edit"</span> /&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">				<span class="attr">android:layout_alignParentRight</span>=<span class="string">"true"</span></div><div class="line">				<span class="attr">android:layout_below</span>=<span class="string">"@id/edit"</span></div><div class="line">				<span class="attr">android:text</span>=<span class="string">"OK"</span></div><div class="line">				<span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:id</span>=<span class="string">"@+id/button2"</span> /&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">Button</span></span></div><div class="line">				<span class="attr">android:layout_toLeftOf</span>=<span class="string">"@id/button2"</span></div><div class="line">				<span class="attr">android:layout_below</span>=<span class="string">"@id/edit"</span></div><div class="line">				<span class="attr">android:text</span>=<span class="string">"CANCEL"</span></div><div class="line">				<span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></div><div class="line">				<span class="attr">android:id</span>=<span class="string">"@+id/button3"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">RelativeLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="III-使用限定符适配平板设备：large限定符、最小限定符、方向限定符。"><a href="#III-使用限定符适配平板设备：large限定符、最小限定符、方向限定符。" class="headerlink" title="(III)使用限定符适配平板设备：large限定符、最小限定符、方向限定符。"></a>(III)使用限定符适配平板设备：large限定符、最小限定符、方向限定符。</h2><p>[使用large限定符]分别创建layout/main.xml，layout-large/main.xml下的不同布局，以适配手机和平板。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//res/layout/main.xml 单面板</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">		<span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">"@+id/headlines"</span></span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">aandroid:layout_width</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line"></div><div class="line">//res/layout-large/main.xml 双面板</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">"@+id/headlines"</span></span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:name</span>=<span class="string">"com.bb.HeadlinesFragment"</span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"400dp"</span></div><div class="line">		<span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span>/&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">"@+id/article"</span></span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:name</span>=<span class="string">"com.bb.ArticleFragment"</span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure>
<p><strong>注意large限定符是在安卓3.2版本以前版本才会起作用的！3.2之后，为了能更精确判断平板范围，谷歌推出了[最小宽度限定符]。</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">//res/layout/main.xml，单面板（默认）布局：</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">		<span class="attr">android:orientation</span>=<span class="string">"vertical"</span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">"@+id/headlines"</span></span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:name</span>=<span class="string">"com.bb.HeadlinesFragment"</span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div><div class="line">//res/layout-sw600dp/main.xml，双面板布局：  Small Width 最小宽度</div><div class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:orientation</span>=<span class="string">"horizontal"</span>&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">"@+id/headlines"</span></span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:name</span>=<span class="string">"com.bb.HeadlinesFragment"</span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"400dp"</span></div><div class="line">		<span class="attr">android:layout_marginRight</span>=<span class="string">"10dp"</span>/&gt;</div><div class="line">		<span class="tag">&lt;<span class="name">fragment</span> <span class="attr">android:id</span>=<span class="string">"@+id/article"</span></span></div><div class="line">		<span class="attr">android:layout_height</span>=<span class="string">"fill_parent"</span></div><div class="line">		<span class="attr">android:name</span>=<span class="string">"com.bb.ArticleFragment"</span></div><div class="line">		<span class="attr">android:layout_width</span>=<span class="string">"fill_parent"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>通过以上，想要兼容安卓3.2之前的平板设备，需要设置添加这三种lyout。<br>res/layout/main.xml:             单面板布局<br>res/layout-large/main.xml:       多面板布局<br>res/layout-sw600dp/main.xml:     多面板布局<br>这样维护起来比较困难，如改变large面板布局，还要去更改sw600dp 面板。<br>我们引入[布局别名]：将多面板相同的地方抽取出来设为main_twopanes进行统一的管理。<br>res/layout/main.xml              单面板布局<br>res/layout/main_twopanes.xml     双面板布局<br>所以我们这么来操作。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">setContentView(R.layout.custom-main);</div><div class="line">默认布局</div><div class="line">res/values/layout.xml:</div><div class="line">&lt;resources&gt;</div><div class="line">&lt;item name="custom-main" type="layout"&gt;@layout/main&lt;/item&gt;</div><div class="line">&lt;/resources&gt;</div><div class="line">Android3.2之前的平板布局</div><div class="line">res/values-large/layout.xml:</div><div class="line">&lt;resources&gt;</div><div class="line">&lt;item name="custom-main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;</div><div class="line">&lt;/resources&gt;</div><div class="line">Android3.2之后的平板布局</div><div class="line">res/values-sw600dp/layout.xml:</div><div class="line">&lt;resources&gt;</div><div class="line">&lt;item name="custom-main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;</div><div class="line">&lt;/resources&gt;</div></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">最后一种限定符:[方向限定符]</div><div class="line">//平板横向</div><div class="line">res/values-sw600dp-land/layouts.xml:</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"custom-main"</span> <span class="attr">type</span>=<span class="string">"layout"</span>&gt;</span>@layout/main_twopanes<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div><div class="line">//平板竖直</div><div class="line">res/values-sw600dp-port/layouts.xml:</div><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"custom-main"</span> <span class="attr">type</span>=<span class="string">"layout"</span>&gt;</span>@layout/main<span class="tag">&lt;/<span class="name">item</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="IV-使用自动拉伸位图——消息气泡框"><a href="#IV-使用自动拉伸位图——消息气泡框" class="headerlink" title="(IV)使用自动拉伸位图——消息气泡框"></a>(IV)使用自动拉伸位图——消息气泡框</h2><p>在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以<br>任意调整大小的一种图片格式“.9.png”。这种图片是用于Android开发的一种特殊的图片格式，它的好处<br>在于可以用简单的方式把一张图片中哪些区域可以拉伸，哪些区域不可以拉伸设定好，同时可以把显示内容<br>区域的位置标示清楚。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-309ecc6dcb2439ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="abc.9.png"><br>我们可以明显看到.9.png的外围是有一些黑色的线条的1、2、3、4，它们的作用及说明：<br>序号1和2标识了可以拉伸的区域。（如图只可拉伸标记的一个像素点。）<br>序号3和4标识了内容区域。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="http://upload-images.jianshu.io/upload_images/4821697-49e20d83fb53fb2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="被拉伸后的效果"></h2><blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/08/27/ScreenAdaptation/ScreenAdaptation.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="适配" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E9%80%82%E9%85%8D/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="适配" scheme="https://jaykuzzi.github.io/tags/%E9%80%82%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 数据存储与共享</title>
    <link href="https://jaykuzzi.github.io/2016/07/15/DataStorage/"/>
    <id>https://jaykuzzi.github.io/2016/07/15/DataStorage/</id>
    <published>2016-07-15T01:48:54.000Z</published>
    <updated>2017-06-27T12:13:10.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/07/15/DataStorage/disk.jpeg" alt=""><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><center>前言</center></h1><p><strong>Android提供了5种方式来让用户保存持久化应用程序数据。</strong><br>①  使用SharedPreferences存储数据　<br>②  文件存储数据<br>③  SQLite数据库存储数据<br>④  使用ContentProvider存储数据<br>⑤  网络存储数据　<br><strong>我们可以根据需求选择对应的方式。文章根据相关Demo讲述各种方式的用法及优缺点说明，在文章末尾附录会有相关Demo的下载 。</strong><br><strong>通过以上方式还可以实现数据的在不同app间的数据共享。</strong></p>
<h1 id="SharedPreferences"><a href="#SharedPreferences" class="headerlink" title="SharedPreferences"></a><center>SharedPreferences</center></h1><h2 id="1、适用范围"><a href="#1、适用范围" class="headerlink" title="1、适用范围"></a>1、适用范围</h2><p>保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口令密码等。</p>
<h2 id="2、核心原理"><a href="#2、核心原理" class="headerlink" title="2、核心原理"></a>2、核心原理</h2><p>保存基于XML文件存储的key-value键值对数据。<br>通过DDMS的File Explorer面板，展开文件浏览树,很明显SharedPreferences数据总是存储在/data/data/<package name="">/shared_prefs目录下。<br>SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。<br>SharedPreferences本身是一个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法中name表示要操作的xml文件名，第二个参数具体如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Context.MODE_PRIVATE: 指定该SharedPreferences数据只能被本应用程序读、写。</div><div class="line">Context.MODE_WORLD_READABLE:  指定该SharedPreferences数据能被其他应用程序读，但不能写。</div><div class="line">Context.MODE_WORLD_WRITEABLE:  指定该SharedPreferences数据能被其他应用程序读，写。</div><div class="line"><span class="comment">//以上三种写法均已过时，可以直接用数字代替，</span></div><div class="line"><span class="comment">//Context.MODE_PRIVATE = 0</span></div><div class="line"><span class="comment">//Context.MODE_WORLD_READABLE = 1</span></div><div class="line"><span class="comment">//Context.MODE_WORLD_WRITEABLE = 2</span></div></pre></td></tr></table></figure></package></p>
<p>Editor有如下主要重要方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SharedPreferences.<span class="function">Editor <span class="title">clear</span><span class="params">()</span></span></div><div class="line"><span class="comment">//清空SharedPreferences里所有数据</span></div><div class="line">SharedPreferences.Editor <span class="title">putXxx</span><span class="params">(String key , xxx value)</span>:</div><div class="line"><span class="comment">//向SharedPreferences存入指定key对应的数据，其中xxx 可以是boolean,float,int等各种基本类型据</span></div><div class="line">SharedPreferences.Editor <span class="title">remove</span><span class="params">()</span></div><div class="line"><span class="comment">//删除SharedPreferences中指定key对应的数据项</span></div><div class="line"><span class="keyword">boolean</span> <span class="title">commit</span><span class="params">()</span></div><div class="line"><span class="comment">//当Editor编辑完成后，使用该方法提交修改</span></div></pre></td></tr></table></figure></p>
<h2 id="3、app内部实现数据存储（Demo）"><a href="#3、app内部实现数据存储（Demo）" class="headerlink" title="3、app内部实现数据存储（Demo）"></a>3、app内部实现数据存储（Demo）</h2><p>通过点击“保存用户名”，对登陆成功的用户进行用户名键值对的保存，让用户下次启动app时自动填充用户名。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> EditText userName,userPass;</div><div class="line">		<span class="keyword">private</span> CheckBox checkBox;</div><div class="line">		<span class="keyword">private</span> Button ok,cancel;</div><div class="line">		<span class="keyword">private</span> SharedPreferences pref;</div><div class="line">		<span class="keyword">private</span> SharedPreferences.Editor editor;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				<span class="comment">//初始化SharedPreferences 及相关组建。</span></div><div class="line">				init();</div><div class="line">				<span class="comment">//3、取出userInfo中的数据。</span></div><div class="line">				String name00=pref.getString(<span class="string">"userName"</span>,<span class="keyword">null</span>);</div><div class="line">				<span class="keyword">if</span> (name00==<span class="keyword">null</span>) &#123;</div><div class="line">						checkBox.setChecked(<span class="keyword">false</span>);</div><div class="line">				&#125;<span class="keyword">else</span> &#123;</div><div class="line">						checkBox.setChecked(<span class="keyword">true</span>);</div><div class="line">						<span class="comment">//4、将取到的用户名赋给用户名编辑框。</span></div><div class="line">						userName.setText(name00);</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">				userName = (EditText) findViewById(R.id.userName);</div><div class="line">				userPass = (EditText) findViewById(R.id.userPass);</div><div class="line">				checkBox = (CheckBox) findViewById(R.id.check);</div><div class="line">				ok = (Button) findViewById(R.id.join_btn);</div><div class="line">				cancel = (Button) findViewById(R.id.cancel_btn);</div><div class="line">				ok.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">				cancel.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">				<span class="comment">//1、获取SharedPreferences对象，并把文件名设为"userInfo"。</span></div><div class="line">				pref =getSharedPreferences(<span class="string">"userInfo"</span>, MODE_PRIVATE);</div><div class="line">				<span class="comment">//2、获取SharedPreferences内部接口Editor用来编辑userInfo。</span></div><div class="line">				editor = pref.edit();</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="comment">//2.1：获取用户输入的用户名密码信息。</span></div><div class="line">				String name = userName.getText().toString();</div><div class="line">				String pass = userPass.getText().toString();</div><div class="line">				<span class="keyword">switch</span> (v.getId()) &#123;</div><div class="line">						<span class="keyword">case</span> R.id.join_btn:</div><div class="line">								<span class="keyword">if</span> (<span class="string">"admin"</span>.equals(name)&amp;&amp;<span class="string">"123456"</span>.equals(pass))&#123;</div><div class="line">										<span class="keyword">if</span>(checkBox.isChecked())&#123;</div><div class="line">												<span class="comment">//2.2.1：判断成功登入并对"保存用户名"打勾之后，</span></div><div class="line">												<span class="comment">//将用户名的键值对添加到文件名为"userInfo"文件中并提交。</span></div><div class="line">												editor.putString(<span class="string">"userName"</span>,name);</div><div class="line">												editor.commit();</div><div class="line">										&#125;<span class="keyword">else</span>&#123;</div><div class="line">												<span class="comment">//2.2.2若没打勾，则清空并提交。</span></div><div class="line">												editor.remove(<span class="string">"userName"</span>);</div><div class="line">												editor.commit();</div><div class="line">										&#125;</div><div class="line">										Toast.makeText(<span class="keyword">this</span>,<span class="string">"登陆成功"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">								&#125;<span class="keyword">else</span>&#123;</div><div class="line">										Toast.makeText(<span class="keyword">this</span>,<span class="string">"登陆失败"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">								&#125;</div><div class="line">										<span class="keyword">break</span>;</div><div class="line">						<span class="keyword">case</span> R.id.cancel_btn:</div><div class="line">								userName.setText(<span class="keyword">null</span>);</div><div class="line">								userPass.setText(<span class="keyword">null</span>);</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br>登入成功<br><img src="http://upload-images.jianshu.io/upload_images/4821697-20dd2fb30f435f11.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="登入成功"><br>第二次打开自动填充用户名。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-c0fa67713d87c40e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="第二次打开app"><br>【在DDMS中依次打开data/data/&lt;包&gt;/shared_prefs，可以看到此文件内容】<br><img src="http://upload-images.jianshu.io/upload_images/4821697-3cf654f44304cb5e.png" alt="data/data/&lt;包&gt;/shared_prefs"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-a5add75b1ea5e990.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件内容"></p>
<h2 id="4、共享其他应用的SharedPreferences"><a href="#4、共享其他应用的SharedPreferences" class="headerlink" title="4、共享其他应用的SharedPreferences"></a>4、共享其他应用的SharedPreferences</h2><p>在创建SharedPreferences时，指定MODE_WORLD_READABLE模式，表明该SharedPreferences数据可以被其他程序读取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SharedPreferences  pref =getSharedPreferences(<span class="string">"userInfo"</span>, MODE_WORLD_READABLE);</div></pre></td></tr></table></figure></p>
<p>创建其他应用程序对应的Context上下文引用:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Context otherAppContent = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">						otherAppContent = createPackageContext(<span class="string">"com.bb.sharedpr"</span>,CONTEXT_IGNORE_SECURITY);</div><div class="line"><span class="comment">//com.bb.sharedpr为我们要调用数据的包名</span></div><div class="line">				&#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</div><div class="line">						e.printStackTrace();</div><div class="line">				&#125;</div></pre></td></tr></table></figure></p>
<p>使用其他程序的Context获取对应的SharedPreferences<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SharedPreferences read = otherAppContent.getSharedPreferences(<span class="string">"userInfo"</span>,MODE_WORLD_READABLE);</div></pre></td></tr></table></figure></p>
<p>如果是写入数据，使用Editor接口即可，所有其他操作均和前面一致。</p>
<h2 id="5、关于android-sharedUserId"><a href="#5、关于android-sharedUserId" class="headerlink" title="5、关于android:sharedUserId"></a>5、关于android:sharedUserId</h2><p>通常，不同的APK会具有不同的userId，因此运行时属于不同的进程中，而不同进程中的资源是不共享的，才保障了程序运行的稳定。然后在有些时候，我们自己开发了多个APK并且需要他们之间互相共享资源，那么就需要通过设置shareUserId来实现这一目的。<br>通过SharedUserId,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以通过获取上下文来互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。<br><strong>而上面的两个工程中并没有对Android:sharedUserId属性进行设置。这个属性是在查资料时看到的：意思是说，在manifest.xml里面将两个应用程序的android:sharedUserId属性设为相同的就可以对SharedPreferences文件进行写。（此处并没有验证）</strong></p>
<h2 id="6、SharedPreferences总结"><a href="#6、SharedPreferences总结" class="headerlink" title="6、SharedPreferences总结"></a>6、SharedPreferences总结</h2><p><strong>优点</strong><br>SharedPreferences对象与SQLite数据库相比显得格外轻量级，免去了创建数据库，创建表，写SQL语句等诸多操作，相对而言更加方便，简洁。<br><strong>缺点</strong><br>1、其职能存储boolean，int，float，long和String五种简单的数据类型。<br>2、无法进行条件查询等。<br><strong>【所以不论SharedPreferences的数据存储操作是如何简单，它也只能是存储方式的一种补充，而无法完全替代如SQLite数据库这样的其他数据存储方式。】</strong></p>
<h1 id="文件存储数据"><a href="#文件存储数据" class="headerlink" title="文件存储数据"></a><center>文件存储数据</center></h1><h2 id="1、功能介绍"><a href="#1、功能介绍" class="headerlink" title="1、功能介绍"></a>1、功能介绍</h2><p>Android文件系统和其他平台上的类似，使用File APIs可以读写文件。这部分内容需要你已经了解了Linux文件系统的基础，并且也了解了java.io包中的标准文件输入输出APIs。</p>
<h2 id="2、存储方式"><a href="#2、存储方式" class="headerlink" title="2、存储方式"></a>2、存储方式</h2><p>所有的Android设备都有两块文件存储区域：内部和外部存储。<br><strong>内部存储：指设备自带的非易失性存储器。</strong><br>永远可用，因为不可以拆卸。<br>文件默认情况下只对你的app可用，是<strong>私有的</strong>，无论是用户或者是其他app都不能共享访问你的数据。<br>当用户卸载你的app时，系统会自动移除app在内部存储上的所有文件。<br><strong>外部存储：指可拆卸的存储介质，如卫星电视SD卡。</strong><br>不一定一直可以访问，因为用户可以拆卸外部存储设备。<br>文件是全局可读的，没有访问限制，不受你的控制。可以和其他app共享数据，用户使用电脑也可以访问在外部存储中的文件。<br>当用户卸载你的app时，只有当你把文件存储在以 getExternalFilesDir().获得的路径下时，系统才会帮你自动移除。</p>
<h2 id="3、使用内部存储（Demo）"><a href="#3、使用内部存储（Demo）" class="headerlink" title="3、使用内部存储（Demo）"></a>3、使用内部存储（Demo）</h2><p>Context提供了两个方法来打开数据文件里的文件IO流<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">FileInputStream <span class="title">openFileInput</span><span class="params">(String name)</span></span>; </div><div class="line"><span class="function">FileOutputStream <span class="title">openFileInput</span><span class="params">(String name , <span class="keyword">int</span> mode)</span></span>;</div><div class="line"><span class="comment">//name参数:　用于指定文件名称，不能包含路径分隔符“/” ,</span></div><div class="line"><span class="comment">//如果文件不存在，Android 会自动创建它。</span></div></pre></td></tr></table></figure></p>
<p>这两个方法第一个参数 用于指定文件名，第二个参数指定打开文件的模式。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下，</div><div class="line">							写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPEND</div><div class="line">MODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。</div><div class="line">MODE_WORLD_READABLE：表示当前文件可以被其他应用读取。</div><div class="line">MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。</div><div class="line">模式可以连用 比如可读可写 就写成：</div><div class="line">MODE_WORLD_READABLE+MODE_WORLD_WRITEABLE</div></pre></td></tr></table></figure></p>
<p> 除此之外，Context还提供了如下几个重要的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getDir(String name , <span class="keyword">int</span> mode):在应用程序的数据文件夹下获取或者创建name对应的子目录</div><div class="line">getFilesDir():获取该应用程序的数据文件夹得绝对路径</div><div class="line">fileList():返回该应用数据文件夹的全部文件</div></pre></td></tr></table></figure></p>
<p><strong>我们将实现的Demo为将输入的文字写入文件，并读取出来。</strong><br>第一步：创建和写入一个内部存储的私有文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">WriteFiles</span><span class="params">(String content)</span></span>&#123;</div><div class="line">		 <span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//①调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。</span></div><div class="line">			FileOutputStream fos = openFileOutput(<span class="string">"a.txt"</span>,</div><div class="line">						MODE_PRIVATE);</div><div class="line">			<span class="comment">//②通过FileOutputStream对象的write()函数写入数据。</span></div><div class="line">			fos.write(content.getBytes());</div><div class="line">			<span class="comment">//③FileOutputStream对象的close ()函数关闭流。</span></div><div class="line">			 fos.close();</div><div class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		 </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第二步：读取一个内部存储的私有文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">readFiles</span><span class="params">()</span></span>&#123;</div><div class="line">		String content = <span class="keyword">null</span>;</div><div class="line">		 <span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">//① 调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。</span></div><div class="line">			FileInputStream fis= openFileInput(<span class="string">"a.txt"</span>);</div><div class="line">			StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">			<span class="keyword">byte</span> [] buffer =  <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">			<span class="keyword">int</span> len = <span class="number">0</span>;</div><div class="line">			<span class="comment">//② 使用流对象的 read()方法读取字节</span></div><div class="line">			<span class="keyword">while</span> ((len=fis.read(buffer))!=-<span class="number">1</span>) &#123;</div><div class="line">				sb.append(<span class="keyword">new</span> String(buffer, <span class="number">0</span>, len));</div><div class="line">			&#125;</div><div class="line">			content =sb.toString();</div><div class="line">			<span class="comment">//③ 调用流的close()方法关闭流</span></div><div class="line">			fis.close();</div><div class="line">		&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">			e.printStackTrace();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> content;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>第三步：MainActivity中实现流程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		edt = (EditText) findViewById(R.id.editText1);</div><div class="line">		but = (Button) findViewById(R.id.write);</div><div class="line">		contentvalue = (TextView) findViewById(R.id.contentvalue);</div><div class="line">		but.setOnClickListener(<span class="keyword">new</span> OnClickListener() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				WriteFiles(edt.getText().toString());</div><div class="line">				contentvalue.setText(readFiles());</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-5a1d7a6d70031ad4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="app效果"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-8bd857b09308a3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件路径"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-86c95bbaf13450f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件"></p>
<p><strong>【注意】保存内存缓存文件</strong><br>有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir()去创建或打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">File file = <span class="keyword">this</span>.getCacheDir();</div><div class="line">Log.i(<span class="string">"info"</span>, file.toString();</div></pre></td></tr></table></figure></p>
<p>当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。</p>
<h2 id="4、使用外部存储（Demo）"><a href="#4、使用外部存储（Demo）" class="headerlink" title="4、使用外部存储（Demo）"></a>4、使用外部存储（Demo）</h2><p>因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：<br>第一步：添加外部存储访问限权<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- 在AndroidManifest.xml中加入访问SDCard的权限--&gt;</span> </div><div class="line"><span class="comment">&lt;!-- 在SDCard中创建与删除文件权限 --&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.MOUNT_UNMOUNT_FILESYSTEMS"</span>/&gt;</span> </div><div class="line"><span class="comment">&lt;!-- 往SDCard写入数据权限 --&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>第二步：检测外部存储的可用性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取外存储的状态</span></div><div class="line">String state = Environment.getExternalStorageState();</div><div class="line"><span class="keyword">if</span> (Environment.MEDIA_MOUNTED.equals(state)) &#123;</div><div class="line">		<span class="comment">// 可读可写</span></div><div class="line">		mExternalStorageAvailable = mExternalStorageWriteable = <span class="keyword">true</span>;</div><div class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123;</div><div class="line">		<span class="comment">// 可读</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 可能有很多其他的状态，但是我们只需要知道，不能读也不能写  </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第三步：读写数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> TextView textView;</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		textView= (TextView) findViewById(R.id.tv);	</div><div class="line">		<span class="keyword">if</span>(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123;</div><div class="line">			File sdCardDir = Environment.getExternalStorageDirectory();</div><div class="line">			<span class="comment">//获取SDCard目录  "/sdcard"</span></div><div class="line">			File saveFile = <span class="keyword">new</span> File(sdCardDir,<span class="string">"a.txt"</span>);</div><div class="line">			<span class="comment">//写数据</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				FileOutputStream fos= <span class="keyword">new</span> FileOutputStream(saveFile);</div><div class="line">				fos.write(<span class="string">"bobobo"</span>.getBytes());</div><div class="line">				fos.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		    <span class="comment">//读数据</span></div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				FileInputStream fis= <span class="keyword">new</span> FileInputStream(saveFile);</div><div class="line">				<span class="keyword">int</span> len =<span class="number">0</span>;</div><div class="line">				<span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</div><div class="line">				StringBuffer sb = <span class="keyword">new</span> StringBuffer();</div><div class="line">				<span class="keyword">while</span>((len=fis.read(buf))!=-<span class="number">1</span>)&#123;</div><div class="line">					sb.append(<span class="keyword">new</span> String(buf, <span class="number">0</span>, len));</div><div class="line">				&#125;</div><div class="line">				textView.setText(sb.toString());</div><div class="line">				fis.close();</div><div class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">				e.printStackTrace();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-83d1a9d1994cf9fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-1c1cc8f30cf7d245.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="外部路径"></p>
<h1 id="SQLite数据库存储数据"><a href="#SQLite数据库存储数据" class="headerlink" title="SQLite数据库存储数据"></a><center>SQLite数据库存储数据</center></h1><h2 id="1、简介及特点"><a href="#1、简介及特点" class="headerlink" title="1、简介及特点"></a>1、简介及特点</h2><p>SQLite是轻量级嵌入式数据库引擎，且只利用很少的内存就有很好的性能。<br>在我们为移动设备开发应用程序时，使用SQLite作为复杂数据、大量数据的存储引擎。<br>SQLite它是一个独立的，无需服务进程，无需安装和管理配置，支持事务处理，可以使用SQL语言的数据库。<br>支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python。<br>在Content Provider 技术中就是使用SQLite数据库来操作数据的。</p>
<h2 id="2、实现原理"><a href="#2、实现原理" class="headerlink" title="2、实现原理"></a>2、实现原理</h2><p>直接通过SQLiteDatabase对象来创建一个数据库。<br>或者继承SQLiteOpenHelper类封装创建和更新数据库使用的逻辑。<br><strong>它们都会在ddns 的file explorer 中的data/data/&lt;包&gt;/databases中创建这个数据库文件。</strong></p>
<h2 id="3、通过SQLiteDatabase创建（Demo）"><a href="#3、通过SQLiteDatabase创建（Demo）" class="headerlink" title="3、通过SQLiteDatabase创建（Demo）"></a>3、通过SQLiteDatabase创建（Demo）</h2><p>第一步：创建数据库并插入数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> SQLiteDatabase db;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">				db = openOrCreateDatabase(<span class="string">"user.db"</span>, MODE_PRIVATE, <span class="keyword">null</span>);</div><div class="line">				db.execSQL(<span class="string">"create table if not exists usertb (_id integer primary key autoincrement, name text not null , age integer not null , sex text not null )"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into usertb(name,sex,age) values('张三','女',18)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into usertb(name,sex,age) values('李四','男',19)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into usertb(name,sex,age) values('王五','女',22)"</span>);</div><div class="line">				<span class="comment">//查询数据库并展示</span></div><div class="line">				query(findViewById(R.id.query));</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>query代码【关于查询代码的详情在本小节末尾会有详细说明】<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">				tv_id.setText(<span class="string">""</span>);</div><div class="line">				tv_name.setText(<span class="string">""</span>);</div><div class="line">				tv_sex.setText(<span class="string">""</span>);</div><div class="line">				tv_age.setText(<span class="string">""</span>);</div><div class="line">				Cursor cursor = db.rawQuery(<span class="string">"select * from usertb"</span>, <span class="keyword">null</span>);</div><div class="line">				<span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="keyword">while</span> (cursor.moveToNext()) &#123;</div><div class="line">								tv_id.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"_id"</span>)));</div><div class="line">								tv_name.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>)));</div><div class="line">								tv_sex.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"sex"</span>)));</div><div class="line">								tv_age.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"age"</span>)));</div><div class="line">						&#125;</div><div class="line">						cursor.close();</div><div class="line">				&#125;</div><div class="line"><span class="comment">//        db.close();不要关闭，不然单独调用查询操作会空指针</span></div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-661a8fd8fb07f311.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-e1106cafc1c095d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件路径"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-006d8c8ea1f5724d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pc中使用Navicat可以操作数据表"><br>第二步：实现插入数据的操作（两种方式任选其一）<br>使用insert方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">			 ContentValues cv = <span class="keyword">new</span> ContentValues();<span class="comment">//实例化一个ContentValues用来装载待插入的数据</span></div><div class="line">				cv.put(<span class="string">"name"</span>,<span class="string">"新来的"</span>);</div><div class="line">				cv.put(<span class="string">"sex"</span>,<span class="string">"女"</span>);</div><div class="line">				cv.put(<span class="string">"age"</span>,<span class="string">"18"</span>);</div><div class="line">				db.insert(<span class="string">"usertb"</span>,<span class="keyword">null</span>,cv);<span class="comment">//执行插入操作</span></div><div class="line"><span class="comment">//      使用直接执行语句添加 </span></div><div class="line"><span class="comment">//      db.execSQL("insert into usertb(name,sex,age) values('新来的','女',18)");</span></div><div class="line">				query(findViewById(R.id.query));</div><div class="line">		&#125;</div></pre></td></tr></table></figure></p>
<p>使用execSQL方式来实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">db.execSQL(<span class="string">"insert into usertb(name,sex,age) values('新来的','女',18)"</span>);</div></pre></td></tr></table></figure></p>
<p><strong>效果</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-8f86bd0458efc4c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="添加效果"></p>
<p>第三步：实现删除数据的操作<br>同样有2种方式可以实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">String whereClause = <span class="string">"name=?"</span>;<span class="comment">//删除的条件</span></div><div class="line">String[] whereArgs = &#123;<span class="string">"新来的"</span>&#125;;<span class="comment">//删除的条件参数</span></div><div class="line">db.delete(<span class="string">"user"</span>,whereClause,whereArgs);<span class="comment">//执行删除</span></div></pre></td></tr></table></figure></p>
<p>使用execSQL方式的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = <span class="string">"delete from usertb where name='新来的'"</span>;<span class="comment">//删除操作的SQL语句</span></div><div class="line">db.execSQL(sql);<span class="comment">//执行删除操作</span></div></pre></td></tr></table></figure></p>
<p>第四步：实现修改数据的操作（将张三改成张三三）<br>同上，仍是2种方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ContentValues cv = <span class="keyword">new</span> ContentValues();<span class="comment">//实例化ContentValues</span></div><div class="line">cv.put(<span class="string">"name"</span>,<span class="string">"张三三"</span>);<span class="comment">//添加要更改的字段及内容</span></div><div class="line">String whereClause = <span class="string">"name=?"</span>;<span class="comment">//修改条件</span></div><div class="line">String[] whereArgs = &#123;<span class="string">"张三"</span>&#125;;<span class="comment">//修改条件的参数</span></div><div class="line">db.update(<span class="string">"usertb"</span>,cv,whereClause,whereArgs);<span class="comment">//执行修改</span></div></pre></td></tr></table></figure></p>
<p>使用execSQL方式的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String sql = <span class="string">"update usertb set name = '张三三' where username='张三'"</span>;<span class="comment">//修改的SQL语句</span></div><div class="line">db.execSQL(sql);<span class="comment">//执行修改</span></div></pre></td></tr></table></figure></p>
<p><strong>【关于查询操作】</strong><br>查询操作相对于上面的几种操作要复杂些，因为我们经常要面对着各种各样的查询条件，所以系统也考虑到这种复杂性，为我们提供了较为丰富的查询形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.rawQuery(String sql, String[] selectionArgs);  </div><div class="line">db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy);  </div><div class="line">db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit);  </div><div class="line">db.query(String distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit);</div></pre></td></tr></table></figure></p>
<p>各参数说明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">table：表名称</div><div class="line">colums：表示要查询的列所有名称集</div><div class="line">selection：表示WHERE之后的条件语句，可以使用占位符</div><div class="line">selectionArgs：条件语句的参数数组</div><div class="line">groupBy：指定分组的列名</div><div class="line">having：指定分组条件,配合groupBy使用</div><div class="line">orderBy：y指定排序的列名</div><div class="line">limit：指定分页参数</div><div class="line">distinct：指定“<span class="keyword">true</span>”或“<span class="keyword">false</span>”表示要不要过滤重复值</div><div class="line">Cursor：返回值，相当于结果集ResultSet</div></pre></td></tr></table></figure></p>
<p>最后，他们同时返回一个Cursor对象，代表数据集的游标，有点类似于JavaSE中的ResultSet。下面是Cursor对象的常用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">c.move(<span class="keyword">int</span> offset); <span class="comment">//以当前位置为参考,移动到指定行  </span></div><div class="line">c.moveToFirst();    <span class="comment">//移动到第一行  </span></div><div class="line">c.moveToLast();     <span class="comment">//移动到最后一行  </span></div><div class="line">c.moveToPosition(<span class="keyword">int</span> position); <span class="comment">//移动到指定行  </span></div><div class="line">c.moveToPrevious(); <span class="comment">//移动到前一行  </span></div><div class="line">c.moveToNext();     <span class="comment">//移动到下一行  </span></div><div class="line">c.isFirst();        <span class="comment">//是否指向第一条  </span></div><div class="line">c.isLast();     <span class="comment">//是否指向最后一条  </span></div><div class="line">c.isBeforeFirst();  <span class="comment">//是否指向第一条之前  </span></div><div class="line">c.isAfterLast();    <span class="comment">//是否指向最后一条之后  </span></div><div class="line">c.isNull(<span class="keyword">int</span> columnIndex);  <span class="comment">//指定列是否为空(列基数为0)  </span></div><div class="line">c.isClosed();       <span class="comment">//游标是否已关闭  </span></div><div class="line">c.getCount();       <span class="comment">//总数据项数  </span></div><div class="line">c.getPosition();    <span class="comment">//返回当前游标所指向的行数  </span></div><div class="line">c.getColumnIndex(String columnName);<span class="comment">//返回某列名对应的列索引值  </span></div><div class="line">c.getString(<span class="keyword">int</span> columnIndex);   <span class="comment">//返回当前行指定列的值</span></div></pre></td></tr></table></figure></p>
<p>举例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">db.update(<span class="string">"stutb"</span>, values, <span class="string">"_id&gt;?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"3"</span>&#125;);<span class="comment">//把id&gt;3的性别更新成"女"</span></div><div class="line">db.delete(<span class="string">"stutb"</span>, <span class="string">"name like ?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"%丰%"</span>&#125;);<span class="comment">//删掉名字中带有"丰"的记录</span></div><div class="line"><span class="comment">//使用游标类 进行查询</span></div><div class="line">Cursor c = db.query(<span class="string">"stutb"</span>, <span class="keyword">null</span>, <span class="string">"_id&gt;?"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"0"</span>&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"_id"</span>);</div></pre></td></tr></table></figure></p>
<h2 id="4、通过继承SQLiteOpenHelper类创建"><a href="#4、通过继承SQLiteOpenHelper类创建" class="headerlink" title="4、通过继承SQLiteOpenHelper类创建"></a>4、通过继承SQLiteOpenHelper类创建</h2><p>Android 提供了 SQLiteOpenHelper，其是SQLiteDatabase的一个帮助类，用来管理数据库的创建和版本的更新。你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。<br>第一步：写一个子类继承SQLiteOpenHelper并复写三个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		* <span class="doctag">@param</span> context  上下文环境（例如，一个 Activity）</div><div class="line">		* <span class="doctag">@param</span> name   数据库名字</div><div class="line">		* <span class="doctag">@param</span> factory  一个可选的游标工厂（通常是 Null）</div><div class="line">		* <span class="doctag">@param</span> version  数据库模型版本的整数</div><div class="line">		* </div><div class="line">		* 会调用父类 SQLiteOpenHelper的构造函数</div><div class="line">		*/ </div><div class="line">		<span class="comment">//    public DatabaseHelper(Context context, String name,    CursorFactory factory, int version) &#123;</span></div><div class="line">		<span class="comment">//        super(context, name, factory, version);</span></div><div class="line">		<span class="comment">//    &#125;</span></div><div class="line">	    <span class="comment">//这里我们直接定义数据库名字根版本号</span></div><div class="line">		 <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"stu.db"</span>;</div><div class="line">		 <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION = <span class="number">1</span>;</div><div class="line">		 <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME = <span class="string">"stutb"</span>;</div><div class="line">		 <span class="comment">// 步骤2：重载构造方法</span></div><div class="line">		 <span class="function"><span class="keyword">public</span> <span class="title">DatabaseHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">				 <span class="keyword">super</span>(context, DATABASE_NAME, <span class="keyword">null</span>, VERSION);</div><div class="line">		 &#125;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 *  在数据库第一次创建的时候会调用这个方法</div><div class="line">		 *  </div><div class="line">		 *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。</div><div class="line">		 */</div><div class="line">		<span class="comment">//在这里进行建表</span></div><div class="line">			 <span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">				db.execSQL(<span class="string">"create table if not exists stutb(_id integer primary key autoincrement,name text not null,sex text not null,age integer not null)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into stutb(name,sex,age)values('张三','男',18)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into stutb(name,sex,age)values('张四','女',20)"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。</div><div class="line">		 * 一般我们在这个方法里边删除数据库表，并建立新的数据库表.</div><div class="line">		 */</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">				<span class="comment">//三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号</span></div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpen</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">				<span class="comment">// 每次成功打开数据库后首先被执行</span></div><div class="line">				<span class="keyword">super</span>.onOpen(db);</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>第二步：继承SQLiteOpenHelper之后就拥有了以下两个方法<br>getReadableDatabase() 　创建或者打开一个查询数据库<br>getWritableDatabase()　创建或者打开一个可写数据库<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DatabaseHelper database = <span class="keyword">new</span> DatabaseHelper(MainActivity.<span class="keyword">this</span>);<span class="comment">//传入一个上下文参数</span></div><div class="line">SQLiteDatabase db = <span class="keyword">null</span>;</div><div class="line">db = database.getWritableDatabase();</div><div class="line"><span class="comment">//上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。</span></div><div class="line">getWritableDatabase()和getReadableDatabase()方法都可以获取一个用于操作数据库的SQLiteDatabase实例。</div><div class="line"><span class="comment">//	其中getReadableDatabase()方法则是先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，当打开失败后</span></div><div class="line"><span class="comment">//	会继续尝试以只读方式打开数据库。如果该问题成功解决，则只读数据库对象就会关闭，然后返回一个可读写的数据库对象。</span></div><div class="line"><span class="comment">//	getWritableDatabase() 方法以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，</span></div><div class="line"><span class="comment">//	使用的是getWritableDatabase() 方法就会出错。</span></div></pre></td></tr></table></figure></p>
<p>第三步：实现查询代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Cursor c = db.rawQuery(<span class="string">"select * from stutb"</span>, <span class="keyword">null</span>);</div><div class="line">		<span class="keyword">if</span> (c!=<span class="keyword">null</span>) &#123;</div><div class="line">			String [] cols = c.getColumnNames();</div><div class="line">			<span class="keyword">while</span> (c.moveToNext()) &#123;</div><div class="line">				<span class="keyword">for</span> (String ColumnName : cols) &#123;</div><div class="line">					Log.i(<span class="string">"info "</span>, ColumnName+<span class="string">":"</span>+c.getString(c.getColumnIndex(ColumnName)));</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			c.close();</div><div class="line">		&#125;</div><div class="line">		db.close();</div></pre></td></tr></table></figure></p>
<p><strong>效果(命令行打印)</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-d9294521ab7eee89.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="命令行打印结果"></p>
<h2 id="5、两种方式的联系"><a href="#5、两种方式的联系" class="headerlink" title="5、两种方式的联系"></a>5、两种方式的联系</h2><p>Context.openOrCreateDatabase 与 SQLiteDatabase.openOrCreateDatabase本质上完成的功能都一样，Context.openOrCreateDatabase最终是需要调用 SQLiteDatabase.openOrCreateDatabase来完成数据库的创建的。  也就是说， SQLiteDatabase类是android上对sqlite的最底层的封装，几乎所有的对数据库的操作最终都通过这个类来实现。<br>对数据表的操作方式不同，SQLiteOpenHelper是SQLiteDatabase的帮助类。要如你的代码执行，你需要通过类似SQLiteOpenHelper的getWritableDatabase方法获取到SQLiteDatabase实例才可以。创建表直接可以在SQLiteOpenHelper的onCreate方法中做，那里通过参数你可以得到一个SQLiteDatabase的实例。</p>
<h1 id="使用ContentProvider存储数据"><a href="#使用ContentProvider存储数据" class="headerlink" title="使用ContentProvider存储数据"></a><center>使用ContentProvider存储数据</center></h1><h2 id="与SQLite数据库联系"><a href="#与SQLite数据库联系" class="headerlink" title="与SQLite数据库联系"></a>与SQLite数据库联系</h2><p><strong>1.SQLiteOpenHelper是将对数据库和表的创建、插入、更新、删除操作进行了简单的封装；</strong><br><strong>2.而ContentProvider可以说是一个对外的接口，除了可以实现对SQLiteOpenHelper的封装，还可以实现对文件操作、图片操作、对象操作等实现封装；</strong><br><strong>3.在多线程中使用SQLiteOpenHelper要考虑线程同步问题，而如果使用ContentProvider的话基本不用考虑；</strong><br><strong>4.使用ContentProvider存储数据可以实现不同app之间的数据共享。</strong><br>详见：<br><a href="http://www.woobo.me/2016/07/05/ContentProvider/" target="_blank" rel="external">Android实习生 —— 四大组件之ContentProvider</a></p>
<h1 id="网络存储数据"><a href="#网络存储数据" class="headerlink" title="网络存储数据"></a><center>网络存储数据</center></h1><h2 id="一、网络保存数据介绍"><a href="#一、网络保存数据介绍" class="headerlink" title="一、网络保存数据介绍"></a>一、网络保存数据介绍</h2><p>可以使用网络来保存数据，在需要的时候从网络上获取数据，进而显示在App中。用网络保存数据的方法有很多种，对于不同的网络数据采用不同的上传与获取方法。<br>本文利用LeanCloud来进行网络数据的存储。<br>LeanCloud是一种简单高效的数据和文件存储服务。感兴趣的可以查看网址：<a href="https://leancloud.cn/。" target="_blank" rel="external">https://leancloud.cn/。</a> 的例子。</p>
<h2 id="二、使用方法"><a href="#二、使用方法" class="headerlink" title="二、使用方法"></a>二、使用方法</h2><p>1、上传数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">AVObject personObject = <span class="keyword">new</span> AVObject(TABLENAME);</div><div class="line">				personObject.put(NAME, person.name);</div><div class="line">				personObject.put(AGE, person.age);</div><div class="line">				personObject.put(INFO, person.info);</div><div class="line">				personObject.saveInBackground(<span class="keyword">new</span> SaveCallback() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(AVException e)</span> </span>&#123;</div><div class="line">								<span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">										Log.v(TAG, <span class="string">"put data success!"</span>);</div><div class="line">								&#125; <span class="keyword">else</span> &#123;</div><div class="line">										Log.v(TAG, <span class="string">"put data failed!error:"</span> + e.getMessage());</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;);</div></pre></td></tr></table></figure></p>
<p>2、读取数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">AVQuery&lt;AVObject&gt; avQuery = <span class="keyword">new</span> AVQuery&lt;&gt;(TABLENAME);</div><div class="line">				avQuery.findInBackground(<span class="keyword">new</span> FindCallback&lt;AVObject&gt;() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(List&lt;AVObject&gt; list, AVException e)</span> </span>&#123;</div><div class="line">								<span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">										Log.v(TAG, <span class="string">"get data success!"</span>);</div><div class="line">										String message = <span class="string">""</span>;</div><div class="line">										<span class="comment">//倒着遍历后四条上传的数据</span></div><div class="line">										<span class="keyword">for</span> (<span class="keyword">int</span> i = list.size()-<span class="number">1</span>; i &gt;=list.size()-<span class="number">4</span>; i--) &#123;</div><div class="line">												String name = list.get(i).getString(NAME);</div><div class="line">												<span class="keyword">int</span> age = list.get(i).getInt(AGE);</div><div class="line">												String info = list.get(i).getString(INFO);</div><div class="line"></div><div class="line">												message += <span class="string">"name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">",info:"</span> + info + <span class="string">".\n"</span>;</div><div class="line">										&#125;</div><div class="line">										textView.setText(message);</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="三、小案例"><a href="#三、小案例" class="headerlink" title="三、小案例"></a>三、小案例</h2><p>1、导入jar包<br><img src="http://upload-images.jianshu.io/upload_images/4821697-8842d8f82c4df9f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="导入jar包"><br>2、添加NetworkDBManager类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.zhangmiao.datastoragedemo;</div><div class="line"><span class="keyword">import</span> android.util.Log;</div><div class="line"><span class="keyword">import</span> android.widget.TextView;</div><div class="line"><span class="keyword">import</span> com.avos.avoscloud.AVException;</div><div class="line"><span class="keyword">import</span> com.avos.avoscloud.AVObject;</div><div class="line"><span class="keyword">import</span> com.avos.avoscloud.AVQuery;</div><div class="line"><span class="keyword">import</span> com.avos.avoscloud.FindCallback;</div><div class="line"><span class="keyword">import</span> com.avos.avoscloud.SaveCallback;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by zhangmiao on 2016/12/22.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDBManager</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"NetworkDBManager"</span>;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TABLENAME = <span class="string">"person"</span>;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String NAME = <span class="string">"name"</span>;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String AGE = <span class="string">"age"</span>;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String INFO = <span class="string">"info"</span>;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putData</span><span class="params">(Person person)</span> </span>&#123;</div><div class="line">				AVObject personObject = <span class="keyword">new</span> AVObject(TABLENAME);</div><div class="line">				personObject.put(NAME, person.name);</div><div class="line">				personObject.put(AGE, person.age);</div><div class="line">				personObject.put(INFO, person.info);</div><div class="line">				personObject.saveInBackground(<span class="keyword">new</span> SaveCallback() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(AVException e)</span> </span>&#123;</div><div class="line">								<span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">										Log.v(TAG, <span class="string">"put data success!"</span>);</div><div class="line">								&#125; <span class="keyword">else</span> &#123;</div><div class="line">										Log.v(TAG, <span class="string">"put data failed!error:"</span> + e.getMessage());</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(<span class="keyword">final</span> TextView textView)</span> </span>&#123;</div><div class="line">				AVQuery&lt;AVObject&gt; avQuery = <span class="keyword">new</span> AVQuery&lt;&gt;(TABLENAME);</div><div class="line">				avQuery.findInBackground(<span class="keyword">new</span> FindCallback&lt;AVObject&gt;() &#123;</div><div class="line">						<span class="meta">@Override</span></div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">(List&lt;AVObject&gt; list, AVException e)</span> </span>&#123;</div><div class="line">								<span class="keyword">if</span> (e == <span class="keyword">null</span>) &#123;</div><div class="line">										Log.v(TAG, <span class="string">"get data success!"</span>);</div><div class="line">										String message = <span class="string">""</span>;</div><div class="line">										 <span class="comment">////倒着遍历后四条上传的数据</span></div><div class="line">										<span class="keyword">for</span> (<span class="keyword">int</span> i = list.size()-<span class="number">1</span>; i &gt;=list.size()-<span class="number">4</span>; i--) &#123;</div><div class="line">												String name = list.get(i).getString(NAME);</div><div class="line">												<span class="keyword">int</span> age = list.get(i).getInt(AGE);</div><div class="line">												String info = list.get(i).getString(INFO);</div><div class="line">												message += <span class="string">"name:"</span> + name + <span class="string">",age:"</span> + age + <span class="string">",info:"</span> + info + <span class="string">".\n"</span>;</div><div class="line">										&#125;</div><div class="line">										textView.setText(message);</div><div class="line">								&#125;</div><div class="line">						&#125;</div><div class="line">				&#125;);</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3、修改AndroidManifest.xml文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.INTERNET"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.ACCESS_NETWORK_STATE"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>4、MainActivity<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> NetworkDBManager mNetworkDBManager;</div><div class="line">		<span class="keyword">private</span> TextView mTableInfo;</div><div class="line">		<span class="keyword">private</span> EditText et1,et2,et3;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				Log.v(<span class="string">"MainActivity"</span>, <span class="string">"onCreate"</span>);</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				AVOSCloud.initialize(<span class="keyword">this</span>, <span class="string">"yMNUazdBt872mNtC9aSakjYy-gzGzoHsz"</span>, <span class="string">"d4vw3VYdMCjLpsXRhHTBRutC"</span>);</div><div class="line">				mNetworkDBManager = <span class="keyword">new</span> NetworkDBManager();</div><div class="line">				et1= (EditText) findViewById(R.id.name);</div><div class="line">				et2= (EditText) findViewById(R.id.age);</div><div class="line">				et3= (EditText) findViewById(R.id.sex);</div><div class="line">				Button networkGet = (Button) findViewById(R.id.network_get);</div><div class="line">				Button networkPut = (Button) findViewById(R.id.network_put);</div><div class="line">				mTableInfo = (TextView) findViewById(R.id.table_info);</div><div class="line">				networkGet.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">				networkPut.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">		&#125;		</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="keyword">switch</span> (v.getId()) &#123;</div><div class="line">						<span class="keyword">case</span> R.id.network_put:</div><div class="line">								Person person3 = <span class="keyword">new</span> Person(et1.getText().toString(), Integer.parseInt(et2.getText().toString()), et3.getText().toString());</div><div class="line">								mNetworkDBManager.putData(person3);</div><div class="line">								Toast.makeText(<span class="keyword">this</span>,<span class="string">"上传成功"</span>,Toast.LENGTH_SHORT).show();</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">						<span class="keyword">case</span> R.id.network_get:</div><div class="line">								mNetworkDBManager.getData(mTableInfo);</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">						<span class="keyword">default</span>:</div><div class="line">								Log.v(<span class="string">"MainActivity"</span>, <span class="string">"default"</span>);</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>#【附录】</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p><strong>一、SharedPreferences</strong><br><a href="https://github.com/JayKuzzi/Android/tree/master/SharedPr" target="_blank" rel="external">app内部实现数据存储</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/SharedP-read" target="_blank" rel="external">其他app实现共享数据</a><br><strong>【先安装使用第一个并登入才可以使用第二个】</strong><br><strong>二、文件存储数据</strong><br><a href="https://github.com/JayKuzzi/Android/tree/master/FileDemo2" target="_blank" rel="external">内部存储</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/FileDemo1" target="_blank" rel="external">外部存储</a><br><strong>三、SQLite数据库存储数据</strong><br><a href="https://github.com/JayKuzzi/Android/tree/master/Sqlitedemo" target="_blank" rel="external">SQLiteDatabase直接操作数据库</a><br><a href="https://github.com/JayKuzzi/Android/tree/master/SQLiteDemo3" target="_blank" rel="external">继承SQLiteOpenHelper类操作数据库</a><br><strong>四、ContentProvider</strong><br>无<br><strong>五、网络存储数据</strong><br><a href="https://github.com/JayKuzzi/Android/tree/master/DataNet" target="_blank" rel="external">网络存储</a></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/07/15/DataStorage/disk.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="数据处理" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="数据处理" scheme="https://jaykuzzi.github.io/tags/%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 四大组件之ContentProvider</title>
    <link href="https://jaykuzzi.github.io/2016/07/05/ContentProvider/"/>
    <id>https://jaykuzzi.github.io/2016/07/05/ContentProvider/</id>
    <published>2016-07-05T12:17:59.000Z</published>
    <updated>2017-06-27T12:11:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/07/05/ContentProvider/content.png" alt=""><br><a id="more"></a></p>
<h1 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a><center>基础回顾</center></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ContentProvider（数据提供者）是在应用程序间共享数据的一种接口机制，虽然我们可以采用文件存储方式、sharedpreferences方式在程序间进行共享数据，但ContentProvider提供了更为高级的数据共享方法，应用程序可以指定需要共享的数据，而其他应用程序则可以在不知数据来源、路径的情况下，对共享数据进行查询、添加、删除和更新等操作，当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-fc2bc00457198686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ContentProvider"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>1、</strong>为存储和获取数据提供了统一的接口。<br><strong>2、</strong>可以在不同的应用程序之间共享数据。<br><strong>3、</strong>使用数据库表的形式来组织数据进行封装。<a href="http://www.woobo.me/2016/07/15/DataStorage/" target="_blank" rel="external">数据库使用：Android实习生 —— 数据存储与共享</a><br><strong>4、</strong>为应用间的数据交互提供了一个安全的环境。它准许你把自己的应用数据根据需求开放给其他应用进行增、删、改、查，而不用担心直接开放数据库权限而带来的安全问题。<br><em>【总的来说使用ContentProvider对外共享数据的好处是统一了数据的安全访问方式。】</em></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Android已经为常见的一些数据提供了系统默认的ContentProvider，比如去获取通讯录信息、获取图片、视频信息。我们可以在其他应用程通过提供的ContentProvider获取这些数据。</p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><center>相关概念</center></h1><h2 id="1、Uri"><a href="#1、Uri" class="headerlink" title="1、Uri"></a>1、Uri</h2><p><strong>通用资源标志符（Universal Resource Identifier, 简称”URI”）。</strong><br>Uri代表了要操作的数据，它为系统的每一个资源给其一个名字，比方说通话记录。每一个ContentProvider都拥有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-c19497f193195cbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Uri"><br>URI一般主要由三部分组成：<br><strong>Authority：</strong>授权信息，用以区别不同的ContentProvider，外部调用者可以根据这个标识来找到它。为了保证URI标识的唯一性，它必须是一个完整的、小写的类名。这个标识在 元素的 authorities属性中说明：一般是定义该ContentProvider的包.类的名称。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">".MyProvider"</span></span></div><div class="line">		  <span class="attr">android:authorities</span>=<span class="string">"com.xxx.MyApp.myprovider"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p><strong>Path：</strong>表名，用以区分ContentProvider中不同的数据表；<br><strong>Id：</strong>Id号，用以区别表中的不同数据记录；如果没有ID，就表示返回全部； “content://com.xxx.MyApp.myprovider/tablename/#” #表示数据id。<br>【举例】<br>1、要操作person表中id为10的记录，可以构建这样的路径:/person/10<br>2、要操作person表中id为10的记录的name字段， person/10/name<br>3、要操作person表中的所有记录，可以构建这样的路径:/person<br>4、如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：Uri uri = Uri.parse(“content://com.xxx.MyApp.myprovider/person”)<br><strong>【每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。Android所提供的ContentProvider都存放在android.provider包当中】</strong></p>
<h2 id="2、工具类：UriMatcher"><a href="#2、工具类：UriMatcher" class="headerlink" title="2、工具类：UriMatcher"></a>2、工具类：UriMatcher</h2><p>因为Uri代表了要操作的数据，所以我们经常需要解析Uri，并从Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为<strong>UriMatcher</strong>和<strong>ContentUris</strong> 。掌握它们的使用，会便于我们的开发工作。<br>使用方法如下：<br><strong>第一步，初始化：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码</span></div><div class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</div></pre></td></tr></table></figure></p>
<p><strong>第二步，注册需要的Uri:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果match()方法匹配content://com.xxx.MyApp.myprovider/person路径，返回匹配码为1</span></div><div class="line">matcher.addURI(<span class="string">"com.xxx.MyApp.myprovider"</span>, <span class="string">"person"</span>, <span class="number">1</span>);  </div><div class="line"><span class="comment">//如果match()方法匹配content://com.xxx.MyApp.myprovider/person/230路径，返回匹配码为2</span></div><div class="line">matcher.addURI(<span class="string">"com.xxx.MyApp.myprovider"</span>, <span class="string">"person/#"</span>, <span class="number">2</span>);  <span class="comment">//#号为通配符</span></div></pre></td></tr></table></figure></p>
<p><strong>第三步，与已经注册的Uri进行匹配:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/people"</span>);  </div><div class="line"><span class="keyword">int</span> match = matcher.match(uri);  </div><div class="line">			 <span class="keyword">switch</span> (match)  </div><div class="line">			 &#123;  </div><div class="line">					 <span class="keyword">case</span> <span class="number">1</span>:  </div><div class="line">							 <span class="keyword">break</span>;</div><div class="line">					 <span class="keyword">case</span> <span class="number">2</span>:  </div><div class="line">							 <span class="keyword">break</span>;</div><div class="line">					 <span class="keyword">default</span>:  </div><div class="line">							 <span class="keyword">break</span>;</div><div class="line">			 &#125;</div></pre></td></tr></table></figure></p>
<p>match方法匹配后会返回一个匹配码Code，即在使用注册方法addURI时传入的第三个参数。 </p>
<h2 id="3、工具类ContentUris："><a href="#3、工具类ContentUris：" class="headerlink" title="3、工具类ContentUris："></a>3、工具类ContentUris：</h2><p>ContentUris类用于操作Uri路径后面的ID部分，它有两个比较实用的方法：<br><strong>withAppendedId(uri, id)</strong>用于为路径加上ID部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/person"</span>)</div><div class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">10</span>); </div><div class="line"><span class="comment">//生成后的Uri为：content://com.xxx.MyApp.myprovider/person/10</span></div></pre></td></tr></table></figure></p>
<p><strong>parseId(uri)</strong>方法用于从路径中获取ID部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/person/10"</span>)</div><div class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);<span class="comment">//获取的结果为:10</span></div></pre></td></tr></table></figure></p>
<h1 id="使用ContentProvider共享数据-Demo，下载链接见附录"><a href="#使用ContentProvider共享数据-Demo，下载链接见附录" class="headerlink" title="使用ContentProvider共享数据(Demo，下载链接见附录)"></a><center>使用ContentProvider共享数据(Demo，下载链接见附录)</center></h1><h2 id="1、建立一个Provider所用到变量类"><a href="#1、建立一个Provider所用到变量类" class="headerlink" title="1、建立一个Provider所用到变量类"></a>1、建立一个Provider所用到变量类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentData</span> </span>&#123;</div><div class="line">		<span class="comment">//provider唯一标示信息</span></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_AUTHORITY = <span class="string">"com.xxx.MyApp.myprovider"</span>;</div><div class="line">		<span class="comment">//基础Uri</span></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BASE_CONTENT_URI = Uri.parse(<span class="string">"content://"</span> + CONTENT_AUTHORITY);</div><div class="line">		<span class="comment">//操作表的名称</span></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH_TEST = <span class="string">"people"</span>;</div><div class="line">		<span class="comment">//表中记录信息</span></div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEntry</span> <span class="keyword">implements</span> <span class="title">BaseColumns</span> </span>&#123;				</div><div class="line">				<span class="comment">// 完整Uri</span></div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri CONTENT_URI = BASE_CONTENT_URI.buildUpon().appendPath(PATH_TEST).build();</div><div class="line">				<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Uri <span class="title">buildUri</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">						<span class="keyword">return</span> ContentUris.withAppendedId(CONTENT_URI, id);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME = <span class="string">"people"</span>;</div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NAME = <span class="string">"name"</span>;</div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_SEX = <span class="string">"sex"</span>;</div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_AGE = <span class="string">"age"</span>;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、Provider最终还要操作数据库，这里我们写数据库操作类代码"><a href="#2、Provider最终还要操作数据库，这里我们写数据库操作类代码" class="headerlink" title="2、Provider最终还要操作数据库，这里我们写数据库操作类代码"></a>2、Provider最终还要操作数据库，这里我们写数据库操作类代码</h2><p><strong><a href="http://www.woobo.me/2016/07/15/DataStorage/" target="_blank" rel="external">数据库使用：Android实习生 —— 数据存储共享</a></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">		<span class="comment">//数据库版本</span></div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</div><div class="line">		<span class="comment">//数据库名称</span></div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"people.db"</span>;</div><div class="line">		<span class="comment">//构造方法</span></div><div class="line">		 <span class="function"><span class="keyword">public</span> <span class="title">DBOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		 <span class="keyword">super</span>(context, DATABASE_NAME,<span class="keyword">null</span>, DATABASE_VERSION);</div><div class="line">		 &#125;		</div><div class="line">		<span class="comment">//通过sql语句建表并插入数据</span></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">				System.out.println(<span class="string">"create table"</span>);</div><div class="line">				<span class="keyword">final</span> String SQL_CREATE_CONTACT_TABLE = <span class="string">"CREATE TABLE "</span> + ContentData.TestEntry.TABLE_NAME + <span class="string">"( "</span></div><div class="line">								+ <span class="string">"_id integer primary key autoincrement,"</span></div><div class="line">								+ ContentData.TestEntry.COLUMN_NAME + <span class="string">" TEXT NOT NULL,"</span></div><div class="line">								+ ContentData.TestEntry.COLUMN_SEX + <span class="string">" TEXT NOT NULL,"</span></div><div class="line">								+ ContentData.TestEntry.COLUMN_AGE + <span class="string">" INTEGER NOT NULL );"</span>;</div><div class="line">				db.execSQL(SQL_CREATE_CONTACT_TABLE);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张三','女',18)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张四','男',20)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张五','女',19)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张六','男',22)"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//数据库升级的时候会调用的代码</span></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">				db.execSQL(<span class="string">"DROP TABLE IF EXISTS "</span> + ContentData.TestEntry.TABLE_NAME);</div><div class="line">				onCreate(db);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3、创建自己的Provider"><a href="#3、创建自己的Provider" class="headerlink" title="3、创建自己的Provider"></a>3、创建自己的Provider</h2><p><strong>MyProvider继承ContentProvider。默认该Provider需要实现如下六个方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> DBOpenHelper dbOpenHelper;<span class="comment">//声明数据库操作类</span></div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TEST = <span class="number">100</span>;<span class="comment">//匹配码		</span></div><div class="line">		<span class="comment">//使用UriMatcher解析Uri，如果被匹配到，返回匹配码100</span></div><div class="line">		<span class="function"><span class="keyword">static</span> UriMatcher <span class="title">buildUriMatcher</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">final</span> UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</div><div class="line">				<span class="keyword">final</span> String authority = ContentData.CONTENT_AUTHORITY;</div><div class="line">				matcher.addURI(authority, ContentData.PATH_TEST, TEST);</div><div class="line">				<span class="keyword">return</span> matcher;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法在ContentProvider被其它应用第一次访问它时才会被创建。</span></div><div class="line">	 <span class="comment">//同时我们操作数据库建表</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">				 dbOpenHelper = <span class="keyword">new</span> DBOpenHelper(getContext());</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用往ContentProvider添加数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues contentValues)</span> </span>&#123;</div><div class="line">				<span class="comment">//获得可写数据库</span></div><div class="line">				<span class="keyword">final</span> SQLiteDatabase db = dbOpenHelper.getWritableDatabase();</div><div class="line">				Uri returnUri;</div><div class="line">				<span class="keyword">long</span> _id;</div><div class="line">				<span class="keyword">switch</span> ( buildUriMatcher().match(uri)) &#123;</div><div class="line">						<span class="keyword">case</span> TEST:</div><div class="line">								<span class="comment">//插入数据</span></div><div class="line">								_id = db.insert(ContentData.TestEntry.TABLE_NAME, <span class="keyword">null</span>, values);</div><div class="line">								<span class="keyword">if</span> ( _id &gt; <span class="number">0</span> )</div><div class="line">										returnUri = ContentData.TestEntry.buildUri(_id);</div><div class="line">								<span class="keyword">else</span></div><div class="line">										<span class="keyword">throw</span> <span class="keyword">new</span> android.database.SQLException(<span class="string">"Failed to insert row into "</span> + uri);</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">						<span class="keyword">default</span>:</div><div class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> android.database.SQLException(<span class="string">"Unknown uri: "</span> + uri);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> returnUri;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用从ContentProvider删除数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String s, String[] strings)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用从ContentProvider中获取数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>    		</span>&#123;</div><div class="line">				<span class="comment">//获得可读数据库</span></div><div class="line">				<span class="keyword">final</span> SQLiteDatabase db = dbOpenHelper.getReadableDatabase();</div><div class="line">				 <span class="comment">//查到的结果是游标类型。</span></div><div class="line">				Cursor cursor = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">switch</span> ( buildUriMatcher().match(uri)) &#123;</div><div class="line">						<span class="keyword">case</span> TEST:</div><div class="line">								cursor = db.query(ContentData.TestEntry.TABLE_NAME, projection, selection, selectionArgs, sortOrder, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> cursor;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用从ContentProvider更新数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues contentValues, String s, String[] strings)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//该方法用于返回当前Uri所代表数据的MIME类型。</span></div><div class="line">		<span class="comment">//如果操作的数据属于集合类型，那么MIME类型字符串应以vnd.android.cursor.dir/开头，</span></div><div class="line">		<span class="comment">//例如：要得到所有person记录的Uri为content://com.xxx.MyApp.myprovider/person，</span></div><div class="line">		<span class="comment">//那么返回的MIME类型字符串应该为："vnd.android.cursor.dir/person"。</span></div><div class="line">		<span class="comment">//如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头，</span></div><div class="line">		<span class="comment">//例如：得到id为10的person记录，Uri为content://com.xxx.MyApp.myprovider/person/10，</span></div><div class="line">		<span class="comment">//那么返回的MIME类型字符串为："vnd.android.cursor.item/person"。</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>【注意】以上代码并没有实现删除，更改功能</p>
<h2 id="4、注册Provider"><a href="#4、注册Provider" class="headerlink" title="4、注册Provider"></a>4、注册Provider</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//应用内访问</span></div><div class="line">&lt;provider    </div><div class="line">		android:authorities=<span class="string">"com.xxx.MyApp.myprovider"</span>  </div><div class="line">		android:name=<span class="string">".MyProvider"</span> /&gt;</div></pre></td></tr></table></figure>
<p>在注册的时候需要注意几个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">android:exported 设置此provider是否可以被其他应用使用。</div><div class="line">android:readPermission 该provider的读权限的标识</div><div class="line">android:writePermission 该provider的写权限标识</div><div class="line">android:permission provider读写权限标识</div></pre></td></tr></table></figure></p>
<p>如何让其他应用也可以访问此应用中的数据呢，我们需要这么注册<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span></span></div><div class="line">		<span class="attr">android:authorities</span>=<span class="string">"com.xxx.MyApp.myprovider"</span></div><div class="line">		<span class="attr">android:name</span>=<span class="string">".MyProvider"</span></div><div class="line">		<span class="attr">android:readPermission</span>=<span class="string">"com.xxx.READ"</span></div><div class="line">		<span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>并且要在注册文件中声明一个permission<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"com.bb.READ"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>【通过以上步骤，一个ContentProvider就造好了。】</p>
<h1 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a><center>ContentResolver</center></h1><p><strong>使用ContentResolver调用ContentProvider去操作数据库数据</strong></p>
<h2 id="为什么我们不直接访问Provider。"><a href="#为什么我们不直接访问Provider。" class="headerlink" title="为什么我们不直接访问Provider。"></a>为什么我们不直接访问Provider。</h2><p>大家要知道一台手机中可不是只有一个Provider内容，它可能安装了很多含有Provider的应用，比如联系人应用，日历应用，字典应用等等。有如此多的Provider，如果你开发一款应用要使用其中多个，如果让你去了解每个ContentProvider的不同实现，岂不是要头都大了。所以Android为我们提供了ContentResolver来统一管理与不同ContentProvider间的操作。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-3616f72087c6afef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ContentResolver"></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p><img src="http://upload-images.jianshu.io/upload_images/4821697-5ba27903f90db1a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现数据操作的过程"><br>1、当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法通过URI进行数据操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentResolver resolver = getContentResolver();</div></pre></td></tr></table></figure></p>
<p>2、ContentResolver 类提供了与ContentProvider类相同签名的四个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>：</span></div><div class="line"><span class="comment">//该方法用于往ContentProvider添加数据。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span>：</div><div class="line"><span class="comment">//该方法用于从ContentProvider删除数据。</span></div><div class="line"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>：</div><div class="line"><span class="comment">//该方法用于从ContentProvider中获取数据。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>：</div><div class="line"><span class="comment">//该方法用于更新ContentProvider中的数据。</span></div></pre></td></tr></table></figure></p>
<p>使用ContentResolver对我们刚才造的ContentProvider中的数据进行添加、查询操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"><span class="comment">//声明Uri常量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri CONTENT_URI = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/people"</span>);</div><div class="line">TextView tv_id, tv_name, tv_sex, tv_age;    </div><div class="line">		 <span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				tv_id = (TextView) findViewById(R.id.tv_id);</div><div class="line">				tv_name = (TextView) findViewById(R.id.tv_name);</div><div class="line">				tv_sex = (TextView) findViewById(R.id.tv_sex);</div><div class="line">				tv_age = (TextView) findViewById(R.id.tv_age);</div><div class="line">				&#125;			</div><div class="line">			<span class="comment">//query()为在xml组建中定义的OnClick</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">				<span class="comment">//通过getContentResolver().query调用ContentProvider实现对数据库的查询</span></div><div class="line">				tv_id.setText(<span class="string">""</span>);</div><div class="line">				tv_name.setText(<span class="string">""</span>);</div><div class="line">				tv_sex.setText(<span class="string">""</span>);</div><div class="line">				tv_age.setText(<span class="string">""</span>);</div><div class="line">				Cursor cursor = getContentResolver().query(CONTENT_URI, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>, <span class="string">"name"</span>, <span class="string">"sex"</span>, <span class="string">"age"</span></div><div class="line">				&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">				<span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="keyword">while</span> (cursor.moveToNext()) &#123;</div><div class="line">								tv_id.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"_id"</span>)));</div><div class="line">								tv_name.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>)));</div><div class="line">								tv_sex.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"sex"</span>)));</div><div class="line">								tv_age.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"age"</span>)));</div><div class="line">						&#125;</div><div class="line">						cursor.close();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">				<span class="comment">//通过getContentResolver().insert调用ContentProvider实现对数据库的增加</span></div><div class="line">				ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">				values.put(<span class="string">"name"</span>, <span class="string">"新来的"</span>);</div><div class="line">				values.put(<span class="string">"sex"</span>, <span class="string">"男"</span>);</div><div class="line">				values.put(<span class="string">"age"</span>, <span class="string">"28"</span>);</div><div class="line">				getContentResolver().insert(CONTENT_URI, values);</div><div class="line">				query(findViewById(R.id.btn_query));</div><div class="line">			&#125;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>【XML布局请下载Demo】<br>3、在注册文件中记得增加权限读取权限<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.xxx.READ"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>4、最终效果<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4df4ec743579042b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击查询"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-b555a4f42aac29b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击增加"></p>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a>【附录】</h1><h2 id="相关Demo"><a href="#相关Demo" class="headerlink" title="相关Demo"></a>相关Demo</h2><p>请先安装MyProvider，再安装MyResolver。<br><a href="https://github.com/JayKuzzi/Android/tree/master/MyProvider" target="_blank" rel="external">MyProvider</a>、<a href="https://github.com/JayKuzzi/Android/tree/master/MyResolver" target="_blank" rel="external">MyResolver</a><br>另赠送两个Demo，关于对系统Provider的调用（增、查联系人）<br><a href="https://github.com/JayKuzzi/Android/tree/master/ContentProviderDemo2" target="_blank" rel="external">增加联系人</a>、<a href="https://github.com/JayKuzzi/Android/tree/master/ContentProviderDemo1" target="_blank" rel="external">查询联系人</a></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/07/05/ContentProvider/content.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 四大组件之Service</title>
    <link href="https://jaykuzzi.github.io/2016/06/26/Service/"/>
    <id>https://jaykuzzi.github.io/2016/06/26/Service/</id>
    <published>2016-06-26T08:28:56.000Z</published>
    <updated>2017-06-27T12:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/06/26/Service/service.png" alt=""><br><a id="more"></a></p>
<h1 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a><center>基础回顾</center></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Service是可以在<strong>后台执行长时间（长生命周期）</strong>而又<strong>不与用户产生UI交互（没有用户界面）</strong>的操作。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>1、</strong>只能在后台运行，即便用户切换了其他应用，启动的Service仍可在后台运行。<br><strong>2、</strong>可以和其他组件进行Service绑定并与之交互，甚至是跨进程通信（IPC）。<br><strong>3、</strong>不能运行在一个独立的进程当中，而是依赖与创建服务时所在的应用组件进程。<br><strong>4、</strong>服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务。</p>
<h2 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h2><p><strong>音乐播放：</strong>播放多媒体的时候用户启动了其他Activity，此时要在后台继续播放。<br><strong>记录检测：</strong>比如检测SD卡上文件的变化；在后台记录你的地理信息位置的改变等。<br><strong>其他操作：</strong>网络请求、执行文件读写操作或者与 content provider交互。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><strong>本地服务</strong>依附在主进程上，在一定程度上节约了资源。本地服务因为是在同一进程，因此不需要IPC，也不需要AIDL。相应bindService会方便很多。缺点是主进程被kill后，服务变会终止。<br><strong>远程服务</strong>是独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被kill的是偶，该服务依然在运行。缺点是该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。本文第六部分将会简单的讲述这一进程间通信方式。<br><em>对于startService来说，不管是本地服务还是远程服务，我们需要做的工作都一样简单。</em></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><center>生命周期</center></h1><p>从Service的启动到销毁，有两种路径（两种生命周期）：<br><strong>startService、bindService</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-cbd6cf296164ddd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service两种生命周期"></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><center>使用方法</center></h1><h2 id="1、通过startService方式定义一个Service（继承Service类）"><a href="#1、通过startService方式定义一个Service（继承Service类）" class="headerlink" title="1、通过startService方式定义一个Service（继承Service类）"></a>1、通过startService方式定义一个Service（继承Service类）</h2><p><strong>核心步骤和代码：</strong><br>创建一个类继承android.app.Service类，实现抽象方法onBind()，重写onCreate()、onStartCommand()、onDestry()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;  </div><div class="line">			 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;  </div><div class="line">			 <span class="comment">//创建服务时调用</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;  </div><div class="line">					 <span class="keyword">super</span>.onCreate();  </div><div class="line">					 Log.d(TAG, <span class="string">"onCreate"</span>);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="comment">//服务执行的操作</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;  </div><div class="line">					 Log.d(TAG, <span class="string">"onStartCommand"</span>);  </div><div class="line">					 <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="comment">//销毁服务时调用</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;  </div><div class="line">					 <span class="keyword">super</span>.onDestroy();  </div><div class="line">					 Log.d(TAG, <span class="string">"onDestroy"</span>);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="comment">//onBind()方法是Service中唯一的一个抽象方法，所以必须要在子类里实现。</span></div><div class="line">			 <span class="comment">//Service有两种启动方式：一种是startService()，另一种是bindService()。第二种启动方式才会用到onBind()方法。</span></div><div class="line">			 <span class="comment">//我们这先用第一种方式定义Service，所以暂时忽略onBind()方法。</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;  </div><div class="line">					 <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">			 &#125;</div></pre></td></tr></table></figure></p>
<p>在清单文件中配置Service,和Activity标签并列。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyService"</span>&gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><em>请注意：为了保证应用的安全，请使用显式Intent启动或绑定一个Service，请不要在<service>标签中配置intent-filter。</service></em><br>在Activity组件中通过onCreate()声明“启动Service和停止Service”代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;  </div><div class="line">			 <span class="keyword">private</span> Button button1_start_service;  </div><div class="line">			 <span class="keyword">private</span> Button button2_stop_service; </div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">					 <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">					 setContentView(R.layout.activity_main);  </div><div class="line">					 button1_start_service = (Button)findViewById(R.id.button1_start_service);  </div><div class="line">					 button2_stop_service = (Button)findViewById(R.id.button2_stop_service);  </div><div class="line">					 button1_start_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">					 button2_stop_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">					 <span class="keyword">switch</span> (v.getId()) &#123;  </div><div class="line">					 <span class="keyword">case</span> R.id.button1_start_service:  </div><div class="line">							 Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">							 startService(startIntent);  </div><div class="line">							 <span class="keyword">break</span>;  </div><div class="line">					 <span class="keyword">case</span> R.id.button2_stop_service:  </div><div class="line">							 Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">							 stopService(stopIntent);  </div><div class="line">							 <span class="keyword">break</span>;  </div><div class="line">					 <span class="keyword">default</span>:  </div><div class="line">							 <span class="keyword">break</span>;  </div><div class="line">					 &#125;  </div><div class="line">			 &#125;  </div><div class="line">	 &#125;</div></pre></td></tr></table></figure></p>
<p>启动和停止服务：<br>startService()和stopService()方法都是定义在Context类当中的，所以可以在MainActivity中直接调用这两个方法。<br> 运行上面的程序，点击button1_start_service按钮，通过Intent实现启动服务，后台打印日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-124753834491008c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过startService方式启动服务后台日志"><br>说明服务启动成功。<br>那么如果我再连续点三次button1_start_service按钮，后台增加的日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-e41f3601e6784870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过startService方式多次启动服务后台日志"><br><strong>onCreate()方法只会在Service第一次被创建的时候调用，而onStartCommand()方法在每次启动服务的时候都会调用。</strong><br>我们还可以在正在“设置–应用—运行”中找到这个服务，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-5d237864961d6359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手机运行的服务"><br>如果我们再点击button2_stop_service按钮或者点击上图中的“Stop”，MyService服务就停止掉了（多次点击stop不会再产生日志）：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-7fc0f1bcd9e6ca05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过startService方式停止服务后台日志"><br><strong>通过startService方式（继承Service类）总结</strong><br><strong>1、启动服务对象多次启动同时只会产生一个，onCreate()方法只会在Service第一次被创建的时候调用，多次点击启动会执行多次onStartCommand()方法，onDestroy()方法只会在Service第一次被停止的时候调用，多次点击停止不会报异常，也不再执行onDestroy()方法。</strong><br><strong>2、一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。</strong><br><strong>3、停止一个started服务有两种方法：</strong><br><strong>（1）在外部使用stopService()手动停止。</strong><br><strong>（2）在服务内部(onStartCommand方法内部)使用stopSelf()方法，使服务执行完毕后自动停止。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</strong><br><strong>4、onStartCommand方法的返回值：</strong><br>onStartCommand方法执行时，返回的是一个int型。这个整型可以有三个返回值：<strong>START_NOT_STICKY</strong>、<strong>START_STICKY</strong>、<strong>START_REDELIVER_INTENT</strong><br><strong>START_NOT_STICKY:</strong>“非粘性的”。使用这个返回值时，如果在执行完onStartCommand方法后，服务被异常kill掉，系统不会自动重启该服务。<br><strong>START_STICKY：</strong>如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。<br><strong>START_REDELIVER_INTENT：</strong>重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。<br><strong>5、默认情况下，一个started的Service与启动他的组件在同一个线程中。上面的实例中，服务就是在主线程中运行的，如果是在服务中完成耗时操作的话，容易造成主线程阻塞。所以我们可以在服务中开启一个子线程来完成耗时操作。</strong></p>
<h2 id="2、通过startService方式定义一个Service（继承IntentService类）："><a href="#2、通过startService方式定义一个Service（继承IntentService类）：" class="headerlink" title="2、通过startService方式定义一个Service（继承IntentService类）："></a>2、通过startService方式定义一个Service（继承IntentService类）：</h2><p><strong>为什么要通过继承IntentService来定义：</strong><br>我们在基础回顾的注意事项3、4中就已经了解，服务中的代码默认运行在主线程中，如果直接在服务里执行一些安卓不允许的耗时操作，容易造成主线程ANR（Application Not Responding）异常，所以就需要用到多线程的知识了，需要在服务的内部手动创建子线程。所以一个比较标准的服务可以这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;  </div><div class="line">			<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;   </div><div class="line">		 <span class="comment">//服务执行的操作</span></div><div class="line">		 <span class="meta">@Override</span>  </div><div class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;  </div><div class="line">				 <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">						 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">									<span class="comment">//在子线程中处理具体的逻辑</span></div><div class="line">									<span class="comment">//在这里我们只做打印子线程id的操作</span></div><div class="line">								 Log.i(<span class="string">"MyService"</span>,Thread.currentThread().getId()+<span class="string">""</span>);</div><div class="line">								 stopSelf();  <span class="comment">//服务执行完毕后自动停止</span></div><div class="line">						 &#125;</div><div class="line">				 &#125;).start();        </div><div class="line">				 <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);  </div><div class="line">		 &#125;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		 <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				 <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		 &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在MainActivity中启动Service代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;  </div><div class="line">	 <span class="keyword">private</span> Button button1_start_service;  </div><div class="line">	 <span class="keyword">private</span> Button button2_stop_service; </div><div class="line">	 <span class="meta">@Override</span>  </div><div class="line">	 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">			 <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">			 setContentView(R.layout.activity_main);  </div><div class="line">			 button1_start_service = (Button)findViewById(R.id.button1_start_service);  </div><div class="line">			 button2_stop_service = (Button)findViewById(R.id.button2_stop_service);  </div><div class="line">			 button1_start_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">			 button2_stop_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">	 &#125;  </div><div class="line">	 <span class="meta">@Override</span>  </div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">			 <span class="keyword">switch</span> (v.getId()) &#123;  </div><div class="line">			 <span class="keyword">case</span> R.id.button1_start_service:  </div><div class="line">					 Log.i(<span class="string">"Main"</span>,Thread.currentThread().getId()+<span class="string">""</span>);</div><div class="line">					 Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">					 startService(startIntent);  </div><div class="line">					 <span class="keyword">break</span>;  </div><div class="line">			 <span class="keyword">case</span> R.id.button2_stop_service:  </div><div class="line">					 Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">					 stopService(stopIntent);  </div><div class="line">					 <span class="keyword">break</span>;  </div><div class="line">			 <span class="keyword">default</span>:  </div><div class="line">					 <span class="keyword">break</span>;  </div><div class="line">			 &#125;  </div><div class="line">	 &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注册Service步骤不再赘述，当开启Service后打印日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-00dd1c9045c24286.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service手动开启线程177"><br>如果我们不手动开启线程，I/MyService: 177将会变成它依赖的主线程1，这就不能做耗时操作了。虽说上面的这种写法并不复杂，但总会有一些程序猿忘记开启线程，或者忘记调用stopSelf()方法。<br><strong>为了可以简单地创建一个可开启单独线程、会自动停止的服务，Android专门提供了一个IntentService类，这个类就很好的解决了上面所提到的两种尴尬。</strong><br><strong>IntentService的作用：</strong><br>当我们需要这样一次性完成的任务时，就可以使用IntentService来完成。<br><strong>IntentService的用法：</strong><br> 1）新建一个MyIntentService类，继承自IntentService，并重写父类的onHandleIntent()方法，代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class MyIntentService extends IntentService&#123;</div><div class="line">			public MyIntentService() &#123;</div><div class="line">				 //第一步：重写父类的onHandleIntent()方法，这里首先要提供一个无参的构造方法，</div><div class="line">				 //并且必须在其内部调用父类的有参构造方法，这里我们手动给服务起个名字为：MyIntentService</div><div class="line">				 super("MyIntentService");</div><div class="line">		 &#125;</div><div class="line">			 //第二步：重写父类的onHandleIntent()方法，该方法在会在一个单独的线程中执行，</div><div class="line">			 //来完成工作任务。任务结束后，该Service自动停止</div><div class="line">		 @Override</div><div class="line">		 protected void onHandleIntent(Intent intent) &#123;</div><div class="line">				 for(int i = 0;i&lt;3;i++) &#123;</div><div class="line">						 //Service要执行的逻辑</div><div class="line">						 //这里我们只打印当前线程的id</div><div class="line">						 Log.d("MyIntentService","IntentService线程的id是："+Thread.currentThread().getId());</div><div class="line">						 try &#123;</div><div class="line">								 //线程睡眠一秒钟</div><div class="line">								 Thread.sleep(1000);</div><div class="line">						 &#125; catch (InterruptedException e) &#123;</div><div class="line">								 e.printStackTrace();</div><div class="line">						 &#125;</div><div class="line">				 &#125;        </div><div class="line">		 &#125;</div><div class="line">		 @Override</div><div class="line">		 public void onDestroy() &#123;</div><div class="line">				 super.onDestroy();</div><div class="line">				 Log.d("MyIntentService","onDestroy");</div><div class="line">		 &#125;</div><div class="line"> &#125;</div><div class="line">```java</div><div class="line"> 2）在清单文件中对服务进行注册服务：</div><div class="line">```xml</div><div class="line">&lt;service android:name=".MyIntentService"&gt;&lt;/service&gt;</div></pre></td></tr></table></figure></p>
<p>3)在MainActivity里面加入启动IntentService的逻辑，核心代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> R.id.button3_stop_intentservice:</div><div class="line">		 Log.d(<span class="string">"MainActivity"</span>,<span class="string">"主线程的id是："</span>+Thread.currentThread().getId());</div><div class="line">		 Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyIntentService.class);</div><div class="line">		 startService(intentService);</div></pre></td></tr></table></figure></p>
<p>运行程序，日志显示如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-0fc34183a06cceb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过继承IntentService运行结果"><br><strong>通过startService方式（继承IntentService类） 总结</strong><br><strong>1、启动一个IntentService和启动一个普通的Service，步骤是相似的。</strong><br><strong>2、与直接继承Service不同在于：通过继承IntentService运行，自动开启了单独线程，而且完成任务后自动销毁了Service。</strong><br><strong>【补充】Service和Thread的关系：</strong><br>不少Android初学者都可能会有这样的疑惑，Service和Thread到底有什么关系呢？什么时候应该用Service，什么时候又应该用Thread？答案可能会有点让你吃惊，因为Service和Thread之间没有任何关系！<br>之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但是，Service其实是运行在主线程里的，一些比较耗时的操作需要开启单独线程。</p>
<h2 id="3、通过bindService方式定义一个Service：（使用Bind-Service完成Service和Activity之间的通信）："><a href="#3、通过bindService方式定义一个Service：（使用Bind-Service完成Service和Activity之间的通信）：" class="headerlink" title="3、通过bindService方式定义一个Service：（使用Bind Service完成Service和Activity之间的通信）："></a>3、通过bindService方式定义一个Service：（使用Bind Service完成Service和Activity之间的通信）：</h2><p><strong>Bind Service的引入：</strong><br>有没有什么办法能让Service与组件的关联更多一些呢？比如说在Activity中指挥Service去干什么，Service就去干什么。当然可以，只需要让Activity和Service建立关联就好了。这时我们就可以通过bindService方式定义一个Service。<br><strong>Bind Service的实现原理：</strong><br> 应用程序组件(客户端）通过调用bindService()方法能够绑定服务，然后Android系统会调用服务的onBind()回调方法，则个方法会返回一个跟服务器端交互的Binder对象。<br>bindService()方法立即返回，并且不给客户端返回IBinder对象。要接收IBinder对象，客户端必须创建一个ServiceConnection类的实例，并且把这个实例传递给bindService()方法。ServiceConnection对象包含了一个系统调用的传递IBinder对象的回调方法。<br><strong>Bind Service实现流程：</strong><br>1）一直有一个onBind()方法我们都没有使用到，这个方法其实就是用于和Activity建立关联的，修改MyService中的代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBindService01</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyBindService01"</span>;</div><div class="line">		<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate();</div><div class="line">				Log.d(TAG, <span class="string">"onCreate"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> mBinder;  <span class="comment">//在这里返回新建的MyBinder类</span></div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				Log.d(TAG, <span class="string">"onUnbind"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">				Log.d(TAG, <span class="string">"onStartCommand"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onDestroy();</div><div class="line">				Log.d(TAG, <span class="string">"onDestroy"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度</span></div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</div><div class="line">						Log.d(<span class="string">"TAG"</span>, <span class="string">"startDownload() executed"</span>);</div><div class="line">						<span class="comment">// 执行具体的下载任务  </span></div><div class="line">				&#125;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProgress</span><span class="params">()</span></span>&#123;</div><div class="line">						Log.d(<span class="string">"TAG"</span>, <span class="string">"getProgress() executed"</span>);</div><div class="line">						<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新建一个MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度。当然，这里只是两个模拟方法，并没有实现真正的功能，我们通过打印日志的形式来体现。<br>接着创建MyBinder的实例，然后在onBind()方法里返回这个实例。返回这个mBinder，是一个IBinder类型，就可以把这个IBinder类型传递到MainActivity中，从而调用Service里面的方法。<br>2）检查清单文件，是否已经对Service进行注册：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyBindService01"</span> &gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>3）让我们修改MainActivity和MyBindService01之间建立关联<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> Button button1_bind_service;</div><div class="line">		<span class="keyword">private</span> Button button2_unbind_service;</div><div class="line">		<span class="keyword">private</span> MyBindService01.MyBinder myBinder;</div><div class="line">		<span class="keyword">boolean</span> mBound = <span class="keyword">false</span>; <span class="comment">//一开始，并没有和Service绑定.这个参数是用来显示绑定状态		</span></div><div class="line">		<span class="comment">//匿名内部类：服务连接对象</span></div><div class="line">		<span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;				</div><div class="line">				<span class="comment">//当服务异常终止时会调用。注意，解除绑定服务时不会调用</span></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">						mBound = <span class="keyword">false</span>; <span class="comment">//服务异常终止时，状态为未绑定</span></div><div class="line">						<span class="comment">//解决了多次执行unbindService()方法引发的异常问题</span></div><div class="line">				&#125;				</div><div class="line">				<span class="comment">//和服务绑定成功后，服务会回调该方法</span></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">						myBinder = (MyBindService01.MyBinder) service;</div><div class="line">						<span class="comment">//在Activity中调用Service里面的方法</span></div><div class="line">						myBinder.startDownload();</div><div class="line">						myBinder.getProgress();</div><div class="line">						mBound = <span class="keyword">true</span>; <span class="comment">//true说明是绑定状态</span></div><div class="line">				&#125;</div><div class="line">		&#125;;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				button1_bind_service = (Button) findViewById(R.id.button1_bind_service);</div><div class="line">				button2_unbind_service = (Button) findViewById(R.id.button2_unbind_service);</div><div class="line">				button1_bind_service.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">				button2_unbind_service.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="keyword">switch</span> (v.getId()) &#123;</div><div class="line">				<span class="keyword">case</span> R.id.button1_bind_service:</div><div class="line">						Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</div><div class="line">						bindService(bindIntent, connection, BIND_AUTO_CREATE);</div><div class="line"><span class="comment">//这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后会自动创建Service（即使之前没有创建</span></div><div class="line"><span class="comment">//Service也没有关系），这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。</span></div><div class="line">						<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> R.id.button2_unbind_service:</div><div class="line">						<span class="comment">//如果和Service是绑定的状态，就解除绑定。</span></div><div class="line">						<span class="keyword">if</span>(mBound)&#123;</div><div class="line">								unbindService(connection);</div><div class="line">								mBound=<span class="keyword">false</span>;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明：这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，如果当前Activity与服务连接成功后，服务会回调onServiceConnected()方法<br>在onServiceConnected()方法中，我们又通过向下转型得到了MyBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。现在我们可以在Activity中根据具体的场景来调用MyBinder中的任何public方法，即实现了Activity指挥Service干什么Service就去干什么的功能。<br>4）执行bindService()方法。<br><img src="//upload-images.jianshu.io/upload_images/4821697-19b1f71bd708830b.png" alt=""><br>5）解除Activity和Service之间的关联。执行unbindService()。<br><img src="//upload-images.jianshu.io/upload_images/4821697-67e550c08838d7af.png" alt=""><br><strong>通过bindService方式 总结</strong><br><strong>1、onCreate()、onBind()方法只会在Service第一次被创建的时候调用，多次点击绑定启动不会执行任何方法，onUnbind()、onDestroy()方法会在调用者执行unbindService()方法时执行或者Activity退出时自动执行。</strong><br><strong>2、如果我们既通过startService()开启Service，又用通过bindService开启，必要unbindService()和stopService()都执行一次（没有先后顺序），Service才会被销毁。</strong><br><strong>3、如果多次执行unbinsService()方法，程序会异常退出，我们需要在代码中加一个判断是否绑定的标记mBound来解决此问题，上面代码中有说明。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> R.id.button4_unbind_service:</div><div class="line"><span class="comment">//如果和Service是绑定的状态，就解除绑定。</span></div><div class="line"><span class="keyword">if</span>(mBound)&#123;</div><div class="line">		unbindService(connection);</div><div class="line">		mBound=<span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p><strong>4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了）。</strong><br><strong>5、只有Activity、Service、Content Provider能够绑定服务；BroadcastReceiver广播接收器不能绑定服务。</strong></p>
<h2 id="4、bindService和startService混合使用："><a href="#4、bindService和startService混合使用：" class="headerlink" title="4、bindService和startService混合使用："></a>4、bindService和startService混合使用：</h2><p><strong>如果先startService,再bindService:</strong><br><strong>在bind的Activity退出的时候,Service会执行unBind方法而不执行其onDestory方法,因为有startService方法调用过,</strong><br><strong>所以Activity与Service解除绑定后会有一个与调用者没有关连的Service存在。</strong><br><strong>如果先bindService,再startService,再调用Context.stopService</strong><br><strong>Service的onDestory方法不会立刻执行,因为有一个与Service绑定的Activity,但是在Activity退出的时候,会执行其(Service的)onDestory方法,如果要立刻执行stopService,就得先解除绑定。</strong><br><strong>如果先是bind了，那么start的时候就直接运行Service的onStartCommand()方法，如果先是start，那么bind的时候就直接运行onBind()方法。</strong><br><strong>当一个服务没被onDestory()销毁之前，只有第一个启动它的客户端能调用它的onBind()和onUnbind()。</strong></p>
<h1 id="startService、bindService区别大总结"><a href="#startService、bindService区别大总结" class="headerlink" title="startService、bindService区别大总结"></a><center>startService、bindService区别大总结</center></h1><p><strong>1、生命周期不同。（详见二）</strong><br><strong>2、多次启动，前者会多次执行onStartCommand()方法，后者什么都不执行。多次停止，前者只会执行一次onDestroy()方法，后者报异常信息。</strong><br><strong>3、当启动Service的组件已被Destroy的时候，前者不停止，后者会停止。</strong><br><strong>4、前者停止直接执行onDestroy()方法（Service中的），后者则先解除绑onUnbind()定再执行onDestroy()方法（Service中的）。</strong><br><strong>5、当手机屏幕在“横”“竖”变换时，前者创建的Service不会停止，后者会随着Activity的重建而停止。</strong><br><strong>6、后者的onBind回调方法将返回给客户端一个IBinder接口实例，IBinder允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。而这些操作前者启动的Service是没有的。</strong></p>
<h1 id="在AndroidManifest-xml里Service元素常见选项"><a href="#在AndroidManifest-xml里Service元素常见选项" class="headerlink" title="在AndroidManifest.xml里Service元素常见选项"></a><center>在AndroidManifest.xml里Service元素常见选项</center></h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">android:name   --　服务类名</div><div class="line">android:label  --  服务的名字，如果此项不设置，那么默认显示的服务名则为类名</div><div class="line">android:icon　--　服务的图标</div><div class="line">android:permission　--　申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务</div><div class="line">android:process　--　表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字</div><div class="line">android:enabled　--表示是否能被系统实例化，为true表示可以，为false表示不可以，默认为true</div><div class="line">android:exported　--　表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false</div></pre></td></tr></table></figure>
<h1 id="扩展：进程间通信"><a href="#扩展：进程间通信" class="headerlink" title="扩展：进程间通信"></a><center>扩展：进程间通信</center></h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>调用者和Service如果不在一个进程内, 就需要使用android中的远程Service调用机制.<br>android使用AIDL定义进程间的通信接口. AIDL的语法与java接口类似, 需要注意以下几点:</p>
<ol>
<li>AIDL文件必须以.aidl作为后缀名.</li>
<li>AIDL接口中用到的数据类型, 除了基本类型, String, List, Map, CharSequence之外, 其他类型都需要导包, 即使两种在同一个包内. List和Map中的元素类型必须是AIDL支持的类型.</li>
<li>接口名需要和文件名相同.</li>
<li>方法的参数或返回值是自定义类型时, 该自定义的类型必须实现了Parcelable接口.</li>
<li>所有非java基本类型参数都需要加上in, out, inout标记, 以表明参数是输入参数, 输出参数, 还是输入输出参数.</li>
<li>接口和方法前不能使用访问修饰符和static, final等修饰.</li>
</ol>
<h2 id="远程通信扩展小例子"><a href="#远程通信扩展小例子" class="headerlink" title="远程通信扩展小例子"></a>远程通信扩展小例子</h2><p><strong>远程service</strong><br>要在service中注册信息中加上 android:process=”:remote”<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".AIDLService"</span></span></div><div class="line">				<span class="attr">android:process</span>=<span class="string">":remote"</span>&gt;<span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>远程service有什么用呢？</strong><br>远程service的作用只是重新建立一个新进程执行，可以独立出去。其他app可以调用这个service。因为是一个新的进程，所以也不能用bindService来建立关联了。可以用新的方式来建立关系就是下面要讲的aidl技术。<br><strong>AIDL实现</strong><br>1.首先我建立2个app工程，通过aidl实现一个app调用另一个app的service<br>目录结构如下：<br>service提供端app<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4047fd697202fee2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="service提供端"><br>利用aidl调用service的app<br><img src="http://upload-images.jianshu.io/upload_images/4821697-19958cfc5a71951c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="service调用端"><br>2.在两个app中都建立一个文件 IPerson.aidl注意 包名 要相同<br>IPerson.aidl只是一个接口文件,用来aidl交互的，建立好之后在Studio中点Build–&gt;Rebuild会自动创建需要的java文件。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-eccab12f13550592.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="接口路径"><br>IPerson.aidl代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> mangues.com.aidl;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</div><div class="line">		<span class="function">String <span class="title">greet</span><span class="params">(String someone)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.在aidl_service 中建立AIDLService<br>这个IPerson.Stub 就是通过IPerson.aidl 自动生成的binder 文件，你实现下，然后在onBind()中 return出去就好了，就和Android Service实现和activity交互一样。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AIDLService"</span>;</div><div class="line">		IPerson.Stub stub = <span class="keyword">new</span> IPerson.Stub() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(String someone)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">						Log.i(TAG, <span class="string">"greet() called"</span>);</div><div class="line">						<span class="keyword">return</span> <span class="string">"hello, "</span> + someone;</div><div class="line">				&#125;</div><div class="line">		&#125;;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate();</div><div class="line">				Log.i(TAG, <span class="string">"onCreate() called"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">				Log.i(TAG, <span class="string">"onBind() onStartCommand"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				Log.i(TAG, <span class="string">"onBind() called"</span>);</div><div class="line">				<span class="keyword">return</span> stub;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				Log.i(TAG, <span class="string">"onUnbind() called"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onDestroy();</div><div class="line">				Log.i(TAG, <span class="string">"onDestroy() called"</span>);</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.aidl_service MainActivity 中启动这个service<br>简单点就不写关闭什么的了；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">			setContentView(R.layout.activity_main);</div><div class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, AIDLService.class);</div><div class="line">			startService(startIntent);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在AndroidManifest.xml注册<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".AIDLService"</span></span></div><div class="line">								 <span class="attr">android:process</span>=<span class="string">":remote"</span>&gt;</div><div class="line">						<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">								<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.AIDLService"</span> /&gt;</span></div><div class="line">								<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>作用就是把这个service暴露出去，让别的APP可以利用<br>android.intent.action.AIDLService 字段隐形绑定这个service，获取数据。<br>5.aidl_client 中绑定aidl_service service 获取数据<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">			<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">			<span class="keyword">private</span> IPerson person;</div><div class="line">			<span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">				 <span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">						Log.i(<span class="string">"ServiceConnection"</span>, <span class="string">"onServiceConnected() called"</span>);</div><div class="line">						person = IPerson.Stub.asInterface(service);</div><div class="line">						String retVal = <span class="keyword">null</span>;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">								retVal = person.greet(<span class="string">"scott"</span>);</div><div class="line">						&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">								e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">						Toast.makeText(MainActivity.<span class="keyword">this</span>, retVal, Toast.LENGTH_SHORT).show();</div><div class="line">				&#125;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">						<span class="comment">//This is called when the connection with the service has been unexpectedly disconnected,</span></div><div class="line">						<span class="comment">//that is, its process crashed. Because it is running in our same process, we should never see this happen.</span></div><div class="line">						Log.i(<span class="string">"ServiceConnection"</span>, <span class="string">"onServiceDisconnected() called"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				Intent mIntent = <span class="keyword">new</span> Intent();</div><div class="line">				mIntent.setAction(<span class="string">"android.intent.action.AIDLService"</span>);</div><div class="line">				Intent eintent = <span class="keyword">new</span> Intent(getExplicitIntent(<span class="keyword">this</span>,mIntent));</div><div class="line">				bindService(eintent, conn, Context.BIND_AUTO_CREATE);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">getExplicitIntent</span><span class="params">(Context context, Intent implicitIntent)</span> </span>&#123;</div><div class="line">				<span class="comment">// Retrieve all services that can match the given intent</span></div><div class="line">				PackageManager pm = context.getPackageManager();</div><div class="line">				List&lt;ResolveInfo&gt; resolveInfo = pm.queryIntentServices(implicitIntent, <span class="number">0</span>);</div><div class="line">				<span class="comment">// Make sure only one match was found</span></div><div class="line">				<span class="keyword">if</span> (resolveInfo == <span class="keyword">null</span> || resolveInfo.size() != <span class="number">1</span>) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// Get component info and create ComponentName</span></div><div class="line">				ResolveInfo serviceInfo = resolveInfo.get(<span class="number">0</span>);</div><div class="line">				String packageName = serviceInfo.serviceInfo.packageName;</div><div class="line">				String className = serviceInfo.serviceInfo.name;</div><div class="line">				ComponentName component = <span class="keyword">new</span> ComponentName(packageName, className);</div><div class="line">				<span class="comment">// Create a new intent. Use the old one for extras and such reuse</span></div><div class="line">				Intent explicitIntent = <span class="keyword">new</span> Intent(implicitIntent);</div><div class="line">				<span class="comment">// Set the component to be explicit</span></div><div class="line">				explicitIntent.setComponent(component);</div><div class="line">				<span class="keyword">return</span> explicitIntent;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>和Android Service 中学习的调用MyBinder获取service中数据一样，这边只是吧MyBinder 改成了aidl定义的接口IPerson 本质上还是一个Binder。</strong><br><strong><em>因为android 5.0 不允许隐形启用service 所有用getExplicitIntent转一下</em></strong></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/06/26/Service/service.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 四大组件之Broadcast Receiver</title>
    <link href="https://jaykuzzi.github.io/2016/05/02/Receiver/"/>
    <id>https://jaykuzzi.github.io/2016/05/02/Receiver/</id>
    <published>2016-05-02T03:38:57.000Z</published>
    <updated>2017-06-27T12:11:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/05/02/Receiver/main.jpeg" alt=""><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><center>前言</center></h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>1.</strong>Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。<strong><em>广播可以跨进程甚至跨App直接通信。</em></strong><br><strong>2.</strong>你的APP可以接收广播(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。<br><strong>3.</strong>广播接收器没有用户界面。然而，它们可以<strong>启动一个Activity或Service服务</strong>来响应它们收到的信息，或者<strong>用NotificationManager 来通知用户</strong>。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：<br><strong>1.</strong>广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册；<br><strong>2.</strong>广播发送者通过Binder机制向AMS发送广播；<br><strong>3.</strong>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；<br><strong>4.</strong>消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-509a9631abac3f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity Manager、NotificationManager位于安卓架构图Framework层"></p>
<h1 id="广播定义及类型"><a href="#广播定义及类型" class="headerlink" title="广播定义及类型"></a><center>广播定义及类型</center></h1><h2 id="广播定义"><a href="#广播定义" class="headerlink" title="广播定义"></a>广播定义</h2><p>Android系统在运行的过程中，会产生很多系统广播，比如开机、电量改变、收发短信、拨打电话、屏幕解锁。当然我们也可以发送自定义普通或有序广播。</p>
<h2 id="广播类型"><a href="#广播类型" class="headerlink" title="广播类型"></a>广播类型</h2><p><strong>1.普通广播：</strong>通过Context.sendBroadcast(Intent intent)发送，可以在同一时刻（逻辑上）被所有广播接收者无需等待的接收到。<br><strong>优点：</strong>消息传递的效率比较高。<br><strong>缺点：</strong>1.接收者不能修改该广播。2.无法终止广播Intent的传播，即无法阻止其他接收者的接收动作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"One"</span>);</div><div class="line">intent.putExtra(<span class="string">"msg"</span>, <span class="string">"这是一条普通广播"</span>);</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure></p>
<p><strong>2.有序广播：</strong>通过Context.sendOrderedBroadcast(intent, receiverPermission)发送，是按照接收者声明的优先级别，被接收者依次接收广播。<br><strong>优点：</strong>1、广播可以通过接收者调用abortBroadcast()方法截断广播（被截断的广播不能再继续传递该广播）。2、接收者能修改处理结果（比如通过传递Bundle）传递给下一个接收者（一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播）。<br><strong>缺点：</strong>消息传递的效率比普通广播低。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent2 = <span class="keyword">new</span> Intent(<span class="string">"Two"</span>);</div><div class="line">intent2.putExtra(<span class="string">"msg"</span>, <span class="string">"这是一条有序广播"</span>);</div><div class="line">sendOrderedBroadcast(intent2, <span class="keyword">null</span>);</div></pre></td></tr></table></figure></p>
<p><strong>3.系统广播：</strong>只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开机启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，由系统自动发出。<strong><em>详见文章末尾附录</em></strong><br><strong>4.异步广播：</strong>通过mContext.sendStickyBroadcast(intent)发送，此广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。其他功能与sendBroadcast相同。但是使用sendStickyBroadcast 发送广播需要获得BROADCAST_STICKY permission，如果没有这个permission则会抛出异常。<br><strong>优点：</strong>广播先发送，接收者后注册依然能收到广播。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent3 = <span class="keyword">new</span> Intent(<span class="string">"Three"</span>);</div><div class="line">intent3.putExtra(<span class="string">"msg"</span>, <span class="string">"这是一条异步广播"</span>);</div><div class="line">sendStickyBroadcast(intent3);</div></pre></td></tr></table></figure></p>
<h1 id="广播接收者"><a href="#广播接收者" class="headerlink" title="广播接收者"></a><center>广播接收者</center></h1><h2 id="广播接收者定义"><a href="#广播接收者定义" class="headerlink" title="广播接收者定义"></a>广播接收者定义</h2><p>BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播，且可以做出相关操作。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p><strong>第一步：</strong>定义广播接收者，继承BroadcastReceiver，并重写onReceive()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver01</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;  </div><div class="line">		<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Contextcontext, Intentintent)</span> </span>&#123;  </div><div class="line">				<span class="comment">//abortBroadcast();//接到的广播为有序的广播则可截断</span></div><div class="line">				String s = intent.getStringExtra(<span class="string">"msg"</span>);</div><div class="line">	    System.out.println(<span class="string">"MyReceiver01收到消息："</span>+s);</div><div class="line">		&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>【关于接收的广播类型的说明】</strong></p>
<ul>
<li><strong>接收的广播为普通广播：</strong><br>1、不可以在onReceive里面截断广播，否则会打印异常。<br>2、不可以处理广播。</li>
<li><strong>接收的广播为有序广播：</strong><br>1、可以在onReceive里面通过abortBroadcast()截断广播，使广播不再传播。<br>2、可以在onReceive里面接收广播Intent携带的数据（String字符串、Bundle对象、或者实现Serializable接口、Parcelable接口的Object对象）。<br>3、可向低优先级接收者传递新的数据，如下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我是高优先级接收者</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Contextcontext, Intentintent)</span> </span>&#123;  </div><div class="line">				Bundle bundle = <span class="keyword">new</span> Bundle();  </div><div class="line">				bundle.putString(<span class="string">"next_receiver"</span>, <span class="string">"下一个广播接收者"</span>);  </div><div class="line">				setResultExtras(bundle);</div><div class="line">	&#125;  </div><div class="line"><span class="comment">//我是低优先级接收者</span></div><div class="line"><span class="meta">@Override</span>  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </div><div class="line">				Bundle bundle = getResultExtras(<span class="keyword">true</span>);  </div><div class="line">				String content = bundle.getString(<span class="string">"next_receiver"</span>); </div><div class="line">		&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>第二步：</strong>注册感兴趣的广播Intent，注册方法有两种：<br><strong>1、动态注册</strong>（在onCreate代码中进行注册）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(<span class="string">"感兴趣的广播名、例如上面发送的有序广播：Two"</span>);  </div><div class="line">MyReceiver01  receiver = <span class="keyword">new</span> MyReceiver01();  </div><div class="line">intentfilter.setPriority(<span class="number">200</span>);<span class="comment">//设置优先级</span></div><div class="line">registerReceiver(receiver, filter);</div></pre></td></tr></table></figure></p>
<p><strong>2、静态注册</strong>（在AndroidManifest.xml配置文件中注册）。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--prioritys设置优先级--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">". MyReceiver01"</span>&gt;</span>  </div><div class="line">	 <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"100"</span>&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"感兴趣的广播名、例如上面发送的有序广播：Two"</span>/&gt;</span>  </div><div class="line">	 <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>【关于优先级别的说明】</strong></p>
<ul>
<li><strong> 设置方法</strong>（如上面注册代码所示）：<br><strong>1.静态设置：</strong>声明在静态注册的广播接收者的intent-filter元素的android:priority属性中。<br><strong>2.动态设置：</strong>调用IntentFilter对象的setPriority()进行声明。</li>
<li><strong>特别说明</strong><br><strong>1.</strong>静态注册时设置优先级。数越大优先级别越高,取值范围:-1000到1000。就会先接受到消息。<br><strong>2.</strong>动态注册优先级高于任何静态注册。<br><strong>3.</strong>如果动态注册和静态注册都有注册，则会执行两次onReceive。<br><strong>4.</strong>同级别的接收顺序是随机的。<br><strong>【关于动、静态注册方式特别说明】</strong></li>
<li><strong>静态注册广播：</strong>又叫常驻型广播，当你的应用程序关闭了，如果有广播信息来，你写的广播接收器同样的能接受到，他的注册方式就是在你的应用程序中的AndroidManifast.xml进行订阅的。</li>
<li><p><strong>动态注册广播：</strong>又叫非常驻型广播，当应用程序结束了，广播自然就没有了，比如你在Activity中的onCreate或者onResume中订阅广播，同时你必须在onDestory或者onPause中取消广播订阅。不然会报异常，这样你的广播接收器就一个非常驻型的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		<span class="comment">//动态注册BC2 接收者</span></div><div class="line">		IntentFilter intentfilter = <span class="keyword">new</span> IntentFilter(<span class="string">"One"</span>);</div><div class="line">		BC2 bc2 = <span class="keyword">new</span> BC2();</div><div class="line">		registerReceiver(bc2, intentfilter);</div><div class="line">	&#125;<span class="comment">//必须在onDestory取消广播订阅</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		unregisterReceiver(bc2);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong><br>1、动态注册的时候使用的是隐式Intent方式，所以在发送广播的时候需要使用隐式Intent去发送，不然是广播接收者是接收不到广播。<br>2、静态注册的时候，因为在AndroidMainfest.xml中订阅的，所以在发送广播的时候使用显示Intent和隐式Intent都可以<br><strong><em>所以以防万一，我们一般都采用隐式Intent去发送广播。</em></strong><br>3、对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext；<br>4、对于动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context；</p>
<h2 id="生命周期。"><a href="#生命周期。" class="headerlink" title="生命周期。"></a>生命周期。</h2><p>它并不像 Activity 一样复杂，运行原理很简单如下图<br><img src="http://upload-images.jianshu.io/upload_images/4821697-9d502f10fa1521ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期"></p>
</li>
<li>广播接收者生命周期<strong>只有十秒</strong>左右，如果在 onReceive() 内做超过十秒内的事情，就会报<strong>ANR(Application No Response) 程序无响应的错误信息</strong>，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 <strong>Service</strong>， 由Service 来完成 。</li>
<li>这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的</li>
</ul>
<h1 id="广播实例"><a href="#广播实例" class="headerlink" title="广播实例"></a><center>广播实例</center></h1><p><em>为了帮助大家更好的理解，以下写了一个接收系统系统电量广播并处理的小例子。</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一步，定义广播接收者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatteryChangedReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BatteryChangedReceiver"</span>;  </div><div class="line">	<span class="meta">@Override</span>  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </div><div class="line">			<span class="keyword">int</span> currLevel =   intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class="number">0</span>);  <span class="comment">//当前电量  </span></div><div class="line">			<span class="keyword">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE,   <span class="number">1</span>);      <span class="comment">//总电量  </span></div><div class="line">			<span class="keyword">int</span> percent = currLevel * <span class="number">100</span> / total;  </div><div class="line">			Log.i(TAG, <span class="string">"battery: "</span> + percent + <span class="string">"%"</span>);  </div><div class="line">	 &#125;  </div><div class="line">&#125;</div><div class="line"><span class="comment">//第二步，注册广播接收者</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		<span class="comment">//动态注册电量广播接收者</span></div><div class="line">		IntentFilter intentfilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED;);</div><div class="line">		BatteryChangedReceiver batteryChangedReceiver = <span class="keyword">new</span> BatteryChangedReceiver();</div><div class="line">		registerReceiver(bc2, intentfilter);</div><div class="line">	&#125;<span class="comment">//必须在onDestory取消广播订阅</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		unregisterReceiver(batteryChangedReceiver);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a><center>【附录】</center></h1><ul>
<li>常见系统广播</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line">//关闭或打开飞行模式时的广播</div><div class="line">Intent.ACTION_AIRPLANE_M;</div><div class="line"></div><div class="line">//充电状态，或者电池的电量发生变化;//电池的充电状态、电荷级别改变，不能通过组建声;</div><div class="line">Intent.ACTION_BATTERY_CH;</div><div class="line"></div><div class="line">//表示电池电量低</div><div class="line">Intent.ACTION_BATTERY_LO;</div><div class="line"></div><div class="line">//表示电池电量充足</div><div class="line">Intent.ACTION_BATTERY_OK;</div><div class="line"></div><div class="line">//关闭或打开飞行模式时的广播</div><div class="line">Intent.ACTION_AIRPLANE_MODE_CHANGED;</div><div class="line"></div><div class="line">//充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册</div><div class="line">Intent.ACTION_BATTERY_CHANGED;</div><div class="line"></div><div class="line">//表示电池电量低</div><div class="line">Intent.ACTION_BATTERY_LOW;</div><div class="line"></div><div class="line">//表示电池电量充足，即从电池电量低变化到饱满时会发出广播</div><div class="line">Intent.ACTION_BATTERY_OKAY;</div><div class="line"></div><div class="line">//在系统启动完成后，这个动作被广播一次（只有一次）。</div><div class="line">Intent.ACTION_BOOT_COMPLETED;</div><div class="line"></div><div class="line">//按下照相时的拍照按键(硬件按键)时发出的广播</div><div class="line">Intent.ACTION_CAMERA_BUTTON;</div><div class="line"></div><div class="line">//当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息</div><div class="line">Intent.ACTION_CLOSE_SYSTEM_DIALOGS;</div><div class="line"></div><div class="line">//设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java)</div><div class="line">Intent.ACTION_CONFIGURATION_CHANGED;</div><div class="line"></div><div class="line">//设备日期发生改变时会发出此广播</div><div class="line">Intent.ACTION_DATE_CHANGED;</div><div class="line"></div><div class="line">//设备内存不足时发出的广播,此广播只能由系统使用，其它APP不可用</div><div class="line">Intent.ACTION_DEVICE_STORAGE_LOW;</div><div class="line"></div><div class="line">//设备内存从不足到充足时发出的广播,此广播只能由系统使用，其它APP不可用</div><div class="line">Intent.ACTION_DEVICE_STORAGE_OK;</div><div class="line"></div><div class="line">//发出此广播的地方frameworks\base\services\java\com\android\server\DockObserver.java</div><div class="line">Intent.ACTION_DOCK_EVENT;</div><div class="line"></div><div class="line">//移动APP完成之后，发出的广播(移动是指:APP2SD)</div><div class="line">Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE;</div><div class="line"></div><div class="line">//正在移动APP时，发出的广播(移动是指:APP2SD)</div><div class="line">Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;</div><div class="line"></div><div class="line">//Gtalk已建立连接时发出的广播</div><div class="line">Intent.ACTION_GTALK_SERVICE_CONNECTED;</div><div class="line"></div><div class="line">//Gtalk已断开连接时发出的广播</div><div class="line">Intent.ACTION_GTALK_SERVICE_DISCONNECTED;</div><div class="line"></div><div class="line">//在耳机口上插入耳机时发出的广播</div><div class="line">Intent.ACTION_HEADSET_PLUG;</div><div class="line"></div><div class="line">//改变输入法时发出的广播</div><div class="line">Intent.ACTION_INPUT_METHOD_CHANGED;</div><div class="line"></div><div class="line">//设备当前区域设置已更改时发出的广播</div><div class="line">Intent.ACTION_LOCALE_CHANGED;</div><div class="line"></div><div class="line">//表示用户和包管理所承认的低内存状态通知应该开始。</div><div class="line">Intent.ACTION_MANAGE_PACKAGE_STORAGE;</div><div class="line"></div><div class="line">//未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播 ,扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)</div><div class="line">Intent.ACTION_MEDIA_BAD_REMOVAL;</div><div class="line"></div><div class="line">//按下"Media Button" 按键时发出的广播,假如有"Media Button" 按键的话(硬件按键)</div><div class="line">Intent.ACTION_MEDIA_BUTTON;</div><div class="line"></div><div class="line">//插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播?</div><div class="line">Intent.ACTION_MEDIA_CHECKING;</div><div class="line"></div><div class="line">//已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播, 用户想要移除扩展介质（拔掉扩展卡）。</div><div class="line">Intent.ACTION_MEDIA_EJECT;</div><div class="line"></div><div class="line">//插入SD卡并且已正确安装（识别）时发出的广播, 扩展介质被插入，而且已经被挂载。</div><div class="line">Intent.ACTION_MEDIA_MOUNTED;</div><div class="line"></div><div class="line">//拓展介质存在，但使用不兼容FS（或为空）的路径安装点检查介质包含在Intent.mData领域。</div><div class="line">Intent.ACTION_MEDIA_NOFS;</div><div class="line"></div><div class="line">//外部储存设备已被移除，不管有没正确卸载,都会发出此广播， 扩展介质被移除。</div><div class="line">Intent.ACTION_MEDIA_REMOVED;</div><div class="line"></div><div class="line">//广播：已经扫描完介质的一个目录</div><div class="line">Intent.ACTION_MEDIA_SCANNER_FINISHED;</div><div class="line"></div><div class="line">//请求媒体扫描仪扫描文件并将其添加到媒体数据库。</div><div class="line">Intent.ACTION_MEDIA_SCANNER_SCAN_FILE;</div><div class="line"></div><div class="line">//广播：开始扫描介质的一个目录</div><div class="line">Intent.ACTION_MEDIA_SCANNER_STARTED;</div><div class="line"></div><div class="line">// 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。</div><div class="line">Intent.ACTION_MEDIA_SHARED;</div><div class="line"></div><div class="line">Intent.ACTION_MEDIA_UNMOUNTABLE;//</div><div class="line"></div><div class="line">// 广播：扩展介质存在，但是还没有被挂载 (mount)</div><div class="line">Intent.ACTION_MEDIA_UNMOUNTED</div><div class="line"></div><div class="line">Intent.ACTION_NEW_OUTGOING_CALL;</div><div class="line"></div><div class="line">//成功的安装APK之后//广播：设备上新安装了一个应用程序包。//一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_ADDED;</div><div class="line"></div><div class="line">//一个已存在的应用程序包已经改变，包括包名</div><div class="line">Intent.ACTION_PACKAGE_CHANGED;</div><div class="line"></div><div class="line">//清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?)//用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_DATA_CLEARED;</div><div class="line"></div><div class="line">//触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？</div><div class="line">Intent.ACTION_PACKAGE_INSTALL;</div><div class="line"></div><div class="line">//成功的删除某个APK之后发出的广播, 一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_REMOVED;</div><div class="line"></div><div class="line">//替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？）</div><div class="line">Intent.ACTION_PACKAGE_REPLACED;</div><div class="line"></div><div class="line">//用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_RESTARTED;</div><div class="line"></div><div class="line">//插上外部电源时发出的广播</div><div class="line">Intent.ACTION_POWER_CONNECTED;</div><div class="line"></div><div class="line">//已断开外部电源连接时发出的广播</div><div class="line">Intent.ACTION_POWER_DISCONNECTED;</div><div class="line"></div><div class="line">Intent.ACTION_PROVIDER_CHANGED;//</div><div class="line"></div><div class="line">//重启设备时的广播</div><div class="line">Intent.ACTION_REBOOT;</div><div class="line"></div><div class="line">//屏幕被关闭之后的广播</div><div class="line">Intent.ACTION_SCREEN_OFF;</div><div class="line"></div><div class="line">//屏幕被打开之后的广播</div><div class="line">Intent.ACTION_SCREEN_ON;</div><div class="line"></div><div class="line">//关闭系统时发出的广播</div><div class="line">Intent.ACTION_SHUTDOWN;</div><div class="line"></div><div class="line">//时区发生改变时发出的广播</div><div class="line">Intent.ACTION_TIMEZONE_CHANGED;</div><div class="line"></div><div class="line">//时间被设置时发出的广播</div><div class="line">Intent.ACTION_TIME_CHANGED;</div><div class="line"></div><div class="line">//广播：当前时间已经变化（正常的时间流逝）， 当前时间改变，每分钟都发送，不能通过组件声明来接收</div><div class="line">，只有通过Context.registerReceiver()方法来注册</div><div class="line">Intent.ACTION_TIME_TICK;</div><div class="line"></div><div class="line">//一个用户ID已经从系统中移除发出的广播</div><div class="line">Intent.ACTION_UID_REMOVED;</div><div class="line"></div><div class="line">//设备已进入USB大容量储存状态时发出的广播？</div><div class="line">Intent.ACTION_UMS_CONNECTED;</div><div class="line"></div><div class="line">//设备已从USB大容量储存状态转为正常状态时发出的广播？</div><div class="line">Intent.ACTION_UMS_DISCONNECTED;</div><div class="line"></div><div class="line">Intent.ACTION_USER_PRESENT;//</div><div class="line"></div><div class="line">//设备墙纸已改变时发出的广播</div><div class="line">Intent.ACTION_WALLPAPER_CHANGED;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/05/02/Receiver/main.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 四大组件之Activity</title>
    <link href="https://jaykuzzi.github.io/2016/04/24/Activity/"/>
    <id>https://jaykuzzi.github.io/2016/04/24/Activity/</id>
    <published>2016-04-24T07:35:36.000Z</published>
    <updated>2017-06-27T12:10:50.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/04/24/Activity/activity.jpeg" alt=""><br><a id="more"></a></p>
<h1 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a><center>基础知识回顾</center></h1><h2 id="定义及功能"><a href="#定义及功能" class="headerlink" title="定义及功能"></a>定义及功能</h2><p>  一个Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务，例如拨号、拍照、发送email、看地图。每一个activity被给予一个窗口，在上面可以绘制用户接口。窗口通常充满屏幕，但也可以小于屏幕而浮于其它窗口之上。</p>
<h2 id="启动和栈"><a href="#启动和栈" class="headerlink" title="启动和栈"></a>启动和栈</h2><p>  一个应用程序通常由多个activities组成，他们通常是松耦合关系。通常，一个应用程序中的activity被指定为”main”activity，当第一次启动应用程序的时候呈现给用户的那个activity。每一个activity然后可以启动另一个activity为了完成不同的动作。每一次一个activity启动，前一个activity就停止了，但是系统保留activity在一个栈上（“back stack”）。当一个新activity启动，它被推送到栈顶，取得用户焦点。Back Stack符合简单“后进先出”原则，所以，当用户完成当前activity然后点击back按钮，它被弹出栈（并且被摧毁），然后之前的activity恢复。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>  基本用法：Activity的本质是一个Java类，如：由我们创建工程生成的MainActivity；一般的每个Activity都会存在一个与它匹配的布局文件（xml文件），由它来写入我们需要Activity展示的各种控件和布局。有了布局文件之后，就需要在类里通过OnCreate方法的setContentView方法调用文件资源ID来初始化UI界面和显示。</p>
<h2 id="创建和注册"><a href="#创建和注册" class="headerlink" title="创建和注册"></a>创建和注册</h2><p>  每个需要显示的Activity都需要我们在工程包下的AndroidMainifest.xml文件进行注册！（注意：程序每次打开时显示的Activity我们称为主界面，它的注册和其他Activity注册有区别）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--主Activity--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">activity</span>  </span></div><div class="line"><span class="attr">Android:name</span>=<span class="string">”.MainActivity”</span>&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">”android.intent.action.MAIN”/</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">”android.intent.category.LAUNCHER”/</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>主界面显示的Activity加入了<intent-filter>标签和内部的两句声明，这也是必须的。</intent-filter></p>
<p><action>元素指定这是一个”main”入口点对这个应用程序。<category>元素指定，这个activity应该被列入系统应用程序列表中（为了允许用户启动这个activity）。<br>此外如果你的应用程序里没有声明任何主活动，它也是可以安装的，只是你无法在启动器中看见或打开，这种程序一般作为第三方服务供其他应用在内部进行调用，如支付宝的快捷支付应用。</category></action></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><center>生命周期</center></h1><h2 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h2><blockquote>
<p><strong>运行状态：</strong>当Activity位于栈顶时，此时正好处于屏幕最前方。<br><strong>暂停状态：</strong>当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕）。<br><strong>停止状态：</strong>当Activity被其他Activity完全遮挡，此时此Activity对用户不可见。<br><strong>销毁状态：</strong>当Activity由于人为或系统原因（如低内存等）被销毁。</p>
<h2 id="七个回调方法"><a href="#七个回调方法" class="headerlink" title="七个回调方法"></a>七个回调方法</h2><p><strong>1.onCreate：</strong>活动第一次创建被调用。<br><strong>2.onStart：</strong>活动由不可见变为可见的时候调用。<br><strong>3.onResume：</strong>活动处于与用户交互状态时候调用。<br><strong>4.onPause：</strong>活动失去焦点时被调用。<br><strong>5.onStop：</strong>活动完全不可见的时候调用（如果新活动是一个对话框式活着半透明的活动，onPause会执行，而onStop不会执行）。<br><strong>6.onDestroy：</strong>在活动被销毁之前调用。<br><strong>7.onRestart：</strong>由停止状态变为运行状态之前调用。</p>
<h2 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h2><p>  <img src="http://upload-images.jianshu.io/upload_images/4821697-b23eea06a1d111e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图"></p>
</blockquote>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>  <em>在实际应用场景中，假设A Activity位于栈顶，此时用户操作，从A Activity跳转到B Activity。那么对AB来说，具体会回调哪些生命周期中的方法呢？回调方法的具体回调顺序又是怎么样的呢？</em><br>  开始时，A被实例化，执行的回调有<strong>A:onCreate -&gt; A:onStart -&gt; A:onResume。</strong><br>  当用户点击A中按钮来到B时，假设B全部遮挡住了A，将依次执行<strong>A:onPause -&gt; B:onCreate -&gt; B:onStart -&gt; B:onResume -&gt; A:onStop。</strong><br>  此时如果点击Back键，将依次执行<strong>B:onPause -&gt; A:onRestart -&gt; A:onStart -&gt; A:onResume -&gt; B:onStop -&gt; B:onDestroy。</strong><br>  <em>至此，Activity栈中只有A。在Android中，有两个按键在影响Activity生命周期这块需要格外区分下，即Back键和Home键。我们先直接看下实验结果：</em><br>  此时如果按下Back键，系统返回到桌面，并依次执行<strong>A:onPause -&gt; A:onStop -&gt; A:onDestroy。</strong><br>  此时如果按下Home键（非长按），系统返回到桌面，并依次执行<strong>A:onPause -&gt; A:onStop。</strong>由此可见，Back键和Home键主要区别在于是否会执行onDestroy。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>  不少应用程序都是采取如Home键的效果，当点击了Back键，系统返回到桌面，然后点击应用程序图标，直接回到之前的Activity界面，这种效果是怎么实现的呢？<br>  通过重写按下Back键的回调函数，转成Home键的效果即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</div><div class="line">		Intent home = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</div><div class="line">		home.addCategory(Intent.CATEGORY_HOME);</div><div class="line">		startActivity(home);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，此种方式通过Home键效果强行影响到Back键对Activity生命周期的影响。注意，此方法只是针对按Back键需要退回到桌面时的Activity且达到Home效果才重写。<br>或者，为达到此类效果，Activity实际上提供了直接的方法。<br><code>activity.moveTaskToBack(true);</code><br>moveTaskToBack()此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态。</p>
<h1 id="Activity跳转"><a href="#Activity跳转" class="headerlink" title="Activity跳转"></a><center>Activity跳转</center></h1><h2 id="startActivity-。"><a href="#startActivity-。" class="headerlink" title="startActivity()。"></a>startActivity()。</h2><p>  Intent的两种用法：显示Intent和隐式Intent。<br>  （1）显示Intent一般使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent=newIntent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);  </div><div class="line">startActivity(intent);  </div><div class="line"><span class="comment">//简单的两行就能实现第一个活动跳转到第二个活动界面。</span></div></pre></td></tr></table></figure></p>
<p>（2）隐式Intent一般使用方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--首先需要在注册第二个活动时加入标签--&gt;</span></div><div class="line"><span class="comment">&lt;!-- 必须指定CATEGORY_DEFAULT，只有这样startActivity(intent)才能找到 --&gt;</span>  </div><div class="line"><span class="comment">&lt;!--注意 Intent Filter顾名思义就是Intent的过滤器，组件通过定义Intent Filter可以决定哪些隐式 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">”.SecondAcivity”</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">”包名.ACTION_START”/</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">”android.intent.category.DEFAULT”/</span>&gt;</span>   </div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样我们就可以用声明的标签来启动隐式Intent<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent=<span class="keyword">new</span> Intent(“包名.ACTION_START”);  </div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>（3）两者的使用区别<br> <strong>显式意图</strong>一般在应用的<strong>内部使用</strong>，因为在应用内部已经知道了组件的名称，直接调用就可以了。当一个应用要激活另一个应用中的Activity时，只能使用隐式意图，根据Activity配置的意图过滤器建一个意图，让意图中的各项参数的值都跟过滤器匹配，这样就可以激活其他应用中的Activity。所以，<strong>隐式意图是在应用与应用之间使用的。</strong></p>
<h2 id="系统意图"><a href="#系统意图" class="headerlink" title="系统意图"></a>系统意图</h2><p>  Intent可以指定你希望启动或描述完成的动作（操作系统会为你选择合适的Activity，可能来自定不同的应用程序）。<br>  你的应用程序或许希望执行一些动作，例如发送一份邮件、文件消息或者状态更新，使用你的Activity的数据。在这种情况下，你的应用程序或许没有它自己的Activity来完成这个动作，因此你可以促使设备上其它应用程序提供的Activity来完成你的动作。这才是Intent真正有价值的地方－－你可以创建一个Intent描述一个你希望执行的动作，然后系统启动一个合适的activity从其它应用程序。如果有多种Activities可以处理这个Intent，那么 用户可以选择哪一个来执行。例如，如果你希望允许用户发送邮件，你可以创建下面的Intent:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent= <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</div><div class="line">				intent.putExtra(Intent.EXTRA_EMAIL,<span class="string">""</span>);</div><div class="line">				startActivity(intent);</div></pre></td></tr></table></figure></p>
<p><em>（常用意图见文章末尾附录。）</em></p>
<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><p>  一个Intent可以传输小量数据被启动的activity使用。<br>  在启动活动时，Intent中提供了一系列putExtra()方法的重载，可以将我们需要传递的数据暂存在Intent中，在打开另一个活动时，从Intent中取出即可。<br>  具体例子：<br>  （1）比如我们想要传递一个String字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String data=”Hello world!”;  </div><div class="line">Intent intent=newIntent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);  </div><div class="line">Intent.putExtra(“extra_data”,data);</div><div class="line"><span class="comment">//extra_data是一个标签，data是传入的数据。 </span></div><div class="line"><span class="comment">//相当于Intent对象具有Map键值对功能。</span></div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>然后在SecondActivity的Oncreate方法里取出Intent存入的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent=getIntent();  </div><div class="line">String data=intent.getStringExtra(“extra_data”);</div><div class="line"><span class="comment">//用String接收带extra_data标签的数据  </span></div><div class="line">Log.d(“SecondActivity”,data);<span class="comment">//打印出data</span></div></pre></td></tr></table></figure></p>
<p>（2）新建一个Bundle对象 ，想该对象中加入键值对，然后将该对象加入Intent中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Intent intent=<span class="keyword">new</span> Intent();</div><div class="line">Bundle bundle = <span class="keyword">new</span> Bundle();  </div><div class="line">bundle.putString(<span class="string">"first"</span>, <span class="string">"zhang"</span>);  </div><div class="line">bundle.putInt(<span class="string">"age"</span>, <span class="number">20</span>);  </div><div class="line">intent.putExtras(bundle);  </div><div class="line">intent.setClass(ActivityMain.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">intent.putExtras(bundle);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>然后在第二个Activity中接收<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line"> bundle = <span class="keyword">this</span>.getIntent().getExtras();</div><div class="line">String a = bundle.getString(<span class="string">"first"</span>);</div><div class="line"><span class="keyword">int</span> b = Integer.parseInt(bundle.getString(<span class="string">"age"</span>));</div></pre></td></tr></table></figure></p>
<p>（3）Intent传递Object对象</p>
<p> Android中Intent传递类对象提供了两种方式一种是 通过实现<strong>Serializable接口</strong>传递对象，一种是通过实现<strong>Parcelable接口</strong>传递对象。要求被传递的对象必须实现上述2种接口中的一种才能通过Intent直接传递。Intent中传递这2种对象的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bundle.putSerializable(Key,Object);  <span class="comment">//实现Serializable接口的对象</span></div><div class="line">Bundle.putParcelable(Key, Object); <span class="comment">//实现Parcelable接口的对象</span></div></pre></td></tr></table></figure></p>
<p>以下以最常用的Serializable方式为例 ：</p>
<pre><code>假设由登录界面（Login）跳转到主界面（MainActivity）传递的对象为登录的用户信息 User类

首先创建一个序列化类：User
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">		<span class="keyword">import</span> java.io.Serializable;</div><div class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> ID;</div><div class="line">		<span class="keyword">private</span> String UserName;    </div><div class="line">		<span class="keyword">private</span> String PWD;    </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> value)</span></span></div><div class="line">		&#123;</div><div class="line">				ID = value;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">				<span class="keyword">return</span> ID;</div><div class="line">		&#125;    </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String value)</span></span></div><div class="line">		&#123;</div><div class="line">				UserName = value;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getUserName</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">				<span class="keyword">return</span> UserName;</div><div class="line">		&#125;  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPWD</span><span class="params">(String value)</span></span></div><div class="line">		&#123;</div><div class="line">				PWD = value;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getPWD</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">				<span class="keyword">return</span> PWD;</div><div class="line">		&#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MainActivity传递内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">intent.setClass(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">bundle.putSerializable(<span class="string">"user"</span>, user);</div><div class="line">intent.putExtras(bundle);</div><div class="line"><span class="keyword">this</span>.startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>SecondActivity接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">this</span>.getIntent(); </div><div class="line">user=(User)intent.getSerializableExtra(<span class="string">"user"</span>);</div></pre></td></tr></table></figure></p>
<p>以上就可以实现对象的传递。<br>补充：<br>如果传递的是List<object>,可以把list强转成Serializable类型,而且object类型也必须实现了Serializable接口<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Intent.putExtras(key, (Serializable)list)</div></pre></td></tr></table></figure></object></p>
<p>接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(List&lt;YourObject&gt;)getIntent().getSerializable(key)</div></pre></td></tr></table></figure></p>
<pre><code>【补充】
parcelable和Serializable的区别又是什么呢？
</code></pre><p><strong>Serializable</strong>的作用是保存对象的属性到本地文件，数据库，网络流等方便数据传输，也可程序之间传递。</p>
<pre><code>**parcelable**的设计的目的是为了解决Serializable效率不高的问题，内存开销小，所以在内存间传递数据的方式用parcelable，缺点是不能持久化。
</code></pre><h2 id="startActivityForResult"><a href="#startActivityForResult" class="headerlink" title="startActivityForResult()"></a>startActivityForResult()</h2><p>  Activity退出时返回结果至前一个Activity<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  1.通过startActivityForResult方式启动一个新Activity </span></div><div class="line">Intent intent=newIntent(FirstActivity,<span class="keyword">this</span>,SecondActivity.class);   </div><div class="line">startActivityForResult(intent, <span class="number">200</span>);  </div><div class="line"><span class="comment">//参数为intent对象， requestCode请求码</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  2.新Activity设定setResult方法，通过该方法可以传递responseCode 和 Intent对象  </span></div><div class="line">Intent intent=<span class="keyword">new</span> Intent();  </div><div class="line"><span class="comment">//Intent中也可以传递Bundle</span></div><div class="line">Intent.putExtra(“data_return”,”Helloworld!”);  </div><div class="line">setResult(<span class="number">101</span>,intent);  </div><div class="line"> <span class="comment">//参数为responseCode响应码 和 intent对象  </span></div><div class="line">finish();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  3.在MainActivity中覆写onActivityResult方法，新Activity一旦退出，就会执行该方法  </span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123; </div><div class="line"><span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line">				<span class="comment">//如果请求标识与返回标识一样,则把数据返回到tv上</span></div><div class="line">				<span class="keyword">if</span> (requestCode == <span class="number">200</span> &amp; resultCode ==<span class="number">101</span>) &#123;</div><div class="line">						String s = data.getStringExtra(<span class="string">"data_return"</span>);</div><div class="line">						tv.setText(s);</div><div class="line">				&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a><center>启动模式</center></h1><h2 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h2><blockquote>
<p><strong>standard（标准模式）：</strong>每当启动一个新活动，它都会进入返回栈并位于栈顶的位置，这种模式下，系统不会在乎这个活动是否已经存在于返回栈中，每次启动都会创建并都放在栈顶。</p>
<p><strong>singleTop（栈顶复用）：</strong>在启动活动时如果发现栈中该活动已经位于栈顶，则重用该实例( 会调用实例的onNewIntent() )而不会创建新的实例。若不在栈顶，则会创建新的实例。</p>
<p><strong>singleTask（栈内复用）：</strong>启动活动时如果发现栈中已经存在该活动，则重用该实例(会调用实例的 onNewIntent() )，并且将位于它之上的活动统统出栈，如果没有发现就会新建一个实例。</p>
<p><strong>singleIntance（单例模式）：</strong>会有一个单独的返回栈来管理这个活动，而且栈中只有此活动，不管是任何一个程序来访问这个活动，都共用这个返回栈，也就解决了共享活动的问题。</p>
<p>设置方法：在AndroidMainifest.xml文件中activity标签name之下加入声明：Android:launchMode=” standard、singleTop、singleTask、singleInstance(四选一)”这样就可以配置活动的启动模式了。</p>
</blockquote>
<h2 id="详解standard"><a href="#详解standard" class="headerlink" title="详解standard"></a>详解standard</h2><p>  standard模式是默认的启动模式，不用为<activity>配置android:launchMode属性即可，当然也可以指定值为standard。<br>  我们将会一个Activity，命名为FirstActivity，来演示一下标准的启动模式。FirstActivity代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">				setContentView(R.layout.first);  </div><div class="line">				TextView textView = (TextView) findViewById(R.id.textView);  </div><div class="line">				textView.setText(<span class="keyword">this</span>.toString());  </div><div class="line">				Button button = (Button) findViewById(R.id.button);  </div><div class="line">				button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;  </div><div class="line">						<span class="meta">@Override</span>  </div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">								Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, FirstActivity.class);  </div><div class="line">								startActivity(intent);  </div><div class="line">						&#125;  </div><div class="line">				&#125;);  </div><div class="line">		&#125;</div></pre></td></tr></table></figure></activity></p>
<p>我们FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。<br>然后我们连续点击几次按钮，将会出现下面的现象<br><img src="http://upload-images.jianshu.io/upload_images/4821697-6b6f54199b70cbb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FristActivity。standard模式的原理如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/4821697-c316d617cee70767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转">如图所示，<strong>每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。</strong><br>这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。</p>
<h2 id="详解singleTop"><a href="#详解singleTop" class="headerlink" title="详解singleTop"></a>详解singleTop</h2><p>  我们在上面的基础上为<activity>指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-80b9ffa6240c3466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。singleTop模式的原理如下图所示：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-1ca377d77e50f2a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。<br>  我们再新建一个Activity命名为SecondActivity，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">			<span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">			setContentView(R.layout.second);  </div><div class="line">			TextView textView = (TextView) findViewById(R.id.textView);  </div><div class="line">			textView.setText(<span class="keyword">this</span>.toString());  </div><div class="line">			Button button = (Button) findViewById(R.id.button);  </div><div class="line">			button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;  </div><div class="line">					<span class="meta">@Override</span>  </div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">							Intent intent = <span class="keyword">new</span> Intent(SecondActivity.<span class="keyword">this</span>, FirstActivity.class);  </div><div class="line">							startActivity(intent);                </div><div class="line">					&#125;  </div><div class="line">			&#125;);  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></activity></p>
<p>然后将之前的FirstActivity跳转代码改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);  </div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>是的，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。演示结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-eb8b909de24ed314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。原理图如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4502b2941605c4bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们看到，<strong>当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。<br>这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。</strong></p>
<h2 id="详解singleTask"><a href="#详解singleTask" class="headerlink" title="详解singleTask"></a>详解singleTask</h2><p>  在上面的基础上我们修改FirstActivity的属性android:launchMode=”singleTask”。演示的结果如下：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-321feaa2137b2fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。singleTask模式的原理图如下图所示：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-44226b927c4e424c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，<strong>SecondActivity消失了</strong>，没错，在这个跳转过程中系统发现有存在的FirstActivity实例，<strong>于是不再生成新的实例，而是将FirstActivity之上的Activity实例统统出栈，将FirstActivity变为栈顶对象，显示到幕前。</strong>也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。<br>  这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。</p>
<h2 id="详解singleInstance"><a href="#详解singleInstance" class="headerlink" title="详解singleInstance"></a>详解singleInstance</h2><p>  这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。<br>  我们修改FirstActivity的launchMode=”standard”，SecondActivity的launchMode=”singleInstance”，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView taskIdView = (TextView) findViewById(R.id.taskIdView);  </div><div class="line">taskIdView.setText(<span class="string">"current task id: "</span> + <span class="keyword">this</span>.getTaskId());</div></pre></td></tr></table></figure></p>
<p>然后我们再演示一下这个流程：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4e37e0d6bc2e4353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-65354e8b4fb44d9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。<br>如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-8322215770724b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ShareActivity"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleInstance"</span>&gt;</span>  </div><div class="line">		<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span>  </div><div class="line">		<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line">		<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span> /&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span>  </div><div class="line">		<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后我们在其他应用中这样启动该Activity：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span>);  </div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。大家可以在ShareActivity中打印一下taskId，看看效果。关于这个过程，原理图如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-11e34c535c48204d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"></p>
<h2 id="启动模式应用场景"><a href="#启动模式应用场景" class="headerlink" title="启动模式应用场景"></a>启动模式应用场景</h2><blockquote>
<p><strong>singleTop</strong>适合<strong>接收通知启动的内容显示页面</strong>。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。所以要从外界尽可能多的跳转到一个界面。</p>
<p><strong>singleTask</strong>适合作为程序入口点。例如<strong>浏览器的主界面、联系人activity</strong>。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>
<p><strong>singleInstance</strong>适合需要与程序分离开的页面。这种模式的使用情况比较罕见，例如<strong>闹铃提醒</strong>，将闹铃提醒与闹铃设置分离。<strong>呼叫来电界面。</strong><br><em>singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，再次启动，首先打开的是B。</em></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  LauncherMode 分为两组：<br>  <strong>第一组standard和SingleTop是一组用的比较多，他们二个唯一的区别就是SingleTop如果在当前Task的顶部，同时在startActivity()这个Activity的时候就不会再创建新的实例，而是执行该实例的onNewIntent()方法，其他情况下的用法是一样的；</strong><br>  <strong>第二组SingleTask和SingleIntance这一组用的比较少，要结合特定情况来使用，这一组的使用区别是比较大的，在我们开发APP的过程中要合理的使用Activity的启动模式来使我们的APP更加的快捷，流畅，提高用户体验。如果有写的不好的还忘指点。</strong></p>
<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a><center>其他补充</center></h1><h2 id="Activity中finish-onDestroy-和System-exit-的区别"><a href="#Activity中finish-onDestroy-和System-exit-的区别" class="headerlink" title="Activity中finish() onDestroy() 和System.exit()的区别"></a>Activity中finish() onDestroy() 和System.exit()的区别</h2><blockquote>
<p><strong>Activity.finish()</strong><br>Call this when your activity is done and should be closed.<br>在你的activity动作完成的时候，或者Activity需要关闭的时候，调用此方法。当你调用此方法的时候，<em>系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory()方法</em>，<strong>其占用的资源也没有被及时释放。</strong>因为移出了栈，所以当你点击手机上面的“back”按键的时候，也不会再找到这个Activity。</p>
<p><strong>Activity.onDestory()</strong><br>the system is temporarily destroying this instance of the activity to save space.<br>系统销毁了这个Activity的实例在内存中占据的空间。<br>在Activity的生命周期中，onDestory()方法是他生命的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法。</p>
<p><strong>System.exit(0)</strong><br>这玩意是退出整个应用程序的，是针对整个Application的。将整个进程直接KO掉。</p>
<p><strong>finish函数仅仅把当前Activity退出了，但是并没有释放他的资源。安卓系统自己决定何时从内存中释放应用程序。当系统没有可用内存到时候，会按照优先级，释放部分应用。</strong></p>
</blockquote>
<h2 id="AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别"><a href="#AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别" class="headerlink" title="AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别"></a>AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别</h2><blockquote>
<p>support v4 FragmentActivity  兼容2.x模式下使用Fragment<br>support v7 AppCompatActivity 兼容2.x模式下使用Fragment和ActionBar，ActionBarActivity是AppCompatActivity过时产品<br>如果3.0以上直接继承Activity，便可使用Fragment和ActionBar</p>
</blockquote>
<h2 id="资源内存不足导致低优先级Activity被杀死"><a href="#资源内存不足导致低优先级Activity被杀死" class="headerlink" title="资源内存不足导致低优先级Activity被杀死"></a>资源内存不足导致低优先级Activity被杀死</h2><blockquote>
<p>Activity优先级<br>前台Activity——正在和用户交互的Activity，优先级最高<br>可见但非前台Activity——Activity中弹出的对话框导致Activity可见但无法交互<br>后台Activity——已经被暂停的Activity，优先级最低<br>系统内存不足是，会按照以上顺序杀死Activity，并通过onSaveInstanceState和onRestoreInstanceState这两个方法来存储和恢复数据。</p>
</blockquote>
<h2 id="ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。"><a href="#ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。" class="headerlink" title="ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。"></a>ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE) ;    </div><div class="line">//获得系统运行的进程  </div><div class="line">List&lt;ActivityManager.RunningAppProcessInfo&gt; appList1 = mActivityManager  </div><div class="line">				.getRunningAppProcesses();  </div><div class="line">for (RunningAppProcessInfo running : appList1) &#123;  </div><div class="line">		System.out.println(running.processName);  </div><div class="line">&#125;  </div><div class="line">System.out.println(&quot;================&quot;);  </div><div class="line">//获得当前正在运行的service  </div><div class="line">List&lt;ActivityManager.RunningServiceInfo&gt; appList2 = mActivityManager  </div><div class="line">				.getRunningServices(100);  </div><div class="line">for (ActivityManager.RunningServiceInfo running : appList2) &#123;  </div><div class="line">		System.out.println(running.service.getClassName());  </div><div class="line">&#125;  </div><div class="line">System.out.println(&quot;================&quot;);  </div><div class="line">//获得当前正在运行的activity  </div><div class="line">List&lt;ActivityManager.RunningTaskInfo&gt; appList3 = mActivityManager  </div><div class="line">				.getRunningTasks(1000);  </div><div class="line">for (ActivityManager.RunningTaskInfo running : appList3) &#123;  </div><div class="line">		System.out.println(running.baseActivity.getClassName());  </div><div class="line">&#125;  </div><div class="line">System.out.println(&quot;================&quot;);  </div><div class="line">//获得最近运行的应用  </div><div class="line">List&lt;ActivityManager.RecentTaskInfo&gt; appList4 = mActivityManager  </div><div class="line">				.getRecentTasks(100, 1);  </div><div class="line">for (ActivityManager.RecentTaskInfo running : appList4) &#123;  </div><div class="line">		System.out.println(running.origActivity.getClassName());  </div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a><center>【附录】</center></h1><ul>
<li>常用Intent意图表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//(1).调用拨号程序</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"tel:10086"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(2).发送短信或者彩信</span></div><div class="line"><span class="comment">//发生短信</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"smsto:10086"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, uri); </div><div class="line">intent.putExtra(<span class="string">"sms_body"</span>, <span class="string">"Hello"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//发送彩信，相当于发送带附件的短信</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND); </div><div class="line">intent.putExtra(<span class="string">"sms_body"</span>, <span class="string">"Hello"</span>); </div><div class="line">Uri uri = Uri.parse(<span class="string">"content://media/external/images/media/23"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_STREAM, uri); </div><div class="line">intent.setType(<span class="string">"image/png"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(3).通过浏览器打开网页</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"http://www.google.com"</span>); </div><div class="line">Intent intent  = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent);</div><div class="line"><span class="comment">//(4).发送电子邮件</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"mailto:someone@domain.com"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//给someone@domain.com发邮件发送内容为“Hello”的邮件 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND); </div><div class="line">intent.putExtra(Intent.EXTRA_EMAIL, <span class="string">"someone@domain.com"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"Subject"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"Hello"</span>); </div><div class="line">intent.setType(<span class="string">"text/plain"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">// 给多人发邮件 </span></div><div class="line">Intent intent=<span class="keyword">new</span> Intent(Intent.ACTION_SEND); </div><div class="line">String[] tos = &#123;<span class="string">"1@abc.com"</span>, <span class="string">"2@abc.com"</span>&#125;; <span class="comment">// 收件人 </span></div><div class="line">String[] ccs = &#123;<span class="string">"3@abc.com"</span>, <span class="string">"4@abc.com"</span>&#125;; <span class="comment">// 抄送 </span></div><div class="line">String[] bccs = &#123;<span class="string">"5@abc.com"</span>, <span class="string">"6@abc.com"</span>&#125;; <span class="comment">// 密送 </span></div><div class="line">intent.putExtra(Intent.EXTRA_EMAIL, tos); </div><div class="line">intent.putExtra(Intent.EXTRA_CC, ccs); </div><div class="line">intent.putExtra(Intent.EXTRA_BCC, bccs); </div><div class="line">intent.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"Subject"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"Hello"</span>); </div><div class="line">intent.setType(<span class="string">"message/rfc822"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(5).显示地图与路径规划</span></div><div class="line"><span class="comment">// 打开Google地图中国北京位置（北纬39.9，东经116.3） </span></div><div class="line">Uri uri = Uri.parse(<span class="string">"geo:39.9,116.3"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">// 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4） </span></div><div class="line">Uri uri = Uri.parse(<span class="string">"http://maps.google.com/maps?f=d&amp;saddr=39.9 116.3&amp;daddr=31.2 121.4"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(6).播放多媒体</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW); </div><div class="line">Uri uri = Uri.parse(<span class="string">"file:///sdcard/foo.mp3"</span>); </div><div class="line">intent.setDataAndType(uri, <span class="string">"audio/mp3"</span>); </div><div class="line">startActivity(intent); </div><div class="line">Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, <span class="string">"1"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(7).拍照</span></div><div class="line"><span class="comment">// 打开拍照程序 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);  </div><div class="line">startActivityForResult(intent, <span class="number">0</span>); </div><div class="line"><span class="comment">// 取出照片数据 </span></div><div class="line">Bundle extras = intent.getExtras();  </div><div class="line">Bitmap bitmap = (Bitmap) extras.get(<span class="string">"data"</span>); </div><div class="line"><span class="comment">//(8).获取并剪切图片</span></div><div class="line"><span class="comment">// 获取并剪切图片 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT); </div><div class="line">intent.setType(<span class="string">"image/*"</span>); </div><div class="line">intent.putExtra(<span class="string">"crop"</span>, <span class="string">"true"</span>); <span class="comment">// 开启剪切 </span></div><div class="line">intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">1</span>); <span class="comment">// 剪切的宽高比为1：2 </span></div><div class="line">intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">2</span>); </div><div class="line">intent.putExtra(<span class="string">"outputX"</span>, <span class="number">20</span>); <span class="comment">// 保存图片的宽和高 </span></div><div class="line">intent.putExtra(<span class="string">"outputY"</span>, <span class="number">40</span>);  </div><div class="line">intent.putExtra(<span class="string">"output"</span>, Uri.fromFile(<span class="keyword">new</span> File(<span class="string">"/mnt/sdcard/temp"</span>))); <span class="comment">// 保存路径 </span></div><div class="line">intent.putExtra(<span class="string">"outputFormat"</span>, <span class="string">"JPEG"</span>);<span class="comment">// 返回格式 </span></div><div class="line">startActivityForResult(intent, <span class="number">0</span>); </div><div class="line"><span class="comment">// 剪切特定图片 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.android.camera.action.CROP"</span>);  </div><div class="line">intent.setClassName(<span class="string">"com.android.camera"</span>, <span class="string">"com.android.camera.CropImage"</span>);  </div><div class="line">intent.setData(Uri.fromFile(<span class="keyword">new</span> File(<span class="string">"/mnt/sdcard/temp"</span>)));  </div><div class="line">intent.putExtra(<span class="string">"outputX"</span>, <span class="number">1</span>); <span class="comment">// 剪切的宽高比为1：2 </span></div><div class="line">intent.putExtra(<span class="string">"outputY"</span>, <span class="number">2</span>); </div><div class="line">intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">20</span>); <span class="comment">// 保存图片的宽和高 </span></div><div class="line">intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">40</span>); </div><div class="line">intent.putExtra(<span class="string">"scale"</span>, <span class="keyword">true</span>); </div><div class="line">intent.putExtra(<span class="string">"noFaceDetection"</span>, <span class="keyword">true</span>);  </div><div class="line">intent.putExtra(<span class="string">"output"</span>, Uri.parse(<span class="string">"file:///mnt/sdcard/temp"</span>));  </div><div class="line">startActivityForResult(intent, <span class="number">0</span>); </div><div class="line"><span class="comment">//(9).打开Google Market</span></div><div class="line"><span class="comment">// 打开Google Market直接进入该程序的详细页面 </span></div><div class="line">Uri uri = Uri.parse(<span class="string">"market://details?id="</span> + <span class="string">"com.demo.app"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(10).安装和卸载程序</span></div><div class="line">Uri uri = Uri.fromParts(<span class="string">"package"</span>, <span class="string">"com.demo.app"</span>, <span class="keyword">null</span>);   </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DELETE, uri);   </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(11).进入设置界面</span></div><div class="line"><span class="comment">// 进入无线网络设置界面（其它可以举一反三）   </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);</div><div class="line">startActivityForResult(intent, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/04/24/Activity/activity.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/categories/Android/%E5%AE%9E%E4%B9%A0%E7%94%9F/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
      <category term="实习生" scheme="https://jaykuzzi.github.io/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="四大组件" scheme="https://jaykuzzi.github.io/tags/%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6/"/>
    
  </entry>
  
</feed>

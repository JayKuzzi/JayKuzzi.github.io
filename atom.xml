<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Woobo&#39;Blog</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jaykuzzi.github.io/"/>
  <updated>2017-06-26T12:48:28.000Z</updated>
  <id>https://jaykuzzi.github.io/</id>
  
  <author>
    <name>汪博</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android实习生 —— 四大组件之ContentProvider</title>
    <link href="https://jaykuzzi.github.io/2016/07/05/ContentProvider/"/>
    <id>https://jaykuzzi.github.io/2016/07/05/ContentProvider/</id>
    <published>2016-07-05T12:17:59.000Z</published>
    <updated>2017-06-26T12:48:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/07/05/ContentProvider/content.png" alt=""><br><a id="more"></a></p>
<h1 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a><center>基础回顾</center></h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ContentProvider（数据提供者）是在应用程序间共享数据的一种接口机制，虽然我们可以采用文件存储方式、sharedpreferences方式在程序间进行共享数据，但ContentProvider提供了更为高级的数据共享方法，应用程序可以指定需要共享的数据，而其他应用程序则可以在不知数据来源、路径的情况下，对共享数据进行查询、添加、删除和更新等操作，当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-fc2bc00457198686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ContentProvider"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>1、</strong>为存储和获取数据提供了统一的接口。<br><strong>2、</strong>可以在不同的应用程序之间共享数据。<br><strong>3、</strong>使用数据库表的形式来组织数据进行封装。<a href="http://www.jianshu.com/p/4375bedacb99" target="_blank" rel="external">数据库使用：Android实习生 —— 数据存储与共享</a><br><strong>4、</strong>为应用间的数据交互提供了一个安全的环境。它准许你把自己的应用数据根据需求开放给其他应用进行增、删、改、查，而不用担心直接开放数据库权限而带来的安全问题。<br><em>【总的来说使用ContentProvider对外共享数据的好处是统一了数据的安全访问方式。】</em></p>
<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Android已经为常见的一些数据提供了系统默认的ContentProvider，比如去获取通讯录信息、获取图片、视频信息。我们可以在其他应用程通过提供的ContentProvider获取这些数据。</p>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><center>相关概念</center></h1><h2 id="1、Uri"><a href="#1、Uri" class="headerlink" title="1、Uri"></a>1、Uri</h2><p><strong>通用资源标志符（Universal Resource Identifier, 简称”URI”）。</strong><br>Uri代表了要操作的数据，它为系统的每一个资源给其一个名字，比方说通话记录。每一个ContentProvider都拥有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-c19497f193195cbe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Uri"><br>URI一般主要由三部分组成：<br><strong>Authority：</strong>授权信息，用以区别不同的ContentProvider，外部调用者可以根据这个标识来找到它。为了保证URI标识的唯一性，它必须是一个完整的、小写的类名。这个标识在 元素的 authorities属性中说明：一般是定义该ContentProvider的包.类的名称。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">".MyProvider"</span></span></div><div class="line">		  <span class="attr">android:authorities</span>=<span class="string">"com.xxx.MyApp.myprovider"</span> /&gt;</div></pre></td></tr></table></figure></p>
<p><strong>Path：</strong>表名，用以区分ContentProvider中不同的数据表；<br><strong>Id：</strong>Id号，用以区别表中的不同数据记录；如果没有ID，就表示返回全部； “content://com.xxx.MyApp.myprovider/tablename/#” #表示数据id。<br>【举例】<br>1、要操作person表中id为10的记录，可以构建这样的路径:/person/10<br>2、要操作person表中id为10的记录的name字段， person/10/name<br>3、要操作person表中的所有记录，可以构建这样的路径:/person<br>4、如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：Uri uri = Uri.parse(“content://com.xxx.MyApp.myprovider/person”)<br><strong>【每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。Android所提供的ContentProvider都存放在android.provider包当中】</strong></p>
<h2 id="2、工具类：UriMatcher"><a href="#2、工具类：UriMatcher" class="headerlink" title="2、工具类：UriMatcher"></a>2、工具类：UriMatcher</h2><p>因为Uri代表了要操作的数据，所以我们经常需要解析Uri，并从Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为<strong>UriMatcher</strong>和<strong>ContentUris</strong> 。掌握它们的使用，会便于我们的开发工作。<br>使用方法如下：<br><strong>第一步，初始化：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码</span></div><div class="line">UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</div></pre></td></tr></table></figure></p>
<p><strong>第二步，注册需要的Uri:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//如果match()方法匹配content://com.xxx.MyApp.myprovider/person路径，返回匹配码为1</span></div><div class="line">matcher.addURI(<span class="string">"com.xxx.MyApp.myprovider"</span>, <span class="string">"person"</span>, <span class="number">1</span>);  </div><div class="line"><span class="comment">//如果match()方法匹配content://com.xxx.MyApp.myprovider/person/230路径，返回匹配码为2</span></div><div class="line">matcher.addURI(<span class="string">"com.xxx.MyApp.myprovider"</span>, <span class="string">"person/#"</span>, <span class="number">2</span>);  <span class="comment">//#号为通配符</span></div></pre></td></tr></table></figure></p>
<p><strong>第三步，与已经注册的Uri进行匹配:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/people"</span>);  </div><div class="line"><span class="keyword">int</span> match = matcher.match(uri);  </div><div class="line">			 <span class="keyword">switch</span> (match)  </div><div class="line">			 &#123;  </div><div class="line">					 <span class="keyword">case</span> <span class="number">1</span>:  </div><div class="line">							 <span class="keyword">break</span>;</div><div class="line">					 <span class="keyword">case</span> <span class="number">2</span>:  </div><div class="line">							 <span class="keyword">break</span>;</div><div class="line">					 <span class="keyword">default</span>:  </div><div class="line">							 <span class="keyword">break</span>;</div><div class="line">			 &#125;</div></pre></td></tr></table></figure></p>
<p>match方法匹配后会返回一个匹配码Code，即在使用注册方法addURI时传入的第三个参数。 </p>
<h2 id="3、工具类ContentUris："><a href="#3、工具类ContentUris：" class="headerlink" title="3、工具类ContentUris："></a>3、工具类ContentUris：</h2><p>ContentUris类用于操作Uri路径后面的ID部分，它有两个比较实用的方法：<br><strong>withAppendedId(uri, id)</strong>用于为路径加上ID部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/person"</span>)</div><div class="line">Uri resultUri = ContentUris.withAppendedId(uri, <span class="number">10</span>); </div><div class="line"><span class="comment">//生成后的Uri为：content://com.xxx.MyApp.myprovider/person/10</span></div></pre></td></tr></table></figure></p>
<p><strong>parseId(uri)</strong>方法用于从路径中获取ID部分：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Uri uri = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/person/10"</span>)</div><div class="line"><span class="keyword">long</span> personid = ContentUris.parseId(uri);<span class="comment">//获取的结果为:10</span></div></pre></td></tr></table></figure></p>
<h1 id="使用ContentProvider共享数据-Demo，下载链接见附录"><a href="#使用ContentProvider共享数据-Demo，下载链接见附录" class="headerlink" title="使用ContentProvider共享数据(Demo，下载链接见附录)"></a><center>使用ContentProvider共享数据(Demo，下载链接见附录)</center></h1><h2 id="1、建立一个Provider所用到变量类"><a href="#1、建立一个Provider所用到变量类" class="headerlink" title="1、建立一个Provider所用到变量类"></a>1、建立一个Provider所用到变量类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentData</span> </span>&#123;</div><div class="line">		<span class="comment">//provider唯一标示信息</span></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String CONTENT_AUTHORITY = <span class="string">"com.xxx.MyApp.myprovider"</span>;</div><div class="line">		<span class="comment">//基础Uri</span></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri BASE_CONTENT_URI = Uri.parse(<span class="string">"content://"</span> + CONTENT_AUTHORITY);</div><div class="line">		<span class="comment">//操作表的名称</span></div><div class="line">		<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH_TEST = <span class="string">"people"</span>;</div><div class="line">		<span class="comment">//表中记录信息</span></div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEntry</span> <span class="keyword">implements</span> <span class="title">BaseColumns</span> </span>&#123;				</div><div class="line">				<span class="comment">// 完整Uri</span></div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri CONTENT_URI = BASE_CONTENT_URI.buildUpon().appendPath(PATH_TEST).build();</div><div class="line">				<span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> Uri <span class="title">buildUri</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">						<span class="keyword">return</span> ContentUris.withAppendedId(CONTENT_URI, id);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String TABLE_NAME = <span class="string">"people"</span>;</div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_NAME = <span class="string">"name"</span>;</div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_SEX = <span class="string">"sex"</span>;</div><div class="line">				<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COLUMN_AGE = <span class="string">"age"</span>;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="2、Provider最终还要操作数据库，这里我们写数据库操作类代码"><a href="#2、Provider最终还要操作数据库，这里我们写数据库操作类代码" class="headerlink" title="2、Provider最终还要操作数据库，这里我们写数据库操作类代码"></a>2、Provider最终还要操作数据库，这里我们写数据库操作类代码</h2><p><a href="http://www.jianshu.com/p/4375bedacb99" target="_blank" rel="external">数据库使用：Android实习生 —— 数据存储共享</a>**<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBOpenHelper</span> <span class="keyword">extends</span> <span class="title">SQLiteOpenHelper</span> </span>&#123;</div><div class="line">		<span class="comment">//数据库版本</span></div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DATABASE_VERSION = <span class="number">1</span>;</div><div class="line">		<span class="comment">//数据库名称</span></div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATABASE_NAME = <span class="string">"people.db"</span>;</div><div class="line">		<span class="comment">//构造方法</span></div><div class="line">		 <span class="function"><span class="keyword">public</span> <span class="title">DBOpenHelper</span><span class="params">(Context context)</span> </span>&#123;</div><div class="line">		 <span class="keyword">super</span>(context, DATABASE_NAME,<span class="keyword">null</span>, DATABASE_VERSION);</div><div class="line">		 &#125;		</div><div class="line">		<span class="comment">//通过sql语句建表并插入数据</span></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(SQLiteDatabase db)</span> </span>&#123;</div><div class="line">				System.out.println(<span class="string">"create table"</span>);</div><div class="line">				<span class="keyword">final</span> String SQL_CREATE_CONTACT_TABLE = <span class="string">"CREATE TABLE "</span> + ContentData.TestEntry.TABLE_NAME + <span class="string">"( "</span></div><div class="line">								+ <span class="string">"_id integer primary key autoincrement,"</span></div><div class="line">								+ ContentData.TestEntry.COLUMN_NAME + <span class="string">" TEXT NOT NULL,"</span></div><div class="line">								+ ContentData.TestEntry.COLUMN_SEX + <span class="string">" TEXT NOT NULL,"</span></div><div class="line">								+ ContentData.TestEntry.COLUMN_AGE + <span class="string">" INTEGER NOT NULL );"</span>;</div><div class="line">				db.execSQL(SQL_CREATE_CONTACT_TABLE);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张三','女',18)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张四','男',20)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张五','女',19)"</span>);</div><div class="line">				db.execSQL(<span class="string">"insert into people(name,sex,age)values('张六','男',22)"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//数据库升级的时候会调用的代码</span></div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUpgrade</span><span class="params">(SQLiteDatabase db, <span class="keyword">int</span> oldVersion, <span class="keyword">int</span> newVersion)</span> </span>&#123;</div><div class="line">				db.execSQL(<span class="string">"DROP TABLE IF EXISTS "</span> + ContentData.TestEntry.TABLE_NAME);</div><div class="line">				onCreate(db);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="3、创建自己的Provider"><a href="#3、创建自己的Provider" class="headerlink" title="3、创建自己的Provider"></a>3、创建自己的Provider</h2><p><strong>MyProvider继承ContentProvider。默认该Provider需要实现如下六个方法</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyProvider</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> DBOpenHelper dbOpenHelper;<span class="comment">//声明数据库操作类</span></div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> TEST = <span class="number">100</span>;<span class="comment">//匹配码		</span></div><div class="line">		<span class="comment">//使用UriMatcher解析Uri，如果被匹配到，返回匹配码100</span></div><div class="line">		<span class="function"><span class="keyword">static</span> UriMatcher <span class="title">buildUriMatcher</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">final</span> UriMatcher matcher = <span class="keyword">new</span> UriMatcher(UriMatcher.NO_MATCH);</div><div class="line">				<span class="keyword">final</span> String authority = ContentData.CONTENT_AUTHORITY;</div><div class="line">				matcher.addURI(authority, ContentData.PATH_TEST, TEST);</div><div class="line">				<span class="keyword">return</span> matcher;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法在ContentProvider被其它应用第一次访问它时才会被创建。</span></div><div class="line">	 <span class="comment">//同时我们操作数据库建表</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">				 dbOpenHelper = <span class="keyword">new</span> DBOpenHelper(getContext());</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用往ContentProvider添加数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues contentValues)</span> </span>&#123;</div><div class="line">				<span class="comment">//获得可写数据库</span></div><div class="line">				<span class="keyword">final</span> SQLiteDatabase db = dbOpenHelper.getWritableDatabase();</div><div class="line">				Uri returnUri;</div><div class="line">				<span class="keyword">long</span> _id;</div><div class="line">				<span class="keyword">switch</span> ( buildUriMatcher().match(uri)) &#123;</div><div class="line">						<span class="keyword">case</span> TEST:</div><div class="line">								<span class="comment">//插入数据</span></div><div class="line">								_id = db.insert(ContentData.TestEntry.TABLE_NAME, <span class="keyword">null</span>, values);</div><div class="line">								<span class="keyword">if</span> ( _id &gt; <span class="number">0</span> )</div><div class="line">										returnUri = ContentData.TestEntry.buildUri(_id);</div><div class="line">								<span class="keyword">else</span></div><div class="line">										<span class="keyword">throw</span> <span class="keyword">new</span> android.database.SQLException(<span class="string">"Failed to insert row into "</span> + uri);</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">						<span class="keyword">default</span>:</div><div class="line">								<span class="keyword">throw</span> <span class="keyword">new</span> android.database.SQLException(<span class="string">"Unknown uri: "</span> + uri);</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> returnUri;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用从ContentProvider删除数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String s, String[] strings)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用从ContentProvider中获取数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>    		</span>&#123;</div><div class="line">				<span class="comment">//获得可读数据库</span></div><div class="line">				<span class="keyword">final</span> SQLiteDatabase db = dbOpenHelper.getReadableDatabase();</div><div class="line">				 <span class="comment">//查到的结果是游标类型。</span></div><div class="line">				Cursor cursor = <span class="keyword">null</span>;</div><div class="line">				<span class="keyword">switch</span> ( buildUriMatcher().match(uri)) &#123;</div><div class="line">						<span class="keyword">case</span> TEST:</div><div class="line">								cursor = db.query(ContentData.TestEntry.TABLE_NAME, projection, selection, selectionArgs, sortOrder, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">								<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> cursor;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="comment">//该方法用于供外部应用从ContentProvider更新数据。</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues contentValues, String s, String[] strings)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(Uri uri)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//该方法用于返回当前Uri所代表数据的MIME类型。</span></div><div class="line">		<span class="comment">//如果操作的数据属于集合类型，那么MIME类型字符串应以vnd.android.cursor.dir/开头，</span></div><div class="line">		<span class="comment">//例如：要得到所有person记录的Uri为content://com.xxx.MyApp.myprovider/person，</span></div><div class="line">		<span class="comment">//那么返回的MIME类型字符串应该为："vnd.android.cursor.dir/person"。</span></div><div class="line">		<span class="comment">//如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头，</span></div><div class="line">		<span class="comment">//例如：得到id为10的person记录，Uri为content://com.xxx.MyApp.myprovider/person/10，</span></div><div class="line">		<span class="comment">//那么返回的MIME类型字符串为："vnd.android.cursor.item/person"。</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>【注意】以上代码并没有实现删除，更改功能</p>
<h2 id="4、注册Provider"><a href="#4、注册Provider" class="headerlink" title="4、注册Provider"></a>4、注册Provider</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//应用内访问</span></div><div class="line">&lt;provider    </div><div class="line">		android:authorities=<span class="string">"com.xxx.MyApp.myprovider"</span>  </div><div class="line">		android:name=<span class="string">".MyProvider"</span> /&gt;</div></pre></td></tr></table></figure>
<p>在注册的时候需要注意几个属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">android:exported 设置此provider是否可以被其他应用使用。</div><div class="line">android:readPermission 该provider的读权限的标识</div><div class="line">android:writePermission 该provider的写权限标识</div><div class="line">android:permission provider读写权限标识</div></pre></td></tr></table></figure></p>
<p>如何让其他应用也可以访问此应用中的数据呢，我们需要这么注册<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span></span></div><div class="line">		<span class="attr">android:authorities</span>=<span class="string">"com.xxx.MyApp.myprovider"</span></div><div class="line">		<span class="attr">android:name</span>=<span class="string">".MyProvider"</span></div><div class="line">		<span class="attr">android:readPermission</span>=<span class="string">"com.xxx.READ"</span></div><div class="line">		<span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>并且要在注册文件中声明一个permission<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:name</span>=<span class="string">"com.bb.READ"</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span>/&gt;</span></div></pre></td></tr></table></figure></p>
<p>【通过以上步骤，一个ContentProvider就造好了。】</p>
<h1 id="ContentResolver"><a href="#ContentResolver" class="headerlink" title="ContentResolver"></a><center>ContentResolver</center></h1><p><strong>使用ContentResolver调用ContentProvider去操作数据库数据</strong></p>
<h2 id="为什么我们不直接访问Provider。"><a href="#为什么我们不直接访问Provider。" class="headerlink" title="为什么我们不直接访问Provider。"></a>为什么我们不直接访问Provider。</h2><p>大家要知道一台手机中可不是只有一个Provider内容，它可能安装了很多含有Provider的应用，比如联系人应用，日历应用，字典应用等等。有如此多的Provider，如果你开发一款应用要使用其中多个，如果让你去了解每个ContentProvider的不同实现，岂不是要头都大了。所以Android为我们提供了ContentResolver来统一管理与不同ContentProvider间的操作。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-3616f72087c6afef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ContentResolver"></p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p><img src="http://upload-images.jianshu.io/upload_images/4821697-5ba27903f90db1a0.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="实现数据操作的过程"><br>1、当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法通过URI进行数据操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ContentResolver resolver = getContentResolver();</div></pre></td></tr></table></figure></p>
<p>2、ContentResolver 类提供了与ContentProvider类相同签名的四个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Uri <span class="title">insert</span><span class="params">(Uri uri, ContentValues values)</span>：</span></div><div class="line"><span class="comment">//该方法用于往ContentProvider添加数据。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delete</span><span class="params">(Uri uri, String selection, String[] selectionArgs)</span>：</div><div class="line"><span class="comment">//该方法用于从ContentProvider删除数据。</span></div><div class="line"><span class="keyword">public</span> Cursor <span class="title">query</span><span class="params">(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)</span>：</div><div class="line"><span class="comment">//该方法用于从ContentProvider中获取数据。</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Uri uri, ContentValues values, String selection, String[] selectionArgs)</span>：</div><div class="line"><span class="comment">//该方法用于更新ContentProvider中的数据。</span></div></pre></td></tr></table></figure></p>
<p>使用ContentResolver对我们刚才造的ContentProvider中的数据进行添加、查询操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"><span class="comment">//声明Uri常量</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Uri CONTENT_URI = Uri.parse(<span class="string">"content://com.xxx.MyApp.myprovider/people"</span>);</div><div class="line">TextView tv_id, tv_name, tv_sex, tv_age;    </div><div class="line">		 <span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				tv_id = (TextView) findViewById(R.id.tv_id);</div><div class="line">				tv_name = (TextView) findViewById(R.id.tv_name);</div><div class="line">				tv_sex = (TextView) findViewById(R.id.tv_sex);</div><div class="line">				tv_age = (TextView) findViewById(R.id.tv_age);</div><div class="line">				&#125;			</div><div class="line">			<span class="comment">//query()为在xml组建中定义的OnClick</span></div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">				<span class="comment">//通过getContentResolver().query调用ContentProvider实现对数据库的查询</span></div><div class="line">				tv_id.setText(<span class="string">""</span>);</div><div class="line">				tv_name.setText(<span class="string">""</span>);</div><div class="line">				tv_sex.setText(<span class="string">""</span>);</div><div class="line">				tv_age.setText(<span class="string">""</span>);</div><div class="line">				Cursor cursor = getContentResolver().query(CONTENT_URI, <span class="keyword">new</span> String[]&#123;<span class="string">"_id"</span>, <span class="string">"name"</span>, <span class="string">"sex"</span>, <span class="string">"age"</span></div><div class="line">				&#125;, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">				<span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</div><div class="line">						<span class="keyword">while</span> (cursor.moveToNext()) &#123;</div><div class="line">								tv_id.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"_id"</span>)));</div><div class="line">								tv_name.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"name"</span>)));</div><div class="line">								tv_sex.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"sex"</span>)));</div><div class="line">								tv_age.append(<span class="string">"\n"</span> + cursor.getString(cursor.getColumnIndex(<span class="string">"age"</span>)));</div><div class="line">						&#125;</div><div class="line">						cursor.close();</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(View view)</span> </span>&#123;</div><div class="line">				<span class="comment">//通过getContentResolver().insert调用ContentProvider实现对数据库的增加</span></div><div class="line">				ContentValues values = <span class="keyword">new</span> ContentValues();</div><div class="line">				values.put(<span class="string">"name"</span>, <span class="string">"新来的"</span>);</div><div class="line">				values.put(<span class="string">"sex"</span>, <span class="string">"男"</span>);</div><div class="line">				values.put(<span class="string">"age"</span>, <span class="string">"28"</span>);</div><div class="line">				getContentResolver().insert(CONTENT_URI, values);</div><div class="line">				query(findViewById(R.id.btn_query));</div><div class="line">			&#125;  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>【XML布局请下载Demo】<br>3、在注册文件中记得增加权限读取权限<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"com.xxx.READ"</span>/&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.READ_EXTERNAL_STORAGE"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>4、最终效果<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4df4ec743579042b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击查询"><br><img src="http://upload-images.jianshu.io/upload_images/4821697-b555a4f42aac29b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="点击增加"></p>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a>【附录】</h1><h2 id="相关Demo"><a href="#相关Demo" class="headerlink" title="相关Demo"></a>相关Demo</h2><p>请先安装MyProvider，再安装MyResolver。<br><a href="https://github.com/JayKuzzi/Android/tree/master/MyProvider" target="_blank" rel="external">MyProvider</a>、<a href="https://github.com/JayKuzzi/Android/tree/master/MyResolver" target="_blank" rel="external">MyResolver</a><br>另赠送两个Demo，关于对系统Provider的调用（增、查联系人）<br><a href="https://github.com/JayKuzzi/Android/tree/master/ContentProviderDemo2" target="_blank" rel="external">增加联系人</a>、<a href="https://github.com/JayKuzzi/Android/tree/master/ContentProviderDemo1" target="_blank" rel="external">查询联系人</a></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/07/05/ContentProvider/content.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 四大组件之Service</title>
    <link href="https://jaykuzzi.github.io/2016/06/26/Service/"/>
    <id>https://jaykuzzi.github.io/2016/06/26/Service/</id>
    <published>2016-06-26T08:28:56.000Z</published>
    <updated>2017-06-26T11:53:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/06/26/Service/service.png" alt=""><br><a id="more"></a></p>
<h1 id="基础回顾"><a href="#基础回顾" class="headerlink" title="基础回顾"></a><center>基础回顾</center></h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Service是可以在<strong>后台执行长时间（长生命周期）</strong>而又<strong>不与用户产生UI交互（没有用户界面）</strong>的操作。</p>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><strong>1、</strong>只能在后台运行，即便用户切换了其他应用，启动的Service仍可在后台运行。<br><strong>2、</strong>可以和其他组件进行Service绑定并与之交互，甚至是跨进程通信（IPC）。<br><strong>3、</strong>不能运行在一个独立的进程当中，而是依赖与创建服务时所在的应用组件进程。<br><strong>4、</strong>服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务。</p>
<h2 id="应用场景举例"><a href="#应用场景举例" class="headerlink" title="应用场景举例"></a>应用场景举例</h2><p><strong>音乐播放：</strong>播放多媒体的时候用户启动了其他Activity，此时要在后台继续播放。<br><strong>记录检测：</strong>比如检测SD卡上文件的变化；在后台记录你的地理信息位置的改变等。<br><strong>其他操作：</strong>网络请求、执行文件读写操作或者与 content provider交互。</p>
<h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><p><strong>本地服务</strong>依附在主进程上，在一定程度上节约了资源。本地服务因为是在同一进程，因此不需要IPC，也不需要AIDL。相应bindService会方便很多。缺点是主进程被kill后，服务变会终止。<br><strong>远程服务</strong>是独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被kill的是偶，该服务依然在运行。缺点是该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。本文第六部分将会简单的讲述这一进程间通信方式。<br><em>对于startService来说，不管是本地服务还是远程服务，我们需要做的工作都一样简单。</em></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><center>生命周期</center></h1><p>从Service的启动到销毁，有两种路径（两种生命周期）：<br><strong>startService、bindService</strong><br><img src="http://upload-images.jianshu.io/upload_images/4821697-cbd6cf296164ddd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service两种生命周期"></p>
<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><center>使用方法</center></h1><h2 id="1、通过startService方式定义一个Service（继承Service类）"><a href="#1、通过startService方式定义一个Service（继承Service类）" class="headerlink" title="1、通过startService方式定义一个Service（继承Service类）"></a>1、通过startService方式定义一个Service（继承Service类）</h2><p><strong>核心步骤和代码：</strong><br>创建一个类继承android.app.Service类，实现抽象方法onBind()，重写onCreate()、onStartCommand()、onDestry()。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;  </div><div class="line">			 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;  </div><div class="line">			 <span class="comment">//创建服务时调用</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;  </div><div class="line">					 <span class="keyword">super</span>.onCreate();  </div><div class="line">					 Log.d(TAG, <span class="string">"onCreate"</span>);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="comment">//服务执行的操作</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;  </div><div class="line">					 Log.d(TAG, <span class="string">"onStartCommand"</span>);  </div><div class="line">					 <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="comment">//销毁服务时调用</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;  </div><div class="line">					 <span class="keyword">super</span>.onDestroy();  </div><div class="line">					 Log.d(TAG, <span class="string">"onDestroy"</span>);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="comment">//onBind()方法是Service中唯一的一个抽象方法，所以必须要在子类里实现。</span></div><div class="line">			 <span class="comment">//Service有两种启动方式：一种是startService()，另一种是bindService()。第二种启动方式才会用到onBind()方法。</span></div><div class="line">			 <span class="comment">//我们这先用第一种方式定义Service，所以暂时忽略onBind()方法。</span></div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;  </div><div class="line">					 <span class="keyword">return</span> <span class="keyword">null</span>;  </div><div class="line">			 &#125;</div></pre></td></tr></table></figure></p>
<p>在清单文件中配置Service,和Activity标签并列。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyService"</span>&gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><em>请注意：为了保证应用的安全，请使用显式Intent启动或绑定一个Service，请不要在<service>标签中配置intent-filter。</service></em><br>在Activity组件中通过onCreate()声明“启动Service和停止Service”代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;  </div><div class="line">			 <span class="keyword">private</span> Button button1_start_service;  </div><div class="line">			 <span class="keyword">private</span> Button button2_stop_service; </div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">					 <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">					 setContentView(R.layout.activity_main);  </div><div class="line">					 button1_start_service = (Button)findViewById(R.id.button1_start_service);  </div><div class="line">					 button2_stop_service = (Button)findViewById(R.id.button2_stop_service);  </div><div class="line">					 button1_start_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">					 button2_stop_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">			 &#125;  </div><div class="line">			 <span class="meta">@Override</span>  </div><div class="line">			 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">					 <span class="keyword">switch</span> (v.getId()) &#123;  </div><div class="line">					 <span class="keyword">case</span> R.id.button1_start_service:  </div><div class="line">							 Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">							 startService(startIntent);  </div><div class="line">							 <span class="keyword">break</span>;  </div><div class="line">					 <span class="keyword">case</span> R.id.button2_stop_service:  </div><div class="line">							 Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">							 stopService(stopIntent);  </div><div class="line">							 <span class="keyword">break</span>;  </div><div class="line">					 <span class="keyword">default</span>:  </div><div class="line">							 <span class="keyword">break</span>;  </div><div class="line">					 &#125;  </div><div class="line">			 &#125;  </div><div class="line">	 &#125;</div></pre></td></tr></table></figure></p>
<p>启动和停止服务：<br>startService()和stopService()方法都是定义在Context类当中的，所以可以在MainActivity中直接调用这两个方法。<br> 运行上面的程序，点击button1_start_service按钮，通过Intent实现启动服务，后台打印日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-124753834491008c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过startService方式启动服务后台日志"><br>说明服务启动成功。<br>那么如果我再连续点三次button1_start_service按钮，后台增加的日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-e41f3601e6784870.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过startService方式多次启动服务后台日志"><br><strong>onCreate()方法只会在Service第一次被创建的时候调用，而onStartCommand()方法在每次启动服务的时候都会调用。</strong><br>我们还可以在正在“设置–应用—运行”中找到这个服务，如下图所示：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-5d237864961d6359.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="手机运行的服务"><br>如果我们再点击button2_stop_service按钮或者点击上图中的“Stop”，MyService服务就停止掉了（多次点击stop不会再产生日志）：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-7fc0f1bcd9e6ca05.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过startService方式停止服务后台日志"><br><strong>通过startService方式（继承Service类）总结</strong><br><strong>1、启动服务对象多次启动同时只会产生一个，onCreate()方法只会在Service第一次被创建的时候调用，多次点击启动会执行多次onStartCommand()方法，onDestroy()方法只会在Service第一次被停止的时候调用，多次点击停止不会报异常，也不再执行onDestroy()方法。</strong><br><strong>2、一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。</strong><br><strong>3、停止一个started服务有两种方法：</strong><br><strong>（1）在外部使用stopService()手动停止。</strong><br><strong>（2）在服务内部(onStartCommand方法内部)使用stopSelf()方法，使服务执行完毕后自动停止。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。</strong><br><strong>4、onStartCommand方法的返回值：</strong><br>onStartCommand方法执行时，返回的是一个int型。这个整型可以有三个返回值：<strong>START_NOT_STICKY</strong>、<strong>START_STICKY</strong>、<strong>START_REDELIVER_INTENT</strong><br><strong>START_NOT_STICKY:</strong>“非粘性的”。使用这个返回值时，如果在执行完onStartCommand方法后，服务被异常kill掉，系统不会自动重启该服务。<br><strong>START_STICKY：</strong>如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。<br><strong>START_REDELIVER_INTENT：</strong>重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。<br><strong>5、默认情况下，一个started的Service与启动他的组件在同一个线程中。上面的实例中，服务就是在主线程中运行的，如果是在服务中完成耗时操作的话，容易造成主线程阻塞。所以我们可以在服务中开启一个子线程来完成耗时操作。</strong></p>
<h2 id="2、通过startService方式定义一个Service（继承IntentService类）："><a href="#2、通过startService方式定义一个Service（继承IntentService类）：" class="headerlink" title="2、通过startService方式定义一个Service（继承IntentService类）："></a>2、通过startService方式定义一个Service（继承IntentService类）：</h2><p><strong>为什么要通过继承IntentService来定义：</strong><br>我们在基础回顾的注意事项3、4中就已经了解，服务中的代码默认运行在主线程中，如果直接在服务里执行一些安卓不允许的耗时操作，容易造成主线程ANR（Application Not Responding）异常，所以就需要用到多线程的知识了，需要在服务的内部手动创建子线程。所以一个比较标准的服务可以这样写：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;  </div><div class="line">			<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;   </div><div class="line">		 <span class="comment">//服务执行的操作</span></div><div class="line">		 <span class="meta">@Override</span>  </div><div class="line">		 <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;  </div><div class="line">				 <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">						 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">									<span class="comment">//在子线程中处理具体的逻辑</span></div><div class="line">									<span class="comment">//在这里我们只做打印子线程id的操作</span></div><div class="line">								 Log.i(<span class="string">"MyService"</span>,Thread.currentThread().getId()+<span class="string">""</span>);</div><div class="line">								 stopSelf();  <span class="comment">//服务执行完毕后自动停止</span></div><div class="line">						 &#125;</div><div class="line">				 &#125;).start();        </div><div class="line">				 <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);  </div><div class="line">		 &#125;</div><div class="line">		 <span class="meta">@Override</span></div><div class="line">		 <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				 <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">				 <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">		 &#125;      </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在MainActivity中启动Service代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;  </div><div class="line">	 <span class="keyword">private</span> Button button1_start_service;  </div><div class="line">	 <span class="keyword">private</span> Button button2_stop_service; </div><div class="line">	 <span class="meta">@Override</span>  </div><div class="line">	 <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">			 <span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">			 setContentView(R.layout.activity_main);  </div><div class="line">			 button1_start_service = (Button)findViewById(R.id.button1_start_service);  </div><div class="line">			 button2_stop_service = (Button)findViewById(R.id.button2_stop_service);  </div><div class="line">			 button1_start_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">			 button2_stop_service.setOnClickListener(<span class="keyword">this</span>);  </div><div class="line">	 &#125;  </div><div class="line">	 <span class="meta">@Override</span>  </div><div class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">			 <span class="keyword">switch</span> (v.getId()) &#123;  </div><div class="line">			 <span class="keyword">case</span> R.id.button1_start_service:  </div><div class="line">					 Log.i(<span class="string">"Main"</span>,Thread.currentThread().getId()+<span class="string">""</span>);</div><div class="line">					 Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">					 startService(startIntent);  </div><div class="line">					 <span class="keyword">break</span>;  </div><div class="line">			 <span class="keyword">case</span> R.id.button2_stop_service:  </div><div class="line">					 Intent stopIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);  </div><div class="line">					 stopService(stopIntent);  </div><div class="line">					 <span class="keyword">break</span>;  </div><div class="line">			 <span class="keyword">default</span>:  </div><div class="line">					 <span class="keyword">break</span>;  </div><div class="line">			 &#125;  </div><div class="line">	 &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注册Service步骤不再赘述，当开启Service后打印日志如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-00dd1c9045c24286.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service手动开启线程177"><br>如果我们不手动开启线程，I/MyService: 177将会变成它依赖的主线程1，这就不能做耗时操作了。虽说上面的这种写法并不复杂，但总会有一些程序猿忘记开启线程，或者忘记调用stopSelf()方法。<br><strong>为了可以简单地创建一个可开启单独线程、会自动停止的服务，Android专门提供了一个IntentService类，这个类就很好的解决了上面所提到的两种尴尬。</strong><br><strong>IntentService的作用：</strong><br>当我们需要这样一次性完成的任务时，就可以使用IntentService来完成。<br><strong>IntentService的用法：</strong><br> 1）新建一个MyIntentService类，继承自IntentService，并重写父类的onHandleIntent()方法，代码如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class MyIntentService extends IntentService&#123;</div><div class="line">			public MyIntentService() &#123;</div><div class="line">				 //第一步：重写父类的onHandleIntent()方法，这里首先要提供一个无参的构造方法，</div><div class="line">				 //并且必须在其内部调用父类的有参构造方法，这里我们手动给服务起个名字为：MyIntentService</div><div class="line">				 super("MyIntentService");</div><div class="line">		 &#125;</div><div class="line">			 //第二步：重写父类的onHandleIntent()方法，该方法在会在一个单独的线程中执行，</div><div class="line">			 //来完成工作任务。任务结束后，该Service自动停止</div><div class="line">		 @Override</div><div class="line">		 protected void onHandleIntent(Intent intent) &#123;</div><div class="line">				 for(int i = 0;i&lt;3;i++) &#123;</div><div class="line">						 //Service要执行的逻辑</div><div class="line">						 //这里我们只打印当前线程的id</div><div class="line">						 Log.d("MyIntentService","IntentService线程的id是："+Thread.currentThread().getId());</div><div class="line">						 try &#123;</div><div class="line">								 //线程睡眠一秒钟</div><div class="line">								 Thread.sleep(1000);</div><div class="line">						 &#125; catch (InterruptedException e) &#123;</div><div class="line">								 e.printStackTrace();</div><div class="line">						 &#125;</div><div class="line">				 &#125;        </div><div class="line">		 &#125;</div><div class="line">		 @Override</div><div class="line">		 public void onDestroy() &#123;</div><div class="line">				 super.onDestroy();</div><div class="line">				 Log.d("MyIntentService","onDestroy");</div><div class="line">		 &#125;</div><div class="line"> &#125;</div><div class="line">```java</div><div class="line"> 2）在清单文件中对服务进行注册服务：</div><div class="line">```xml</div><div class="line">&lt;service android:name=".MyIntentService"&gt;&lt;/service&gt;</div></pre></td></tr></table></figure></p>
<p>3)在MainActivity里面加入启动IntentService的逻辑，核心代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> R.id.button3_stop_intentservice:</div><div class="line">		 Log.d(<span class="string">"MainActivity"</span>,<span class="string">"主线程的id是："</span>+Thread.currentThread().getId());</div><div class="line">		 Intent intentService = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyIntentService.class);</div><div class="line">		 startService(intentService);</div></pre></td></tr></table></figure></p>
<p>运行程序，日志显示如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-0fc34183a06cceb2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="通过继承IntentService运行结果"><br><strong>通过startService方式（继承IntentService类） 总结</strong><br><strong>1、启动一个IntentService和启动一个普通的Service，步骤是相似的。</strong><br><strong>2、与直接继承Service不同在于：通过继承IntentService运行，自动开启了单独线程，而且完成任务后自动销毁了Service。</strong><br><strong>【补充】Service和Thread的关系：</strong><br>不少Android初学者都可能会有这样的疑惑，Service和Thread到底有什么关系呢？什么时候应该用Service，什么时候又应该用Thread？答案可能会有点让你吃惊，因为Service和Thread之间没有任何关系！<br>之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但是，Service其实是运行在主线程里的，一些比较耗时的操作需要开启单独线程。</p>
<h2 id="3、通过bindService方式定义一个Service：（使用Bind-Service完成Service和Activity之间的通信）："><a href="#3、通过bindService方式定义一个Service：（使用Bind-Service完成Service和Activity之间的通信）：" class="headerlink" title="3、通过bindService方式定义一个Service：（使用Bind Service完成Service和Activity之间的通信）："></a>3、通过bindService方式定义一个Service：（使用Bind Service完成Service和Activity之间的通信）：</h2><p><strong>Bind Service的引入：</strong><br>有没有什么办法能让Service与组件的关联更多一些呢？比如说在Activity中指挥Service去干什么，Service就去干什么。当然可以，只需要让Activity和Service建立关联就好了。这时我们就可以通过bindService方式定义一个Service。<br><strong>Bind Service的实现原理：</strong><br> 应用程序组件(客户端）通过调用bindService()方法能够绑定服务，然后Android系统会调用服务的onBind()回调方法，则个方法会返回一个跟服务器端交互的Binder对象。<br>bindService()方法立即返回，并且不给客户端返回IBinder对象。要接收IBinder对象，客户端必须创建一个ServiceConnection类的实例，并且把这个实例传递给bindService()方法。ServiceConnection对象包含了一个系统调用的传递IBinder对象的回调方法。<br><strong>Bind Service实现流程：</strong><br>1）一直有一个onBind()方法我们都没有使用到，这个方法其实就是用于和Activity建立关联的，修改MyService中的代码，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBindService01</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">		<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyBindService01"</span>;</div><div class="line">		<span class="keyword">private</span> MyBinder mBinder = <span class="keyword">new</span> MyBinder();</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate();</div><div class="line">				Log.d(TAG, <span class="string">"onCreate"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> mBinder;  <span class="comment">//在这里返回新建的MyBinder类</span></div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				Log.d(TAG, <span class="string">"onUnbind"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.onUnbind(intent);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">				Log.d(TAG, <span class="string">"onStartCommand"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onDestroy();</div><div class="line">				Log.d(TAG, <span class="string">"onDestroy"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度</span></div><div class="line">		<span class="class"><span class="keyword">class</span> <span class="title">MyBinder</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDownload</span><span class="params">()</span> </span>&#123;</div><div class="line">						Log.d(<span class="string">"TAG"</span>, <span class="string">"startDownload() executed"</span>);</div><div class="line">						<span class="comment">// 执行具体的下载任务  </span></div><div class="line">				&#125;</div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getProgress</span><span class="params">()</span></span>&#123;</div><div class="line">						Log.d(<span class="string">"TAG"</span>, <span class="string">"getProgress() executed"</span>);</div><div class="line">						<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>新建一个MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度。当然，这里只是两个模拟方法，并没有实现真正的功能，我们通过打印日志的形式来体现。<br>接着创建MyBinder的实例，然后在onBind()方法里返回这个实例。返回这个mBinder，是一个IBinder类型，就可以把这个IBinder类型传递到MainActivity中，从而调用Service里面的方法。<br>2）检查清单文件，是否已经对Service进行注册：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".MyBindService01"</span> &gt;</span><span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>3）让我们修改MainActivity和MyBindService01之间建立关联<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> Button button1_bind_service;</div><div class="line">		<span class="keyword">private</span> Button button2_unbind_service;</div><div class="line">		<span class="keyword">private</span> MyBindService01.MyBinder myBinder;</div><div class="line">		<span class="keyword">boolean</span> mBound = <span class="keyword">false</span>; <span class="comment">//一开始，并没有和Service绑定.这个参数是用来显示绑定状态		</span></div><div class="line">		<span class="comment">//匿名内部类：服务连接对象</span></div><div class="line">		<span class="keyword">private</span> ServiceConnection connection = <span class="keyword">new</span> ServiceConnection() &#123;				</div><div class="line">				<span class="comment">//当服务异常终止时会调用。注意，解除绑定服务时不会调用</span></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">						mBound = <span class="keyword">false</span>; <span class="comment">//服务异常终止时，状态为未绑定</span></div><div class="line">						<span class="comment">//解决了多次执行unbindService()方法引发的异常问题</span></div><div class="line">				&#125;				</div><div class="line">				<span class="comment">//和服务绑定成功后，服务会回调该方法</span></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">						myBinder = (MyBindService01.MyBinder) service;</div><div class="line">						<span class="comment">//在Activity中调用Service里面的方法</span></div><div class="line">						myBinder.startDownload();</div><div class="line">						myBinder.getProgress();</div><div class="line">						mBound = <span class="keyword">true</span>; <span class="comment">//true说明是绑定状态</span></div><div class="line">				&#125;</div><div class="line">		&#125;;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				button1_bind_service = (Button) findViewById(R.id.button1_bind_service);</div><div class="line">				button2_unbind_service = (Button) findViewById(R.id.button2_unbind_service);</div><div class="line">				button1_bind_service.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">				button2_unbind_service.setOnClickListener(<span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">				<span class="keyword">switch</span> (v.getId()) &#123;</div><div class="line">				<span class="keyword">case</span> R.id.button1_bind_service:</div><div class="line">						Intent bindIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, MyService.class);</div><div class="line">						bindService(bindIntent, connection, BIND_AUTO_CREATE);</div><div class="line"><span class="comment">//这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后会自动创建Service（即使之前没有创建</span></div><div class="line"><span class="comment">//Service也没有关系），这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。</span></div><div class="line">						<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">case</span> R.id.button2_unbind_service:</div><div class="line">						<span class="comment">//如果和Service是绑定的状态，就解除绑定。</span></div><div class="line">						<span class="keyword">if</span>(mBound)&#123;</div><div class="line">								unbindService(connection);</div><div class="line">								mBound=<span class="keyword">false</span>;</div><div class="line">						&#125;</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">				<span class="keyword">default</span>:</div><div class="line">						<span class="keyword">break</span>;</div><div class="line">				&#125;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>说明：这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，如果当前Activity与服务连接成功后，服务会回调onServiceConnected()方法<br>在onServiceConnected()方法中，我们又通过向下转型得到了MyBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。现在我们可以在Activity中根据具体的场景来调用MyBinder中的任何public方法，即实现了Activity指挥Service干什么Service就去干什么的功能。<br>4）执行bindService()方法。<br><img src="//upload-images.jianshu.io/upload_images/4821697-19b1f71bd708830b.png" alt=""><br>5）解除Activity和Service之间的关联。执行unbindService()。<br><img src="//upload-images.jianshu.io/upload_images/4821697-67e550c08838d7af.png" alt=""><br><strong>通过bindService方式 总结</strong><br><strong>1、onCreate()、onBind()方法只会在Service第一次被创建的时候调用，多次点击绑定启动不会执行任何方法，onUnbind()、onDestroy()方法会在调用者执行unbindService()方法时执行或者Activity退出时自动执行。</strong><br><strong>2、如果我们既通过startService()开启Service，又用通过bindService开启，必要unbindService()和stopService()都执行一次（没有先后顺序），Service才会被销毁。</strong><br><strong>3、如果多次执行unbinsService()方法，程序会异常退出，我们需要在代码中加一个判断是否绑定的标记mBound来解决此问题，上面代码中有说明。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> R.id.button4_unbind_service:</div><div class="line"><span class="comment">//如果和Service是绑定的状态，就解除绑定。</span></div><div class="line"><span class="keyword">if</span>(mBound)&#123;</div><div class="line">		unbindService(connection);</div><div class="line">		mBound=<span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">break</span>;</div></pre></td></tr></table></figure></p>
<p><strong>4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了）。</strong><br><strong>5、只有Activity、Service、Content Provider能够绑定服务；BroadcastReceiver广播接收器不能绑定服务。</strong></p>
<h2 id="4、bindService和startService混合使用："><a href="#4、bindService和startService混合使用：" class="headerlink" title="4、bindService和startService混合使用："></a>4、bindService和startService混合使用：</h2><p><strong>如果先startService,再bindService:</strong><br><strong>在bind的Activity退出的时候,Service会执行unBind方法而不执行其onDestory方法,因为有startService方法调用过,</strong><br><strong>所以Activity与Service解除绑定后会有一个与调用者没有关连的Service存在。</strong><br><strong>如果先bindService,再startService,再调用Context.stopService</strong><br><strong>Service的onDestory方法不会立刻执行,因为有一个与Service绑定的Activity,但是在Activity退出的时候,会执行其(Service的)onDestory方法,如果要立刻执行stopService,就得先解除绑定。</strong><br><strong>如果先是bind了，那么start的时候就直接运行Service的onStartCommand()方法，如果先是start，那么bind的时候就直接运行onBind()方法。</strong><br><strong>当一个服务没被onDestory()销毁之前，只有第一个启动它的客户端能调用它的onBind()和onUnbind()。</strong></p>
<h1 id="startService、bindService区别大总结"><a href="#startService、bindService区别大总结" class="headerlink" title="startService、bindService区别大总结"></a><center>startService、bindService区别大总结</center></h1><p><strong>1、生命周期不同。（详见二）</strong><br><strong>2、多次启动，前者会多次执行onStartCommand()方法，后者什么都不执行。多次停止，前者只会执行一次onDestroy()方法，后者报异常信息。</strong><br><strong>3、当启动Service的组件已被Destroy的时候，前者不停止，后者会停止。</strong><br><strong>4、前者停止直接执行onDestroy()方法（Service中的），后者则先解除绑onUnbind()定再执行onDestroy()方法（Service中的）。</strong><br><strong>5、当手机屏幕在“横”“竖”变换时，前者创建的Service不会停止，后者会随着Activity的重建而停止。</strong><br><strong>6、后者的onBind回调方法将返回给客户端一个IBinder接口实例，IBinder允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。而这些操作前者启动的Service是没有的。</strong></p>
<h1 id="在AndroidManifest-xml里Service元素常见选项"><a href="#在AndroidManifest-xml里Service元素常见选项" class="headerlink" title="在AndroidManifest.xml里Service元素常见选项"></a><center>在AndroidManifest.xml里Service元素常见选项</center></h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">android:name   --　服务类名</div><div class="line">android:label  --  服务的名字，如果此项不设置，那么默认显示的服务名则为类名</div><div class="line">android:icon　--　服务的图标</div><div class="line">android:permission　--　申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务</div><div class="line">android:process　--　表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字</div><div class="line">android:enabled　--表示是否能被系统实例化，为true表示可以，为false表示不可以，默认为true</div><div class="line">android:exported　--　表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false</div></pre></td></tr></table></figure>
<h1 id="扩展：进程间通信"><a href="#扩展：进程间通信" class="headerlink" title="扩展：进程间通信"></a><center>扩展：进程间通信</center></h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>调用者和Service如果不在一个进程内, 就需要使用android中的远程Service调用机制.<br>android使用AIDL定义进程间的通信接口. AIDL的语法与java接口类似, 需要注意以下几点:</p>
<ol>
<li>AIDL文件必须以.aidl作为后缀名.</li>
<li>AIDL接口中用到的数据类型, 除了基本类型, String, List, Map, CharSequence之外, 其他类型都需要导包, 即使两种在同一个包内. List和Map中的元素类型必须是AIDL支持的类型.</li>
<li>接口名需要和文件名相同.</li>
<li>方法的参数或返回值是自定义类型时, 该自定义的类型必须实现了Parcelable接口.</li>
<li>所有非java基本类型参数都需要加上in, out, inout标记, 以表明参数是输入参数, 输出参数, 还是输入输出参数.</li>
<li>接口和方法前不能使用访问修饰符和static, final等修饰.</li>
</ol>
<h2 id="远程通信扩展小例子"><a href="#远程通信扩展小例子" class="headerlink" title="远程通信扩展小例子"></a>远程通信扩展小例子</h2><p><strong>远程service</strong><br>要在service中注册信息中加上 android:process=”:remote”<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".AIDLService"</span></span></div><div class="line">				<span class="attr">android:process</span>=<span class="string">":remote"</span>&gt;<span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>远程service有什么用呢？</strong><br>远程service的作用只是重新建立一个新进程执行，可以独立出去。其他app可以调用这个service。因为是一个新的进程，所以也不能用bindService来建立关联了。可以用新的方式来建立关系就是下面要讲的aidl技术。<br><strong>AIDL实现</strong><br>1.首先我建立2个app工程，通过aidl实现一个app调用另一个app的service<br>目录结构如下：<br>service提供端app<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4047fd697202fee2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="service提供端"><br>利用aidl调用service的app<br><img src="http://upload-images.jianshu.io/upload_images/4821697-19958cfc5a71951c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="service调用端"><br>2.在两个app中都建立一个文件 IPerson.aidl注意 包名 要相同<br>IPerson.aidl只是一个接口文件,用来aidl交互的，建立好之后在Studio中点Build–&gt;Rebuild会自动创建需要的java文件。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-eccab12f13550592.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="接口路径"><br>IPerson.aidl代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> mangues.com.aidl;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span> </span>&#123;</div><div class="line">		<span class="function">String <span class="title">greet</span><span class="params">(String someone)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>3.在aidl_service 中建立AIDLService<br>这个IPerson.Stub 就是通过IPerson.aidl 自动生成的binder 文件，你实现下，然后在onBind()中 return出去就好了，就和Android Service实现和activity交互一样。<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AIDLService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"AIDLService"</span>;</div><div class="line">		IPerson.Stub stub = <span class="keyword">new</span> IPerson.Stub() &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> String <span class="title">greet</span><span class="params">(String someone)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">						Log.i(TAG, <span class="string">"greet() called"</span>);</div><div class="line">						<span class="keyword">return</span> <span class="string">"hello, "</span> + someone;</div><div class="line">				&#125;</div><div class="line">		&#125;;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate();</div><div class="line">				Log.i(TAG, <span class="string">"onCreate() called"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</div><div class="line">				Log.i(TAG, <span class="string">"onBind() onStartCommand"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				Log.i(TAG, <span class="string">"onBind() called"</span>);</div><div class="line">				<span class="keyword">return</span> stub;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onUnbind</span><span class="params">(Intent intent)</span> </span>&#123;</div><div class="line">				Log.i(TAG, <span class="string">"onUnbind() called"</span>);</div><div class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">		&#125;</div><div class="line">		<span class="meta">@Override</span></div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onDestroy();</div><div class="line">				Log.i(TAG, <span class="string">"onDestroy() called"</span>);</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4.aidl_service MainActivity 中启动这个service<br>简单点就不写关闭什么的了；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">			<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">			setContentView(R.layout.activity_main);</div><div class="line">			Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, AIDLService.class);</div><div class="line">			startService(startIntent);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>在AndroidManifest.xml注册<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">service</span> <span class="attr">android:name</span>=<span class="string">".AIDLService"</span></span></div><div class="line">								 <span class="attr">android:process</span>=<span class="string">":remote"</span>&gt;</div><div class="line">						<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">								<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.AIDLService"</span> /&gt;</span></div><div class="line">								<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">						<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">				<span class="tag">&lt;/<span class="name">service</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>作用就是把这个service暴露出去，让别的APP可以利用<br>android.intent.action.AIDLService 字段隐形绑定这个service，获取数据。<br>5.aidl_client 中绑定aidl_service service 获取数据<br>代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">			<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line">			<span class="keyword">private</span> IPerson person;</div><div class="line">			<span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</div><div class="line">				 <span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</div><div class="line">						Log.i(<span class="string">"ServiceConnection"</span>, <span class="string">"onServiceConnected() called"</span>);</div><div class="line">						person = IPerson.Stub.asInterface(service);</div><div class="line">						String retVal = <span class="keyword">null</span>;</div><div class="line">						<span class="keyword">try</span> &#123;</div><div class="line">								retVal = person.greet(<span class="string">"scott"</span>);</div><div class="line">						&#125; <span class="keyword">catch</span> (RemoteException e) &#123;</div><div class="line">								e.printStackTrace();</div><div class="line">						&#125;</div><div class="line">						Toast.makeText(MainActivity.<span class="keyword">this</span>, retVal, Toast.LENGTH_SHORT).show();</div><div class="line">				&#125;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</div><div class="line">						<span class="comment">//This is called when the connection with the service has been unexpectedly disconnected,</span></div><div class="line">						<span class="comment">//that is, its process crashed. Because it is running in our same process, we should never see this happen.</span></div><div class="line">						Log.i(<span class="string">"ServiceConnection"</span>, <span class="string">"onServiceDisconnected() called"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">				setContentView(R.layout.activity_main);</div><div class="line">				Intent mIntent = <span class="keyword">new</span> Intent();</div><div class="line">				mIntent.setAction(<span class="string">"android.intent.action.AIDLService"</span>);</div><div class="line">				Intent eintent = <span class="keyword">new</span> Intent(getExplicitIntent(<span class="keyword">this</span>,mIntent));</div><div class="line">				bindService(eintent, conn, Context.BIND_AUTO_CREATE);</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Intent <span class="title">getExplicitIntent</span><span class="params">(Context context, Intent implicitIntent)</span> </span>&#123;</div><div class="line">				<span class="comment">// Retrieve all services that can match the given intent</span></div><div class="line">				PackageManager pm = context.getPackageManager();</div><div class="line">				List&lt;ResolveInfo&gt; resolveInfo = pm.queryIntentServices(implicitIntent, <span class="number">0</span>);</div><div class="line">				<span class="comment">// Make sure only one match was found</span></div><div class="line">				<span class="keyword">if</span> (resolveInfo == <span class="keyword">null</span> || resolveInfo.size() != <span class="number">1</span>) &#123;</div><div class="line">						<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// Get component info and create ComponentName</span></div><div class="line">				ResolveInfo serviceInfo = resolveInfo.get(<span class="number">0</span>);</div><div class="line">				String packageName = serviceInfo.serviceInfo.packageName;</div><div class="line">				String className = serviceInfo.serviceInfo.name;</div><div class="line">				ComponentName component = <span class="keyword">new</span> ComponentName(packageName, className);</div><div class="line">				<span class="comment">// Create a new intent. Use the old one for extras and such reuse</span></div><div class="line">				Intent explicitIntent = <span class="keyword">new</span> Intent(implicitIntent);</div><div class="line">				<span class="comment">// Set the component to be explicit</span></div><div class="line">				explicitIntent.setComponent(component);</div><div class="line">				<span class="keyword">return</span> explicitIntent;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>和Android Service 中学习的调用MyBinder获取service中数据一样，这边只是吧MyBinder 改成了aidl定义的接口IPerson 本质上还是一个Binder。</strong><br><strong><em>因为android 5.0 不允许隐形启用service 所有用getExplicitIntent转一下</em></strong></p>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/06/26/Service/service.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 四大组件之Broadcast Receiver</title>
    <link href="https://jaykuzzi.github.io/2016/05/02/Receiver/"/>
    <id>https://jaykuzzi.github.io/2016/05/02/Receiver/</id>
    <published>2016-05-02T03:38:57.000Z</published>
    <updated>2017-06-26T04:03:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/05/02/Receiver/main.jpeg" alt=""><br><a id="more"></a></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a><center>前言</center></h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><strong>1.</strong>Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。<strong><em>广播可以跨进程甚至跨App直接通信。</em></strong><br><strong>2.</strong>你的APP可以接收广播(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。<br><strong>3.</strong>广播接收器没有用户界面。然而，它们可以<strong>启动一个Activity或Service服务</strong>来响应它们收到的信息，或者<strong>用NotificationManager 来通知用户</strong>。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：<br><strong>1.</strong>广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册；<br><strong>2.</strong>广播发送者通过Binder机制向AMS发送广播；<br><strong>3.</strong>AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；<br><strong>4.</strong>消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。<br><img src="http://upload-images.jianshu.io/upload_images/4821697-509a9631abac3f80.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Activity Manager、NotificationManager位于安卓架构图Framework层"></p>
<h1 id="广播定义及类型"><a href="#广播定义及类型" class="headerlink" title="广播定义及类型"></a><center>广播定义及类型</center></h1><h2 id="广播定义"><a href="#广播定义" class="headerlink" title="广播定义"></a>广播定义</h2><p>Android系统在运行的过程中，会产生很多系统广播，比如开机、电量改变、收发短信、拨打电话、屏幕解锁。当然我们也可以发送自定义普通或有序广播。</p>
<h2 id="广播类型"><a href="#广播类型" class="headerlink" title="广播类型"></a>广播类型</h2><p><strong>1.普通广播：</strong>通过Context.sendBroadcast(Intent intent)发送，可以在同一时刻（逻辑上）被所有广播接收者无需等待的接收到。<br><strong>优点：</strong>消息传递的效率比较高。<br><strong>缺点：</strong>1.接收者不能修改该广播。2.无法终止广播Intent的传播，即无法阻止其他接收者的接收动作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"One"</span>);</div><div class="line">intent.putExtra(<span class="string">"msg"</span>, <span class="string">"这是一条普通广播"</span>);</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure></p>
<p><strong>2.有序广播：</strong>通过Context.sendOrderedBroadcast(intent, receiverPermission)发送，是按照接收者声明的优先级别，被接收者依次接收广播。<br><strong>优点：</strong>1、广播可以通过接收者调用abortBroadcast()方法截断广播（被截断的广播不能再继续传递该广播）。2、接收者能修改处理结果（比如通过传递Bundle）传递给下一个接收者（一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播）。<br><strong>缺点：</strong>消息传递的效率比普通广播低。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent2 = <span class="keyword">new</span> Intent(<span class="string">"Two"</span>);</div><div class="line">intent2.putExtra(<span class="string">"msg"</span>, <span class="string">"这是一条有序广播"</span>);</div><div class="line">sendOrderedBroadcast(intent2, <span class="keyword">null</span>);</div></pre></td></tr></table></figure></p>
<p><strong>3.系统广播：</strong>只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开机启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，由系统自动发出。<strong><em>详见文章末尾附录</em></strong><br><strong>4.异步广播：</strong>通过mContext.sendStickyBroadcast(intent)发送，此广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。其他功能与sendBroadcast相同。但是使用sendStickyBroadcast 发送广播需要获得BROADCAST_STICKY permission，如果没有这个permission则会抛出异常。<br><strong>优点：</strong>广播先发送，接收者后注册依然能收到广播。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent3 = <span class="keyword">new</span> Intent(<span class="string">"Three"</span>);</div><div class="line">intent3.putExtra(<span class="string">"msg"</span>, <span class="string">"这是一条异步广播"</span>);</div><div class="line">sendStickyBroadcast(intent3);</div></pre></td></tr></table></figure></p>
<h1 id="广播接收者"><a href="#广播接收者" class="headerlink" title="广播接收者"></a><center>广播接收者</center></h1><h2 id="广播接收者定义"><a href="#广播接收者定义" class="headerlink" title="广播接收者定义"></a>广播接收者定义</h2><p>BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播，且可以做出相关操作。</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><p><strong>第一步：</strong>定义广播接收者，继承BroadcastReceiver，并重写onReceive()方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyReceiver01</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;  </div><div class="line">		<span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Contextcontext, Intentintent)</span> </span>&#123;  </div><div class="line">				<span class="comment">//abortBroadcast();//接到的广播为有序的广播则可截断</span></div><div class="line">				String s = intent.getStringExtra(<span class="string">"msg"</span>);</div><div class="line">	    System.out.println(<span class="string">"MyReceiver01收到消息："</span>+s);</div><div class="line">		&#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>【关于接收的广播类型的说明】</strong></p>
<ul>
<li><strong>接收的广播为普通广播：</strong><br>1、不可以在onReceive里面截断广播，否则会打印异常。<br>2、不可以处理广播。</li>
<li><strong>接收的广播为有序广播：</strong><br>1、可以在onReceive里面通过abortBroadcast()截断广播，使广播不再传播。<br>2、可以在onReceive里面接收广播Intent携带的数据（String字符串、Bundle对象、或者实现Serializable接口、Parcelable接口的Object对象）。<br>3、可向低优先级接收者传递新的数据，如下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//我是高优先级接收者</span></div><div class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Contextcontext, Intentintent)</span> </span>&#123;  </div><div class="line">				Bundle bundle = <span class="keyword">new</span> Bundle();  </div><div class="line">				bundle.putString(<span class="string">"next_receiver"</span>, <span class="string">"下一个广播接收者"</span>);  </div><div class="line">				setResultExtras(bundle);</div><div class="line">	&#125;  </div><div class="line"><span class="comment">//我是低优先级接收者</span></div><div class="line"><span class="meta">@Override</span>  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </div><div class="line">				Bundle bundle = getResultExtras(<span class="keyword">true</span>);  </div><div class="line">				String content = bundle.getString(<span class="string">"next_receiver"</span>); </div><div class="line">		&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>第二步：</strong>注册感兴趣的广播Intent，注册方法有两种：<br><strong>1、动态注册</strong>（在onCreate代码中进行注册）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(<span class="string">"感兴趣的广播名、例如上面发送的有序广播：Two"</span>);  </div><div class="line">MyReceiver01  receiver = <span class="keyword">new</span> MyReceiver01();  </div><div class="line">intentfilter.setPriority(<span class="number">200</span>);<span class="comment">//设置优先级</span></div><div class="line">registerReceiver(receiver, filter);</div></pre></td></tr></table></figure></p>
<p><strong>2、静态注册</strong>（在AndroidManifest.xml配置文件中注册）。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--prioritys设置优先级--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">receiver</span> <span class="attr">android:name</span>=<span class="string">". MyReceiver01"</span>&gt;</span>  </div><div class="line">	 <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"100"</span>&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"感兴趣的广播名、例如上面发送的有序广播：Two"</span>/&gt;</span>  </div><div class="line">	 <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><strong>【关于优先级别的说明】</strong></p>
<ul>
<li><strong> 设置方法</strong>（如上面注册代码所示）：<br><strong>1.静态设置：</strong>声明在静态注册的广播接收者的intent-filter元素的android:priority属性中。<br><strong>2.动态设置：</strong>调用IntentFilter对象的setPriority()进行声明。</li>
<li><strong>特别说明</strong><br><strong>1.</strong>静态注册时设置优先级。数越大优先级别越高,取值范围:-1000到1000。就会先接受到消息。<br><strong>2.</strong>动态注册优先级高于任何静态注册。<br><strong>3.</strong>如果动态注册和静态注册都有注册，则会执行两次onReceive。<br><strong>4.</strong>同级别的接收顺序是随机的。<br><strong>【关于动、静态注册方式特别说明】</strong></li>
<li><strong>静态注册广播：</strong>又叫常驻型广播，当你的应用程序关闭了，如果有广播信息来，你写的广播接收器同样的能接受到，他的注册方式就是在你的应用程序中的AndroidManifast.xml进行订阅的。</li>
<li><p><strong>动态注册广播：</strong>又叫非常驻型广播，当应用程序结束了，广播自然就没有了，比如你在Activity中的onCreate或者onResume中订阅广播，同时你必须在onDestory或者onPause中取消广播订阅。不然会报异常，这样你的广播接收器就一个非常驻型的了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		<span class="comment">//动态注册BC2 接收者</span></div><div class="line">		IntentFilter intentfilter = <span class="keyword">new</span> IntentFilter(<span class="string">"One"</span>);</div><div class="line">		BC2 bc2 = <span class="keyword">new</span> BC2();</div><div class="line">		registerReceiver(bc2, intentfilter);</div><div class="line">	&#125;<span class="comment">//必须在onDestory取消广播订阅</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		unregisterReceiver(bc2);</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
</li>
<li><p><strong>注意：</strong><br>1、动态注册的时候使用的是隐式Intent方式，所以在发送广播的时候需要使用隐式Intent去发送，不然是广播接收者是接收不到广播。<br>2、静态注册的时候，因为在AndroidMainfest.xml中订阅的，所以在发送广播的时候使用显示Intent和隐式Intent都可以<br><strong><em>所以以防万一，我们一般都采用隐式Intent去发送广播。</em></strong><br>3、对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext；<br>4、对于动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context；</p>
<h2 id="生命周期。"><a href="#生命周期。" class="headerlink" title="生命周期。"></a>生命周期。</h2><p>它并不像 Activity 一样复杂，运行原理很简单如下图<br><img src="http://upload-images.jianshu.io/upload_images/4821697-9d502f10fa1521ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期"></p>
</li>
<li>广播接收者生命周期<strong>只有十秒</strong>左右，如果在 onReceive() 内做超过十秒内的事情，就会报<strong>ANR(Application No Response) 程序无响应的错误信息</strong>，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 <strong>Service</strong>， 由Service 来完成 。</li>
<li>这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的</li>
</ul>
<h1 id="广播实例"><a href="#广播实例" class="headerlink" title="广播实例"></a><center>广播实例</center></h1><p><em>为了帮助大家更好的理解，以下写了一个接收系统系统电量广播并处理的小例子。</em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//第一步，定义广播接收者</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatteryChangedReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;  </div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"BatteryChangedReceiver"</span>;  </div><div class="line">	<span class="meta">@Override</span>  </div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;  </div><div class="line">			<span class="keyword">int</span> currLevel =   intent.getIntExtra(BatteryManager.EXTRA_LEVEL, <span class="number">0</span>);  <span class="comment">//当前电量  </span></div><div class="line">			<span class="keyword">int</span> total = intent.getIntExtra(BatteryManager.EXTRA_SCALE,   <span class="number">1</span>);      <span class="comment">//总电量  </span></div><div class="line">			<span class="keyword">int</span> percent = currLevel * <span class="number">100</span> / total;  </div><div class="line">			Log.i(TAG, <span class="string">"battery: "</span> + percent + <span class="string">"%"</span>);  </div><div class="line">	 &#125;  </div><div class="line">&#125;</div><div class="line"><span class="comment">//第二步，注册广播接收者</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">		setContentView(R.layout.activity_main);</div><div class="line">		<span class="comment">//动态注册电量广播接收者</span></div><div class="line">		IntentFilter intentfilter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED;);</div><div class="line">		BatteryChangedReceiver batteryChangedReceiver = <span class="keyword">new</span> BatteryChangedReceiver();</div><div class="line">		registerReceiver(bc2, intentfilter);</div><div class="line">	&#125;<span class="comment">//必须在onDestory取消广播订阅</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.onDestroy();</div><div class="line">		unregisterReceiver(batteryChangedReceiver);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a><center>【附录】</center></h1><ul>
<li>常见系统广播</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div></pre></td><td class="code"><pre><div class="line">//关闭或打开飞行模式时的广播</div><div class="line">Intent.ACTION_AIRPLANE_M;</div><div class="line"></div><div class="line">//充电状态，或者电池的电量发生变化;//电池的充电状态、电荷级别改变，不能通过组建声;</div><div class="line">Intent.ACTION_BATTERY_CH;</div><div class="line"></div><div class="line">//表示电池电量低</div><div class="line">Intent.ACTION_BATTERY_LO;</div><div class="line"></div><div class="line">//表示电池电量充足</div><div class="line">Intent.ACTION_BATTERY_OK;</div><div class="line"></div><div class="line">//关闭或打开飞行模式时的广播</div><div class="line">Intent.ACTION_AIRPLANE_MODE_CHANGED;</div><div class="line"></div><div class="line">//充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册</div><div class="line">Intent.ACTION_BATTERY_CHANGED;</div><div class="line"></div><div class="line">//表示电池电量低</div><div class="line">Intent.ACTION_BATTERY_LOW;</div><div class="line"></div><div class="line">//表示电池电量充足，即从电池电量低变化到饱满时会发出广播</div><div class="line">Intent.ACTION_BATTERY_OKAY;</div><div class="line"></div><div class="line">//在系统启动完成后，这个动作被广播一次（只有一次）。</div><div class="line">Intent.ACTION_BOOT_COMPLETED;</div><div class="line"></div><div class="line">//按下照相时的拍照按键(硬件按键)时发出的广播</div><div class="line">Intent.ACTION_CAMERA_BUTTON;</div><div class="line"></div><div class="line">//当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息</div><div class="line">Intent.ACTION_CLOSE_SYSTEM_DIALOGS;</div><div class="line"></div><div class="line">//设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java)</div><div class="line">Intent.ACTION_CONFIGURATION_CHANGED;</div><div class="line"></div><div class="line">//设备日期发生改变时会发出此广播</div><div class="line">Intent.ACTION_DATE_CHANGED;</div><div class="line"></div><div class="line">//设备内存不足时发出的广播,此广播只能由系统使用，其它APP不可用</div><div class="line">Intent.ACTION_DEVICE_STORAGE_LOW;</div><div class="line"></div><div class="line">//设备内存从不足到充足时发出的广播,此广播只能由系统使用，其它APP不可用</div><div class="line">Intent.ACTION_DEVICE_STORAGE_OK;</div><div class="line"></div><div class="line">//发出此广播的地方frameworks\base\services\java\com\android\server\DockObserver.java</div><div class="line">Intent.ACTION_DOCK_EVENT;</div><div class="line"></div><div class="line">//移动APP完成之后，发出的广播(移动是指:APP2SD)</div><div class="line">Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE;</div><div class="line"></div><div class="line">//正在移动APP时，发出的广播(移动是指:APP2SD)</div><div class="line">Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;</div><div class="line"></div><div class="line">//Gtalk已建立连接时发出的广播</div><div class="line">Intent.ACTION_GTALK_SERVICE_CONNECTED;</div><div class="line"></div><div class="line">//Gtalk已断开连接时发出的广播</div><div class="line">Intent.ACTION_GTALK_SERVICE_DISCONNECTED;</div><div class="line"></div><div class="line">//在耳机口上插入耳机时发出的广播</div><div class="line">Intent.ACTION_HEADSET_PLUG;</div><div class="line"></div><div class="line">//改变输入法时发出的广播</div><div class="line">Intent.ACTION_INPUT_METHOD_CHANGED;</div><div class="line"></div><div class="line">//设备当前区域设置已更改时发出的广播</div><div class="line">Intent.ACTION_LOCALE_CHANGED;</div><div class="line"></div><div class="line">//表示用户和包管理所承认的低内存状态通知应该开始。</div><div class="line">Intent.ACTION_MANAGE_PACKAGE_STORAGE;</div><div class="line"></div><div class="line">//未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播 ,扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)</div><div class="line">Intent.ACTION_MEDIA_BAD_REMOVAL;</div><div class="line"></div><div class="line">//按下"Media Button" 按键时发出的广播,假如有"Media Button" 按键的话(硬件按键)</div><div class="line">Intent.ACTION_MEDIA_BUTTON;</div><div class="line"></div><div class="line">//插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播?</div><div class="line">Intent.ACTION_MEDIA_CHECKING;</div><div class="line"></div><div class="line">//已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播, 用户想要移除扩展介质（拔掉扩展卡）。</div><div class="line">Intent.ACTION_MEDIA_EJECT;</div><div class="line"></div><div class="line">//插入SD卡并且已正确安装（识别）时发出的广播, 扩展介质被插入，而且已经被挂载。</div><div class="line">Intent.ACTION_MEDIA_MOUNTED;</div><div class="line"></div><div class="line">//拓展介质存在，但使用不兼容FS（或为空）的路径安装点检查介质包含在Intent.mData领域。</div><div class="line">Intent.ACTION_MEDIA_NOFS;</div><div class="line"></div><div class="line">//外部储存设备已被移除，不管有没正确卸载,都会发出此广播， 扩展介质被移除。</div><div class="line">Intent.ACTION_MEDIA_REMOVED;</div><div class="line"></div><div class="line">//广播：已经扫描完介质的一个目录</div><div class="line">Intent.ACTION_MEDIA_SCANNER_FINISHED;</div><div class="line"></div><div class="line">//请求媒体扫描仪扫描文件并将其添加到媒体数据库。</div><div class="line">Intent.ACTION_MEDIA_SCANNER_SCAN_FILE;</div><div class="line"></div><div class="line">//广播：开始扫描介质的一个目录</div><div class="line">Intent.ACTION_MEDIA_SCANNER_STARTED;</div><div class="line"></div><div class="line">// 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。</div><div class="line">Intent.ACTION_MEDIA_SHARED;</div><div class="line"></div><div class="line">Intent.ACTION_MEDIA_UNMOUNTABLE;//</div><div class="line"></div><div class="line">// 广播：扩展介质存在，但是还没有被挂载 (mount)</div><div class="line">Intent.ACTION_MEDIA_UNMOUNTED</div><div class="line"></div><div class="line">Intent.ACTION_NEW_OUTGOING_CALL;</div><div class="line"></div><div class="line">//成功的安装APK之后//广播：设备上新安装了一个应用程序包。//一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_ADDED;</div><div class="line"></div><div class="line">//一个已存在的应用程序包已经改变，包括包名</div><div class="line">Intent.ACTION_PACKAGE_CHANGED;</div><div class="line"></div><div class="line">//清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?)//用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_DATA_CLEARED;</div><div class="line"></div><div class="line">//触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？</div><div class="line">Intent.ACTION_PACKAGE_INSTALL;</div><div class="line"></div><div class="line">//成功的删除某个APK之后发出的广播, 一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_REMOVED;</div><div class="line"></div><div class="line">//替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？）</div><div class="line">Intent.ACTION_PACKAGE_REPLACED;</div><div class="line"></div><div class="line">//用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播）</div><div class="line">Intent.ACTION_PACKAGE_RESTARTED;</div><div class="line"></div><div class="line">//插上外部电源时发出的广播</div><div class="line">Intent.ACTION_POWER_CONNECTED;</div><div class="line"></div><div class="line">//已断开外部电源连接时发出的广播</div><div class="line">Intent.ACTION_POWER_DISCONNECTED;</div><div class="line"></div><div class="line">Intent.ACTION_PROVIDER_CHANGED;//</div><div class="line"></div><div class="line">//重启设备时的广播</div><div class="line">Intent.ACTION_REBOOT;</div><div class="line"></div><div class="line">//屏幕被关闭之后的广播</div><div class="line">Intent.ACTION_SCREEN_OFF;</div><div class="line"></div><div class="line">//屏幕被打开之后的广播</div><div class="line">Intent.ACTION_SCREEN_ON;</div><div class="line"></div><div class="line">//关闭系统时发出的广播</div><div class="line">Intent.ACTION_SHUTDOWN;</div><div class="line"></div><div class="line">//时区发生改变时发出的广播</div><div class="line">Intent.ACTION_TIMEZONE_CHANGED;</div><div class="line"></div><div class="line">//时间被设置时发出的广播</div><div class="line">Intent.ACTION_TIME_CHANGED;</div><div class="line"></div><div class="line">//广播：当前时间已经变化（正常的时间流逝）， 当前时间改变，每分钟都发送，不能通过组件声明来接收</div><div class="line">，只有通过Context.registerReceiver()方法来注册</div><div class="line">Intent.ACTION_TIME_TICK;</div><div class="line"></div><div class="line">//一个用户ID已经从系统中移除发出的广播</div><div class="line">Intent.ACTION_UID_REMOVED;</div><div class="line"></div><div class="line">//设备已进入USB大容量储存状态时发出的广播？</div><div class="line">Intent.ACTION_UMS_CONNECTED;</div><div class="line"></div><div class="line">//设备已从USB大容量储存状态转为正常状态时发出的广播？</div><div class="line">Intent.ACTION_UMS_DISCONNECTED;</div><div class="line"></div><div class="line">Intent.ACTION_USER_PRESENT;//</div><div class="line"></div><div class="line">//设备墙纸已改变时发出的广播</div><div class="line">Intent.ACTION_WALLPAPER_CHANGED;</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/05/02/Receiver/main.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android实习生 —— 四大组件之Activity</title>
    <link href="https://jaykuzzi.github.io/2016/04/24/Activity/"/>
    <id>https://jaykuzzi.github.io/2016/04/24/Activity/</id>
    <published>2016-04-24T07:35:36.000Z</published>
    <updated>2017-06-26T12:15:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2016/04/24/Activity/activity.jpeg" alt=""><br><a id="more"></a></p>
<h1 id="基础知识回顾"><a href="#基础知识回顾" class="headerlink" title="基础知识回顾"></a><center>基础知识回顾</center></h1><h2 id="定义及功能"><a href="#定义及功能" class="headerlink" title="定义及功能"></a>定义及功能</h2><p>  一个Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务，例如拨号、拍照、发送email、看地图。每一个activity被给予一个窗口，在上面可以绘制用户接口。窗口通常充满屏幕，但也可以小于屏幕而浮于其它窗口之上。</p>
<h2 id="启动和栈"><a href="#启动和栈" class="headerlink" title="启动和栈"></a>启动和栈</h2><p>  一个应用程序通常由多个activities组成，他们通常是松耦合关系。通常，一个应用程序中的activity被指定为”main”activity，当第一次启动应用程序的时候呈现给用户的那个activity。每一个activity然后可以启动另一个activity为了完成不同的动作。每一次一个activity启动，前一个activity就停止了，但是系统保留activity在一个栈上（“back stack”）。当一个新activity启动，它被推送到栈顶，取得用户焦点。Back Stack符合简单“后进先出”原则，所以，当用户完成当前activity然后点击back按钮，它被弹出栈（并且被摧毁），然后之前的activity恢复。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>  基本用法：Activity的本质是一个Java类，如：由我们创建工程生成的MainActivity；一般的每个Activity都会存在一个与它匹配的布局文件（xml文件），由它来写入我们需要Activity展示的各种控件和布局。有了布局文件之后，就需要在类里通过OnCreate方法的setContentView方法调用文件资源ID来初始化UI界面和显示。</p>
<h2 id="创建和注册"><a href="#创建和注册" class="headerlink" title="创建和注册"></a>创建和注册</h2><p>  每个需要显示的Activity都需要我们在工程包下的AndroidMainifest.xml文件进行注册！（注意：程序每次打开时显示的Activity我们称为主界面，它的注册和其他Activity注册有区别）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--主Activity--&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">activity</span>  </span></div><div class="line"><span class="attr">Android:name</span>=<span class="string">”.MainActivity”</span>&gt;  </div><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">”android.intent.action.MAIN”/</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">”android.intent.category.LAUNCHER”/</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>主界面显示的Activity加入了<intent-filter>标签和内部的两句声明，这也是必须的。</intent-filter></p>
<p><action>元素指定这是一个”main”入口点对这个应用程序。<category>元素指定，这个activity应该被列入系统应用程序列表中（为了允许用户启动这个activity）。<br>此外如果你的应用程序里没有声明任何主活动，它也是可以安装的，只是你无法在启动器中看见或打开，这种程序一般作为第三方服务供其他应用在内部进行调用，如支付宝的快捷支付应用。</category></action></p>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a><center>生命周期</center></h1><h2 id="四种状态"><a href="#四种状态" class="headerlink" title="四种状态"></a>四种状态</h2><blockquote>
<p><strong>运行状态：</strong>当Activity位于栈顶时，此时正好处于屏幕最前方。<br><strong>暂停状态：</strong>当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕）。<br><strong>停止状态：</strong>当Activity被其他Activity完全遮挡，此时此Activity对用户不可见。<br><strong>销毁状态：</strong>当Activity由于人为或系统原因（如低内存等）被销毁。</p>
<h2 id="七个回调方法"><a href="#七个回调方法" class="headerlink" title="七个回调方法"></a>七个回调方法</h2><p><strong>1.onCreate：</strong>活动第一次创建被调用。<br><strong>2.onStart：</strong>活动由不可见变为可见的时候调用。<br><strong>3.onResume：</strong>活动处于与用户交互状态时候调用。<br><strong>4.onPause：</strong>活动失去焦点时被调用。<br><strong>5.onStop：</strong>活动完全不可见的时候调用（如果新活动是一个对话框式活着半透明的活动，onPause会执行，而onStop不会执行）。<br><strong>6.onDestroy：</strong>在活动被销毁之前调用。<br><strong>7.onRestart：</strong>由停止状态变为运行状态之前调用。</p>
<h2 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h2><p>  <img src="http://upload-images.jianshu.io/upload_images/4821697-b23eea06a1d111e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="生命周期图"></p>
</blockquote>
<h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>  <em>在实际应用场景中，假设A Activity位于栈顶，此时用户操作，从A Activity跳转到B Activity。那么对AB来说，具体会回调哪些生命周期中的方法呢？回调方法的具体回调顺序又是怎么样的呢？</em><br>  开始时，A被实例化，执行的回调有<strong>A:onCreate -&gt; A:onStart -&gt; A:onResume。</strong><br>  当用户点击A中按钮来到B时，假设B全部遮挡住了A，将依次执行<strong>A:onPause -&gt; B:onCreate -&gt; B:onStart -&gt; B:onResume -&gt; A:onStop。</strong><br>  此时如果点击Back键，将依次执行<strong>B:onPause -&gt; A:onRestart -&gt; A:onStart -&gt; A:onResume -&gt; B:onStop -&gt; B:onDestroy。</strong><br>  <em>至此，Activity栈中只有A。在Android中，有两个按键在影响Activity生命周期这块需要格外区分下，即Back键和Home键。我们先直接看下实验结果：</em><br>  此时如果按下Back键，系统返回到桌面，并依次执行<strong>A:onPause -&gt; A:onStop -&gt; A:onDestroy。</strong><br>  此时如果按下Home键（非长按），系统返回到桌面，并依次执行<strong>A:onPause -&gt; A:onStop。</strong>由此可见，Back键和Home键主要区别在于是否会执行onDestroy。</p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>  不少应用程序都是采取如Home键的效果，当点击了Back键，系统返回到桌面，然后点击应用程序图标，直接回到之前的Activity界面，这种效果是怎么实现的呢？<br>  通过重写按下Back键的回调函数，转成Home键的效果即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</div><div class="line">		Intent home = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</div><div class="line">		home.addCategory(Intent.CATEGORY_HOME);</div><div class="line">		startActivity(home);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，此种方式通过Home键效果强行影响到Back键对Activity生命周期的影响。注意，此方法只是针对按Back键需要退回到桌面时的Activity且达到Home效果才重写。<br>或者，为达到此类效果，Activity实际上提供了直接的方法。<br><code>activity.moveTaskToBack(true);</code><br>moveTaskToBack()此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态。</p>
<h1 id="Activity跳转"><a href="#Activity跳转" class="headerlink" title="Activity跳转"></a><center>Activity跳转</center></h1><h2 id="startActivity-。"><a href="#startActivity-。" class="headerlink" title="startActivity()。"></a>startActivity()。</h2><p>  Intent的两种用法：显示Intent和隐式Intent。<br>  （1）显示Intent一般使用方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent=newIntent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);  </div><div class="line">startActivity(intent);  </div><div class="line"><span class="comment">//简单的两行就能实现第一个活动跳转到第二个活动界面。</span></div></pre></td></tr></table></figure></p>
<p>（2）隐式Intent一般使用方法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!--首先需要在注册第二个活动时加入标签--&gt;</span></div><div class="line"><span class="comment">&lt;!-- 必须指定CATEGORY_DEFAULT，只有这样startActivity(intent)才能找到 --&gt;</span>  </div><div class="line"><span class="comment">&lt;!--注意 Intent Filter顾名思义就是Intent的过滤器，组件通过定义Intent Filter可以决定哪些隐式 --&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">”.SecondAcivity”</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">”包名.ACTION_START”/</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">”android.intent.category.DEFAULT”/</span>&gt;</span>   </div><div class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>这样我们就可以用声明的标签来启动隐式Intent<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent=<span class="keyword">new</span> Intent(“包名.ACTION_START”);  </div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>（3）两者的使用区别<br> <strong>显式意图</strong>一般在应用的<strong>内部使用</strong>，因为在应用内部已经知道了组件的名称，直接调用就可以了。当一个应用要激活另一个应用中的Activity时，只能使用隐式意图，根据Activity配置的意图过滤器建一个意图，让意图中的各项参数的值都跟过滤器匹配，这样就可以激活其他应用中的Activity。所以，<strong>隐式意图是在应用与应用之间使用的。</strong></p>
<h2 id="系统意图"><a href="#系统意图" class="headerlink" title="系统意图"></a>系统意图</h2><p>  Intent可以指定你希望启动或描述完成的动作（操作系统会为你选择合适的Activity，可能来自定不同的应用程序）。<br>  你的应用程序或许希望执行一些动作，例如发送一份邮件、文件消息或者状态更新，使用你的Activity的数据。在这种情况下，你的应用程序或许没有它自己的Activity来完成这个动作，因此你可以促使设备上其它应用程序提供的Activity来完成你的动作。这才是Intent真正有价值的地方－－你可以创建一个Intent描述一个你希望执行的动作，然后系统启动一个合适的activity从其它应用程序。如果有多种Activities可以处理这个Intent，那么 用户可以选择哪一个来执行。例如，如果你希望允许用户发送邮件，你可以创建下面的Intent:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Intent intent= <span class="keyword">new</span> Intent(Intent.ACTION_SEND);</div><div class="line">				intent.putExtra(Intent.EXTRA_EMAIL,<span class="string">""</span>);</div><div class="line">				startActivity(intent);</div></pre></td></tr></table></figure></p>
<p><em>（常用意图见文章末尾附录。）</em></p>
<h2 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h2><p>  一个Intent可以传输小量数据被启动的activity使用。<br>  在启动活动时，Intent中提供了一系列putExtra()方法的重载，可以将我们需要传递的数据暂存在Intent中，在打开另一个活动时，从Intent中取出即可。<br>  具体例子：<br>  （1）比如我们想要传递一个String字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">String data=”Hello world!”;  </div><div class="line">Intent intent=newIntent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class);  </div><div class="line">Intent.putExtra(“extra_data”,data);</div><div class="line"><span class="comment">//extra_data是一个标签，data是传入的数据。 </span></div><div class="line"><span class="comment">//相当于Intent对象具有Map键值对功能。</span></div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>然后在SecondActivity的Oncreate方法里取出Intent存入的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent=getIntent();  </div><div class="line">String data=intent.getStringExtra(“extra_data”);</div><div class="line"><span class="comment">//用String接收带extra_data标签的数据  </span></div><div class="line">Log.d(“SecondActivity”,data);<span class="comment">//打印出data</span></div></pre></td></tr></table></figure></p>
<p>（2）新建一个Bundle对象 ，想该对象中加入键值对，然后将该对象加入Intent中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Intent intent=<span class="keyword">new</span> Intent();</div><div class="line">Bundle bundle = <span class="keyword">new</span> Bundle();  </div><div class="line">bundle.putString(<span class="string">"first"</span>, <span class="string">"zhang"</span>);  </div><div class="line">bundle.putInt(<span class="string">"age"</span>, <span class="number">20</span>);  </div><div class="line">intent.putExtras(bundle);  </div><div class="line">intent.setClass(ActivityMain.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">intent.putExtras(bundle);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>然后在第二个Activity中接收<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line"> bundle = <span class="keyword">this</span>.getIntent().getExtras();</div><div class="line">String a = bundle.getString(<span class="string">"first"</span>);</div><div class="line"><span class="keyword">int</span> b = Integer.parseInt(bundle.getString(<span class="string">"age"</span>));</div></pre></td></tr></table></figure></p>
<p>（3）Intent传递Object对象</p>
<p> Android中Intent传递类对象提供了两种方式一种是 通过实现<strong>Serializable接口</strong>传递对象，一种是通过实现<strong>Parcelable接口</strong>传递对象。要求被传递的对象必须实现上述2种接口中的一种才能通过Intent直接传递。Intent中传递这2种对象的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bundle.putSerializable(Key,Object);  <span class="comment">//实现Serializable接口的对象</span></div><div class="line">Bundle.putParcelable(Key, Object); <span class="comment">//实现Parcelable接口的对象</span></div></pre></td></tr></table></figure></p>
<p>以下以最常用的Serializable方式为例 ：</p>
<pre><code>假设由登录界面（Login）跳转到主界面（MainActivity）传递的对象为登录的用户信息 User类

首先创建一个序列化类：User
</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">		<span class="keyword">import</span> java.io.Serializable;</div><div class="line">		<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">int</span> ID;</div><div class="line">		<span class="keyword">private</span> String UserName;    </div><div class="line">		<span class="keyword">private</span> String PWD;    </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setID</span><span class="params">(<span class="keyword">int</span> value)</span></span></div><div class="line">		&#123;</div><div class="line">				ID = value;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getID</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">				<span class="keyword">return</span> ID;</div><div class="line">		&#125;    </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String value)</span></span></div><div class="line">		&#123;</div><div class="line">				UserName = value;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getUserName</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">				<span class="keyword">return</span> UserName;</div><div class="line">		&#125;  </div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPWD</span><span class="params">(String value)</span></span></div><div class="line">		&#123;</div><div class="line">				PWD = value;</div><div class="line">		&#125;</div><div class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">getPWD</span><span class="params">()</span></span></div><div class="line">		&#123;</div><div class="line">				<span class="keyword">return</span> PWD;</div><div class="line">		&#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MainActivity传递内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">intent.setClass(MainActivity.<span class="keyword">this</span>, SecondActivity.class);</div><div class="line">Bundle bundle = <span class="keyword">new</span> Bundle();</div><div class="line">bundle.putSerializable(<span class="string">"user"</span>, user);</div><div class="line">intent.putExtras(bundle);</div><div class="line"><span class="keyword">this</span>.startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>SecondActivity接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">this</span>.getIntent(); </div><div class="line">user=(User)intent.getSerializableExtra(<span class="string">"user"</span>);</div></pre></td></tr></table></figure></p>
<p>以上就可以实现对象的传递。<br>补充：<br>如果传递的是List<object>,可以把list强转成Serializable类型,而且object类型也必须实现了Serializable接口<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Intent.putExtras(key, (Serializable)list)</div></pre></td></tr></table></figure></object></p>
<p>接收<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(List&lt;YourObject&gt;)getIntent().getSerializable(key)</div></pre></td></tr></table></figure></p>
<pre><code>【补充】
parcelable和Serializable的区别又是什么呢？
</code></pre><p><strong>Serializable</strong>的作用是保存对象的属性到本地文件，数据库，网络流等方便数据传输，也可程序之间传递。</p>
<pre><code>**parcelable**的设计的目的是为了解决Serializable效率不高的问题，内存开销小，所以在内存间传递数据的方式用parcelable，缺点是不能持久化。
</code></pre><h2 id="startActivityForResult"><a href="#startActivityForResult" class="headerlink" title="startActivityForResult()"></a>startActivityForResult()</h2><p>  Activity退出时返回结果至前一个Activity<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  1.通过startActivityForResult方式启动一个新Activity </span></div><div class="line">Intent intent=newIntent(FirstActivity,<span class="keyword">this</span>,SecondActivity.class);   </div><div class="line">startActivityForResult(intent, <span class="number">200</span>);  </div><div class="line"><span class="comment">//参数为intent对象， requestCode请求码</span></div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  2.新Activity设定setResult方法，通过该方法可以传递responseCode 和 Intent对象  </span></div><div class="line">Intent intent=<span class="keyword">new</span> Intent();  </div><div class="line"><span class="comment">//Intent中也可以传递Bundle</span></div><div class="line">Intent.putExtra(“data_return”,”Helloworld!”);  </div><div class="line">setResult(<span class="number">101</span>,intent);  </div><div class="line"> <span class="comment">//参数为responseCode响应码 和 intent对象  </span></div><div class="line">finish();</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//  3.在MainActivity中覆写onActivityResult方法，新Activity一旦退出，就会执行该方法  </span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123; </div><div class="line"><span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line">				<span class="comment">//如果请求标识与返回标识一样,则把数据返回到tv上</span></div><div class="line">				<span class="keyword">if</span> (requestCode == <span class="number">200</span> &amp; resultCode ==<span class="number">101</span>) &#123;</div><div class="line">						String s = data.getStringExtra(<span class="string">"data_return"</span>);</div><div class="line">						tv.setText(s);</div><div class="line">				&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="启动模式"><a href="#启动模式" class="headerlink" title="启动模式"></a><center>启动模式</center></h1><h2 id="四种启动模式"><a href="#四种启动模式" class="headerlink" title="四种启动模式"></a>四种启动模式</h2><blockquote>
<p><strong>standard（标准模式）：</strong>每当启动一个新活动，它都会进入返回栈并位于栈顶的位置，这种模式下，系统不会在乎这个活动是否已经存在于返回栈中，每次启动都会创建并都放在栈顶。</p>
<p><strong>singleTop（栈顶复用）：</strong>在启动活动时如果发现栈中该活动已经位于栈顶，则重用该实例( 会调用实例的onNewIntent() )而不会创建新的实例。若不在栈顶，则会创建新的实例。</p>
<p><strong>singleTask（栈内复用）：</strong>启动活动时如果发现栈中已经存在该活动，则重用该实例(会调用实例的 onNewIntent() )，并且将位于它之上的活动统统出栈，如果没有发现就会新建一个实例。</p>
<p><strong>singleIntance（单例模式）：</strong>会有一个单独的返回栈来管理这个活动，而且栈中只有此活动，不管是任何一个程序来访问这个活动，都共用这个返回栈，也就解决了共享活动的问题。</p>
<p>设置方法：在AndroidMainifest.xml文件中activity标签name之下加入声明：Android:launchMode=” standard、singleTop、singleTask、singleInstance(四选一)”这样就可以配置活动的启动模式了。</p>
</blockquote>
<h2 id="详解standard"><a href="#详解standard" class="headerlink" title="详解standard"></a>详解standard</h2><p>  standard模式是默认的启动模式，不用为<activity>配置android:launchMode属性即可，当然也可以指定值为standard。<br>  我们将会一个Activity，命名为FirstActivity，来演示一下标准的启动模式。FirstActivity代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">				<span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">				setContentView(R.layout.first);  </div><div class="line">				TextView textView = (TextView) findViewById(R.id.textView);  </div><div class="line">				textView.setText(<span class="keyword">this</span>.toString());  </div><div class="line">				Button button = (Button) findViewById(R.id.button);  </div><div class="line">				button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;  </div><div class="line">						<span class="meta">@Override</span>  </div><div class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">								Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, FirstActivity.class);  </div><div class="line">								startActivity(intent);  </div><div class="line">						&#125;  </div><div class="line">				&#125;);  </div><div class="line">		&#125;</div></pre></td></tr></table></figure></activity></p>
<p>我们FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。<br>然后我们连续点击几次按钮，将会出现下面的现象<br><img src="http://upload-images.jianshu.io/upload_images/4821697-6b6f54199b70cbb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FristActivity。standard模式的原理如下图所示<br><img src="http://upload-images.jianshu.io/upload_images/4821697-c316d617cee70767.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转">如图所示，<strong>每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。</strong><br>这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。</p>
<h2 id="详解singleTop"><a href="#详解singleTop" class="headerlink" title="详解singleTop"></a>详解singleTop</h2><p>  我们在上面的基础上为<activity>指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-80b9ffa6240c3466.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。singleTop模式的原理如下图所示：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-1ca377d77e50f2a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。<br>  我们再新建一个Activity命名为SecondActivity，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;  </div><div class="line">			<span class="keyword">super</span>.onCreate(savedInstanceState);  </div><div class="line">			setContentView(R.layout.second);  </div><div class="line">			TextView textView = (TextView) findViewById(R.id.textView);  </div><div class="line">			textView.setText(<span class="keyword">this</span>.toString());  </div><div class="line">			Button button = (Button) findViewById(R.id.button);  </div><div class="line">			button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;  </div><div class="line">					<span class="meta">@Override</span>  </div><div class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;  </div><div class="line">							Intent intent = <span class="keyword">new</span> Intent(SecondActivity.<span class="keyword">this</span>, FirstActivity.class);  </div><div class="line">							startActivity(intent);                </div><div class="line">					&#125;  </div><div class="line">			&#125;);  </div><div class="line">	&#125;</div></pre></td></tr></table></figure></activity></p>
<p>然后将之前的FirstActivity跳转代码改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>, SecondActivity.class);  </div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>是的，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。演示结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-eb8b909de24ed314.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。原理图如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4502b2941605c4bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们看到，<strong>当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。<br>这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。</strong></p>
<h2 id="详解singleTask"><a href="#详解singleTask" class="headerlink" title="详解singleTask"></a>详解singleTask</h2><p>  在上面的基础上我们修改FirstActivity的属性android:launchMode=”singleTask”。演示的结果如下：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-321feaa2137b2fd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。singleTask模式的原理图如下图所示：<br>  <img src="http://upload-images.jianshu.io/upload_images/4821697-44226b927c4e424c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>  在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，<strong>SecondActivity消失了</strong>，没错，在这个跳转过程中系统发现有存在的FirstActivity实例，<strong>于是不再生成新的实例，而是将FirstActivity之上的Activity实例统统出栈，将FirstActivity变为栈顶对象，显示到幕前。</strong>也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。<br>  这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。</p>
<h2 id="详解singleInstance"><a href="#详解singleInstance" class="headerlink" title="详解singleInstance"></a>详解singleInstance</h2><p>  这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。<br>  我们修改FirstActivity的launchMode=”standard”，SecondActivity的launchMode=”singleInstance”，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">TextView taskIdView = (TextView) findViewById(R.id.taskIdView);  </div><div class="line">taskIdView.setText(<span class="string">"current task id: "</span> + <span class="keyword">this</span>.getTaskId());</div></pre></td></tr></table></figure></p>
<p>然后我们再演示一下这个流程：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-4e37e0d6bc2e4353.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-65354e8b4fb44d9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。<br>如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-8322215770724b55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"><br>singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".ShareActivity"</span> <span class="attr">android:launchMode</span>=<span class="string">"singleInstance"</span>&gt;</span>  </div><div class="line">		<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span>  </div><div class="line">		<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line">		<span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span> /&gt;</span>  </div><div class="line">				<span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span>  </div><div class="line">		<span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span>  </div><div class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>然后我们在其他应用中这样启动该Activity：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.intent.action.SINGLE_INSTANCE_SHARE"</span>);  </div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure></p>
<p>当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。大家可以在ShareActivity中打印一下taskId，看看效果。关于这个过程，原理图如下：<br><img src="http://upload-images.jianshu.io/upload_images/4821697-11e34c535c48204d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="跳转"></p>
<h2 id="启动模式应用场景"><a href="#启动模式应用场景" class="headerlink" title="启动模式应用场景"></a>启动模式应用场景</h2><blockquote>
<p><strong>singleTop</strong>适合<strong>接收通知启动的内容显示页面</strong>。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。所以要从外界尽可能多的跳转到一个界面。</p>
<p><strong>singleTask</strong>适合作为程序入口点。例如<strong>浏览器的主界面、联系人activity</strong>。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。</p>
<p><strong>singleInstance</strong>适合需要与程序分离开的页面。这种模式的使用情况比较罕见，例如<strong>闹铃提醒</strong>，将闹铃提醒与闹铃设置分离。<strong>呼叫来电界面。</strong><br><em>singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，再次启动，首先打开的是B。</em></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>  LauncherMode 分为两组：<br>  <strong>第一组standard和SingleTop是一组用的比较多，他们二个唯一的区别就是SingleTop如果在当前Task的顶部，同时在startActivity()这个Activity的时候就不会再创建新的实例，而是执行该实例的onNewIntent()方法，其他情况下的用法是一样的；</strong><br>  <strong>第二组SingleTask和SingleIntance这一组用的比较少，要结合特定情况来使用，这一组的使用区别是比较大的，在我们开发APP的过程中要合理的使用Activity的启动模式来使我们的APP更加的快捷，流畅，提高用户体验。如果有写的不好的还忘指点。</strong></p>
<h1 id="其他补充"><a href="#其他补充" class="headerlink" title="其他补充"></a><center>其他补充</center></h1><h2 id="Activity中finish-onDestroy-和System-exit-的区别"><a href="#Activity中finish-onDestroy-和System-exit-的区别" class="headerlink" title="Activity中finish() onDestroy() 和System.exit()的区别"></a>Activity中finish() onDestroy() 和System.exit()的区别</h2><blockquote>
<p><strong>Activity.finish()</strong><br>Call this when your activity is done and should be closed.<br>在你的activity动作完成的时候，或者Activity需要关闭的时候，调用此方法。当你调用此方法的时候，<em>系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory()方法</em>，<strong>其占用的资源也没有被及时释放。</strong>因为移出了栈，所以当你点击手机上面的“back”按键的时候，也不会再找到这个Activity。</p>
<p><strong>Activity.onDestory()</strong><br>the system is temporarily destroying this instance of the activity to save space.<br>系统销毁了这个Activity的实例在内存中占据的空间。<br>在Activity的生命周期中，onDestory()方法是他生命的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法。</p>
<p><strong>System.exit(0)</strong><br>这玩意是退出整个应用程序的，是针对整个Application的。将整个进程直接KO掉。</p>
<p><strong>finish函数仅仅把当前Activity退出了，但是并没有释放他的资源。安卓系统自己决定何时从内存中释放应用程序。当系统没有可用内存到时候，会按照优先级，释放部分应用。</strong></p>
</blockquote>
<h2 id="AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别"><a href="#AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别" class="headerlink" title="AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别"></a>AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别</h2><blockquote>
<p>support v4 FragmentActivity  兼容2.x模式下使用Fragment<br>support v7 AppCompatActivity 兼容2.x模式下使用Fragment和ActionBar，ActionBarActivity是AppCompatActivity过时产品<br>如果3.0以上直接继承Activity，便可使用Fragment和ActionBar</p>
</blockquote>
<h2 id="资源内存不足导致低优先级Activity被杀死"><a href="#资源内存不足导致低优先级Activity被杀死" class="headerlink" title="资源内存不足导致低优先级Activity被杀死"></a>资源内存不足导致低优先级Activity被杀死</h2><blockquote>
<p>Activity优先级<br>前台Activity——正在和用户交互的Activity，优先级最高<br>可见但非前台Activity——Activity中弹出的对话框导致Activity可见但无法交互<br>后台Activity——已经被暂停的Activity，优先级最低<br>系统内存不足是，会按照以上顺序杀死Activity，并通过onSaveInstanceState和onRestoreInstanceState这两个方法来存储和恢复数据。</p>
</blockquote>
<h2 id="ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。"><a href="#ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。" class="headerlink" title="ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。"></a>ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE) ;    </div><div class="line">//获得系统运行的进程  </div><div class="line">List&lt;ActivityManager.RunningAppProcessInfo&gt; appList1 = mActivityManager  </div><div class="line">				.getRunningAppProcesses();  </div><div class="line">for (RunningAppProcessInfo running : appList1) &#123;  </div><div class="line">		System.out.println(running.processName);  </div><div class="line">&#125;  </div><div class="line">System.out.println(&quot;================&quot;);  </div><div class="line">//获得当前正在运行的service  </div><div class="line">List&lt;ActivityManager.RunningServiceInfo&gt; appList2 = mActivityManager  </div><div class="line">				.getRunningServices(100);  </div><div class="line">for (ActivityManager.RunningServiceInfo running : appList2) &#123;  </div><div class="line">		System.out.println(running.service.getClassName());  </div><div class="line">&#125;  </div><div class="line">System.out.println(&quot;================&quot;);  </div><div class="line">//获得当前正在运行的activity  </div><div class="line">List&lt;ActivityManager.RunningTaskInfo&gt; appList3 = mActivityManager  </div><div class="line">				.getRunningTasks(1000);  </div><div class="line">for (ActivityManager.RunningTaskInfo running : appList3) &#123;  </div><div class="line">		System.out.println(running.baseActivity.getClassName());  </div><div class="line">&#125;  </div><div class="line">System.out.println(&quot;================&quot;);  </div><div class="line">//获得最近运行的应用  </div><div class="line">List&lt;ActivityManager.RecentTaskInfo&gt; appList4 = mActivityManager  </div><div class="line">				.getRecentTasks(100, 1);  </div><div class="line">for (ActivityManager.RecentTaskInfo running : appList4) &#123;  </div><div class="line">		System.out.println(running.origActivity.getClassName());  </div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<h1 id="【附录】"><a href="#【附录】" class="headerlink" title="【附录】"></a><center>【附录】</center></h1><ul>
<li>常用Intent意图表</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//(1).调用拨号程序</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"tel:10086"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DIAL, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(2).发送短信或者彩信</span></div><div class="line"><span class="comment">//发生短信</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"smsto:10086"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, uri); </div><div class="line">intent.putExtra(<span class="string">"sms_body"</span>, <span class="string">"Hello"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//发送彩信，相当于发送带附件的短信</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND); </div><div class="line">intent.putExtra(<span class="string">"sms_body"</span>, <span class="string">"Hello"</span>); </div><div class="line">Uri uri = Uri.parse(<span class="string">"content://media/external/images/media/23"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_STREAM, uri); </div><div class="line">intent.setType(<span class="string">"image/png"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(3).通过浏览器打开网页</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"http://www.google.com"</span>); </div><div class="line">Intent intent  = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent);</div><div class="line"><span class="comment">//(4).发送电子邮件</span></div><div class="line">Uri uri = Uri.parse(<span class="string">"mailto:someone@domain.com"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SENDTO, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//给someone@domain.com发邮件发送内容为“Hello”的邮件 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_SEND); </div><div class="line">intent.putExtra(Intent.EXTRA_EMAIL, <span class="string">"someone@domain.com"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"Subject"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"Hello"</span>); </div><div class="line">intent.setType(<span class="string">"text/plain"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">// 给多人发邮件 </span></div><div class="line">Intent intent=<span class="keyword">new</span> Intent(Intent.ACTION_SEND); </div><div class="line">String[] tos = &#123;<span class="string">"1@abc.com"</span>, <span class="string">"2@abc.com"</span>&#125;; <span class="comment">// 收件人 </span></div><div class="line">String[] ccs = &#123;<span class="string">"3@abc.com"</span>, <span class="string">"4@abc.com"</span>&#125;; <span class="comment">// 抄送 </span></div><div class="line">String[] bccs = &#123;<span class="string">"5@abc.com"</span>, <span class="string">"6@abc.com"</span>&#125;; <span class="comment">// 密送 </span></div><div class="line">intent.putExtra(Intent.EXTRA_EMAIL, tos); </div><div class="line">intent.putExtra(Intent.EXTRA_CC, ccs); </div><div class="line">intent.putExtra(Intent.EXTRA_BCC, bccs); </div><div class="line">intent.putExtra(Intent.EXTRA_SUBJECT, <span class="string">"Subject"</span>); </div><div class="line">intent.putExtra(Intent.EXTRA_TEXT, <span class="string">"Hello"</span>); </div><div class="line">intent.setType(<span class="string">"message/rfc822"</span>); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(5).显示地图与路径规划</span></div><div class="line"><span class="comment">// 打开Google地图中国北京位置（北纬39.9，东经116.3） </span></div><div class="line">Uri uri = Uri.parse(<span class="string">"geo:39.9,116.3"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">// 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4） </span></div><div class="line">Uri uri = Uri.parse(<span class="string">"http://maps.google.com/maps?f=d&amp;saddr=39.9 116.3&amp;daddr=31.2 121.4"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(6).播放多媒体</span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW); </div><div class="line">Uri uri = Uri.parse(<span class="string">"file:///sdcard/foo.mp3"</span>); </div><div class="line">intent.setDataAndType(uri, <span class="string">"audio/mp3"</span>); </div><div class="line">startActivity(intent); </div><div class="line">Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, <span class="string">"1"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(7).拍照</span></div><div class="line"><span class="comment">// 打开拍照程序 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);  </div><div class="line">startActivityForResult(intent, <span class="number">0</span>); </div><div class="line"><span class="comment">// 取出照片数据 </span></div><div class="line">Bundle extras = intent.getExtras();  </div><div class="line">Bitmap bitmap = (Bitmap) extras.get(<span class="string">"data"</span>); </div><div class="line"><span class="comment">//(8).获取并剪切图片</span></div><div class="line"><span class="comment">// 获取并剪切图片 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT); </div><div class="line">intent.setType(<span class="string">"image/*"</span>); </div><div class="line">intent.putExtra(<span class="string">"crop"</span>, <span class="string">"true"</span>); <span class="comment">// 开启剪切 </span></div><div class="line">intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">1</span>); <span class="comment">// 剪切的宽高比为1：2 </span></div><div class="line">intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">2</span>); </div><div class="line">intent.putExtra(<span class="string">"outputX"</span>, <span class="number">20</span>); <span class="comment">// 保存图片的宽和高 </span></div><div class="line">intent.putExtra(<span class="string">"outputY"</span>, <span class="number">40</span>);  </div><div class="line">intent.putExtra(<span class="string">"output"</span>, Uri.fromFile(<span class="keyword">new</span> File(<span class="string">"/mnt/sdcard/temp"</span>))); <span class="comment">// 保存路径 </span></div><div class="line">intent.putExtra(<span class="string">"outputFormat"</span>, <span class="string">"JPEG"</span>);<span class="comment">// 返回格式 </span></div><div class="line">startActivityForResult(intent, <span class="number">0</span>); </div><div class="line"><span class="comment">// 剪切特定图片 </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.android.camera.action.CROP"</span>);  </div><div class="line">intent.setClassName(<span class="string">"com.android.camera"</span>, <span class="string">"com.android.camera.CropImage"</span>);  </div><div class="line">intent.setData(Uri.fromFile(<span class="keyword">new</span> File(<span class="string">"/mnt/sdcard/temp"</span>)));  </div><div class="line">intent.putExtra(<span class="string">"outputX"</span>, <span class="number">1</span>); <span class="comment">// 剪切的宽高比为1：2 </span></div><div class="line">intent.putExtra(<span class="string">"outputY"</span>, <span class="number">2</span>); </div><div class="line">intent.putExtra(<span class="string">"aspectX"</span>, <span class="number">20</span>); <span class="comment">// 保存图片的宽和高 </span></div><div class="line">intent.putExtra(<span class="string">"aspectY"</span>, <span class="number">40</span>); </div><div class="line">intent.putExtra(<span class="string">"scale"</span>, <span class="keyword">true</span>); </div><div class="line">intent.putExtra(<span class="string">"noFaceDetection"</span>, <span class="keyword">true</span>);  </div><div class="line">intent.putExtra(<span class="string">"output"</span>, Uri.parse(<span class="string">"file:///mnt/sdcard/temp"</span>));  </div><div class="line">startActivityForResult(intent, <span class="number">0</span>); </div><div class="line"><span class="comment">//(9).打开Google Market</span></div><div class="line"><span class="comment">// 打开Google Market直接进入该程序的详细页面 </span></div><div class="line">Uri uri = Uri.parse(<span class="string">"market://details?id="</span> + <span class="string">"com.demo.app"</span>); </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, uri); </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(10).安装和卸载程序</span></div><div class="line">Uri uri = Uri.fromParts(<span class="string">"package"</span>, <span class="string">"com.demo.app"</span>, <span class="keyword">null</span>);   </div><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_DELETE, uri);   </div><div class="line">startActivity(intent); </div><div class="line"><span class="comment">//(11).进入设置界面</span></div><div class="line"><span class="comment">// 进入无线网络设置界面（其它可以举一反三）   </span></div><div class="line">Intent intent = <span class="keyword">new</span> Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);</div><div class="line">startActivityForResult(intent, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>整理作者：</strong><a href="http://woobo.me" target="_blank" rel="external">汪博</a><br><strong>个人名言：</strong>少壮不努力，老大徒悲伤。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2016/04/24/Activity/activity.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://jaykuzzi.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://jaykuzzi.github.io/tags/Android/"/>
    
  </entry>
  
</feed>

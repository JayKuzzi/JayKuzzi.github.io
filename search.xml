<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Android实习生 —— 数据存储与共享]]></title>
      <url>%2F2016%2F07%2F15%2FDataStorage%2F</url>
      <content type="text"><![CDATA[前言Android提供了5种方式来让用户保存持久化应用程序数据。① 使用SharedPreferences存储数据 ② 文件存储数据③ SQLite数据库存储数据④ 使用ContentProvider存储数据⑤ 网络存储数据 我们可以根据需求选择对应的方式。文章根据相关Demo讲述各种方式的用法及优缺点说明，在文章末尾附录会有相关Demo的下载 。通过以上方式还可以实现数据的在不同app间的数据共享。 SharedPreferences1、适用范围保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口令密码等。 2、核心原理保存基于XML文件存储的key-value键值对数据。通过DDMS的File Explorer面板，展开文件浏览树,很明显SharedPreferences数据总是存储在/data/data//shared_prefs目录下。SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。SharedPreferences本身是一个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法中name表示要操作的xml文件名，第二个参数具体如下：1234567Context.MODE_PRIVATE: 指定该SharedPreferences数据只能被本应用程序读、写。Context.MODE_WORLD_READABLE: 指定该SharedPreferences数据能被其他应用程序读，但不能写。Context.MODE_WORLD_WRITEABLE: 指定该SharedPreferences数据能被其他应用程序读，写。//以上三种写法均已过时，可以直接用数字代替，//Context.MODE_PRIVATE = 0//Context.MODE_WORLD_READABLE = 1//Context.MODE_WORLD_WRITEABLE = 2 Editor有如下主要重要方法：12345678SharedPreferences.Editor clear()//清空SharedPreferences里所有数据SharedPreferences.Editor putXxx(String key , xxx value)://向SharedPreferences存入指定key对应的数据，其中xxx 可以是boolean,float,int等各种基本类型据SharedPreferences.Editor remove()//删除SharedPreferences中指定key对应的数据项boolean commit()//当Editor编辑完成后，使用该方法提交修改 3、app内部实现数据存储（Demo）通过点击“保存用户名”，对登陆成功的用户进行用户名键值对的保存，让用户下次启动app时自动填充用户名。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText userName,userPass; private CheckBox checkBox; private Button ok,cancel; private SharedPreferences pref; private SharedPreferences.Editor editor; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化SharedPreferences 及相关组建。 init(); //3、取出userInfo中的数据。 String name00=pref.getString("userName",null); if (name00==null) &#123; checkBox.setChecked(false); &#125;else &#123; checkBox.setChecked(true); //4、将取到的用户名赋给用户名编辑框。 userName.setText(name00); &#125; &#125; private void init() &#123; userName = (EditText) findViewById(R.id.userName); userPass = (EditText) findViewById(R.id.userPass); checkBox = (CheckBox) findViewById(R.id.check); ok = (Button) findViewById(R.id.join_btn); cancel = (Button) findViewById(R.id.cancel_btn); ok.setOnClickListener(this); cancel.setOnClickListener(this); //1、获取SharedPreferences对象，并把文件名设为"userInfo"。 pref =getSharedPreferences("userInfo", MODE_PRIVATE); //2、获取SharedPreferences内部接口Editor用来编辑userInfo。 editor = pref.edit(); &#125; @Override public void onClick(View v) &#123; //2.1：获取用户输入的用户名密码信息。 String name = userName.getText().toString(); String pass = userPass.getText().toString(); switch (v.getId()) &#123; case R.id.join_btn: if ("admin".equals(name)&amp;&amp;"123456".equals(pass))&#123; if(checkBox.isChecked())&#123; //2.2.1：判断成功登入并对"保存用户名"打勾之后， //将用户名的键值对添加到文件名为"userInfo"文件中并提交。 editor.putString("userName",name); editor.commit(); &#125;else&#123; //2.2.2若没打勾，则清空并提交。 editor.remove("userName"); editor.commit(); &#125; Toast.makeText(this,"登陆成功",Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(this,"登陆失败",Toast.LENGTH_SHORT).show(); &#125; break; case R.id.cancel_btn: userName.setText(null); userPass.setText(null); break; &#125; &#125; 效果登入成功第二次打开自动填充用户名。【在DDMS中依次打开data/data/&lt;包&gt;/shared_prefs，可以看到此文件内容】 4、共享其他应用的SharedPreferences在创建SharedPreferences时，指定MODE_WORLD_READABLE模式，表明该SharedPreferences数据可以被其他程序读取。1SharedPreferences pref =getSharedPreferences("userInfo", MODE_WORLD_READABLE); 创建其他应用程序对应的Context上下文引用:1234567Context otherAppContent = null; try &#123; otherAppContent = createPackageContext("com.bb.sharedpr",CONTEXT_IGNORE_SECURITY);//com.bb.sharedpr为我们要调用数据的包名 &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; 使用其他程序的Context获取对应的SharedPreferences1SharedPreferences read = otherAppContent.getSharedPreferences("userInfo",MODE_WORLD_READABLE); 如果是写入数据，使用Editor接口即可，所有其他操作均和前面一致。 5、关于android:sharedUserId通常，不同的APK会具有不同的userId，因此运行时属于不同的进程中，而不同进程中的资源是不共享的，才保障了程序运行的稳定。然后在有些时候，我们自己开发了多个APK并且需要他们之间互相共享资源，那么就需要通过设置shareUserId来实现这一目的。通过SharedUserId,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以通过获取上下文来互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。而上面的两个工程中并没有对Android:sharedUserId属性进行设置。这个属性是在查资料时看到的：意思是说，在manifest.xml里面将两个应用程序的android:sharedUserId属性设为相同的就可以对SharedPreferences文件进行写。（此处并没有验证） 6、SharedPreferences总结优点SharedPreferences对象与SQLite数据库相比显得格外轻量级，免去了创建数据库，创建表，写SQL语句等诸多操作，相对而言更加方便，简洁。缺点1、其职能存储boolean，int，float，long和String五种简单的数据类型。2、无法进行条件查询等。【所以不论SharedPreferences的数据存储操作是如何简单，它也只能是存储方式的一种补充，而无法完全替代如SQLite数据库这样的其他数据存储方式。】 文件存储数据1、功能介绍Android文件系统和其他平台上的类似，使用File APIs可以读写文件。这部分内容需要你已经了解了Linux文件系统的基础，并且也了解了java.io包中的标准文件输入输出APIs。 2、存储方式所有的Android设备都有两块文件存储区域：内部和外部存储。内部存储：指设备自带的非易失性存储器。永远可用，因为不可以拆卸。文件默认情况下只对你的app可用，是私有的，无论是用户或者是其他app都不能共享访问你的数据。当用户卸载你的app时，系统会自动移除app在内部存储上的所有文件。外部存储：指可拆卸的存储介质，如卫星电视SD卡。不一定一直可以访问，因为用户可以拆卸外部存储设备。文件是全局可读的，没有访问限制，不受你的控制。可以和其他app共享数据，用户使用电脑也可以访问在外部存储中的文件。当用户卸载你的app时，只有当你把文件存储在以 getExternalFilesDir().获得的路径下时，系统才会帮你自动移除。 3、使用内部存储（Demo）Context提供了两个方法来打开数据文件里的文件IO流1234FileInputStream openFileInput(String name); FileOutputStream openFileInput(String name , int mode);//name参数: 用于指定文件名称，不能包含路径分隔符“/” ,//如果文件不存在，Android 会自动创建它。 这两个方法第一个参数 用于指定文件名，第二个参数指定打开文件的模式。1234567MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下， 写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPENDMODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。MODE_WORLD_READABLE：表示当前文件可以被其他应用读取。MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。模式可以连用 比如可读可写 就写成：MODE_WORLD_READABLE+MODE_WORLD_WRITEABLE 除此之外，Context还提供了如下几个重要的方法：123getDir(String name , int mode):在应用程序的数据文件夹下获取或者创建name对应的子目录getFilesDir():获取该应用程序的数据文件夹得绝对路径fileList():返回该应用数据文件夹的全部文件 我们将实现的Demo为将输入的文字写入文件，并读取出来。第一步：创建和写入一个内部存储的私有文件：12345678910111213141516public void WriteFiles(String content)&#123; try &#123; //①调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。 FileOutputStream fos = openFileOutput("a.txt", MODE_PRIVATE); //②通过FileOutputStream对象的write()函数写入数据。 fos.write(content.getBytes()); //③FileOutputStream对象的close ()函数关闭流。 fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 第二步：读取一个内部存储的私有文件：12345678910111213141516171819202122public String readFiles()&#123; String content = null; try &#123; //① 调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。 FileInputStream fis= openFileInput("a.txt"); StringBuilder sb = new StringBuilder(); byte [] buffer = new byte[1024]; int len = 0; //② 使用流对象的 read()方法读取字节 while ((len=fis.read(buffer))!=-1) &#123; sb.append(new String(buffer, 0, len)); &#125; content =sb.toString(); //③ 调用流的close()方法关闭流 fis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return content; &#125; 第三步：MainActivity中实现流程：1234567891011121314protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); edt = (EditText) findViewById(R.id.editText1); but = (Button) findViewById(R.id.write); contentvalue = (TextView) findViewById(R.id.contentvalue); but.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; WriteFiles(edt.getText().toString()); contentvalue.setText(readFiles()); &#125; &#125;); &#125; 效果 【注意】保存内存缓存文件有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir()去创建或打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。12File file = this.getCacheDir();Log.i("info", file.toString(); 当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。 4、使用外部存储（Demo）因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：第一步：添加外部存储访问限权12345&lt;!-- 在AndroidManifest.xml中加入访问SDCard的权限--&gt; &lt;!-- 在SDCard中创建与删除文件权限 --&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; &lt;!-- 往SDCard写入数据权限 --&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 第二步：检测外部存储的可用性12345678910//获取外存储的状态String state = Environment.getExternalStorageState();if (Environment.MEDIA_MOUNTED.equals(state)) &#123; // 可读可写 mExternalStorageAvailable = mExternalStorageWriteable = true;&#125; else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; // 可读&#125; else &#123; // 可能有很多其他的状态，但是我们只需要知道，不能读也不能写 &#125; 第三步：读写数据123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends Activity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView= (TextView) findViewById(R.id.tv); if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; File sdCardDir = Environment.getExternalStorageDirectory(); //获取SDCard目录 "/sdcard" File saveFile = new File(sdCardDir,"a.txt"); //写数据 try &#123; FileOutputStream fos= new FileOutputStream(saveFile); fos.write("bobobo".getBytes()); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //读数据 try &#123; FileInputStream fis= new FileInputStream(saveFile); int len =0; byte[] buf = new byte[1024]; StringBuffer sb = new StringBuffer(); while((len=fis.read(buf))!=-1)&#123; sb.append(new String(buf, 0, len)); &#125; textView.setText(sb.toString()); fis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 效果 SQLite数据库存储数据1、简介及特点SQLite是轻量级嵌入式数据库引擎，且只利用很少的内存就有很好的性能。在我们为移动设备开发应用程序时，使用SQLite作为复杂数据、大量数据的存储引擎。SQLite它是一个独立的，无需服务进程，无需安装和管理配置，支持事务处理，可以使用SQL语言的数据库。支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python。在Content Provider 技术中就是使用SQLite数据库来操作数据的。 2、实现原理直接通过SQLiteDatabase对象来创建一个数据库。或者继承SQLiteOpenHelper类封装创建和更新数据库使用的逻辑。它们都会在ddns 的file explorer 中的data/data/&lt;包&gt;/databases中创建这个数据库文件。 3、通过SQLiteDatabase创建（Demo）第一步：创建数据库并插入数据12345678910private SQLiteDatabase db;public void init() &#123; db = openOrCreateDatabase("user.db", MODE_PRIVATE, null); db.execSQL("create table if not exists usertb (_id integer primary key autoincrement, name text not null , age integer not null , sex text not null )"); db.execSQL("insert into usertb(name,sex,age) values('张三','女',18)"); db.execSQL("insert into usertb(name,sex,age) values('李四','男',19)"); db.execSQL("insert into usertb(name,sex,age) values('王五','女',22)"); //查询数据库并展示 query(findViewById(R.id.query)); &#125; query代码【关于查询代码的详情在本小节末尾会有详细说明】1234567891011121314151617public void query(View view) &#123; tv_id.setText(""); tv_name.setText(""); tv_sex.setText(""); tv_age.setText(""); Cursor cursor = db.rawQuery("select * from usertb", null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; tv_id.append("\n" + cursor.getString(cursor.getColumnIndex("_id"))); tv_name.append("\n" + cursor.getString(cursor.getColumnIndex("name"))); tv_sex.append("\n" + cursor.getString(cursor.getColumnIndex("sex"))); tv_age.append("\n" + cursor.getString(cursor.getColumnIndex("age"))); &#125; cursor.close(); &#125;// db.close();不要关闭，不然单独调用查询操作会空指针 &#125; 效果第二步：实现插入数据的操作（两种方式任选其一）使用insert方法12345678910public void add(View view) &#123; ContentValues cv = new ContentValues();//实例化一个ContentValues用来装载待插入的数据 cv.put("name","新来的"); cv.put("sex","女"); cv.put("age","18"); db.insert("usertb",null,cv);//执行插入操作// 使用直接执行语句添加 // db.execSQL("insert into usertb(name,sex,age) values('新来的','女',18)"); query(findViewById(R.id.query)); &#125; 使用execSQL方式来实现1db.execSQL("insert into usertb(name,sex,age) values('新来的','女',18)"); 效果 第三步：实现删除数据的操作同样有2种方式可以实现123String whereClause = "name=?";//删除的条件String[] whereArgs = &#123;"新来的"&#125;;//删除的条件参数db.delete("user",whereClause,whereArgs);//执行删除 使用execSQL方式的实现12String sql = "delete from usertb where name='新来的'";//删除操作的SQL语句db.execSQL(sql);//执行删除操作 第四步：实现修改数据的操作（将张三改成张三三）同上，仍是2种方式12345ContentValues cv = new ContentValues();//实例化ContentValuescv.put("name","张三三");//添加要更改的字段及内容String whereClause = "name=?";//修改条件String[] whereArgs = &#123;"张三"&#125;;//修改条件的参数db.update("usertb",cv,whereClause,whereArgs);//执行修改 使用execSQL方式的实现12String sql = "update usertb set name = '张三三' where username='张三'";//修改的SQL语句db.execSQL(sql);//执行修改 【关于查询操作】查询操作相对于上面的几种操作要复杂些，因为我们经常要面对着各种各样的查询条件，所以系统也考虑到这种复杂性，为我们提供了较为丰富的查询形式：1234db.rawQuery(String sql, String[] selectionArgs); db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy); db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit); db.query(String distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit); 各参数说明：12345678910table：表名称colums：表示要查询的列所有名称集selection：表示WHERE之后的条件语句，可以使用占位符selectionArgs：条件语句的参数数组groupBy：指定分组的列名having：指定分组条件,配合groupBy使用orderBy：y指定排序的列名limit：指定分页参数distinct：指定“true”或“false”表示要不要过滤重复值Cursor：返回值，相当于结果集ResultSet 最后，他们同时返回一个Cursor对象，代表数据集的游标，有点类似于JavaSE中的ResultSet。下面是Cursor对象的常用方法：12345678910111213141516c.move(int offset); //以当前位置为参考,移动到指定行 c.moveToFirst(); //移动到第一行 c.moveToLast(); //移动到最后一行 c.moveToPosition(int position); //移动到指定行 c.moveToPrevious(); //移动到前一行 c.moveToNext(); //移动到下一行 c.isFirst(); //是否指向第一条 c.isLast(); //是否指向最后一条 c.isBeforeFirst(); //是否指向第一条之前 c.isAfterLast(); //是否指向最后一条之后 c.isNull(int columnIndex); //指定列是否为空(列基数为0) c.isClosed(); //游标是否已关闭 c.getCount(); //总数据项数 c.getPosition(); //返回当前游标所指向的行数 c.getColumnIndex(String columnName);//返回某列名对应的列索引值 c.getString(int columnIndex); //返回当前行指定列的值 举例1234db.update("stutb", values, "_id&gt;?", new String[]&#123;"3"&#125;);//把id&gt;3的性别更新成"女"db.delete("stutb", "name like ?", new String[]&#123;"%丰%"&#125;);//删掉名字中带有"丰"的记录//使用游标类 进行查询Cursor c = db.query("stutb", null, "_id&gt;?", new String[]&#123;"0"&#125;, null, null, "_id"); 4、通过继承SQLiteOpenHelper类创建Android 提供了 SQLiteOpenHelper，其是SQLiteDatabase的一个帮助类，用来管理数据库的创建和版本的更新。你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。第一步：写一个子类继承SQLiteOpenHelper并复写三个方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class DatabaseHelper extends SQLiteOpenHelper &#123; /** * @param context 上下文环境（例如，一个 Activity） * @param name 数据库名字 * @param factory 一个可选的游标工厂（通常是 Null） * @param version 数据库模型版本的整数 * * 会调用父类 SQLiteOpenHelper的构造函数 */ // public DatabaseHelper(Context context, String name, CursorFactory factory, int version) &#123; // super(context, name, factory, version); // &#125; //这里我们直接定义数据库名字根版本号 private static final String DATABASE_NAME = "stu.db"; private static final int VERSION = 1; private static final String TABLE_NAME = "stutb"; // 步骤2：重载构造方法 public DatabaseHelper(Context context) &#123; super(context, DATABASE_NAME, null, VERSION); &#125; /** * 在数据库第一次创建的时候会调用这个方法 * *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。 */ //在这里进行建表 @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL("create table if not exists stutb(_id integer primary key autoincrement,name text not null,sex text not null,age integer not null)"); db.execSQL("insert into stutb(name,sex,age)values('张三','男',18)"); db.execSQL("insert into stutb(name,sex,age)values('张四','女',20)"); &#125; /** * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。 * 一般我们在这个方法里边删除数据库表，并建立新的数据库表. */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; //三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号 &#125; @Override public void onOpen(SQLiteDatabase db) &#123; // 每次成功打开数据库后首先被执行 super.onOpen(db); &#125;&#125; 第二步：继承SQLiteOpenHelper之后就拥有了以下两个方法getReadableDatabase() 创建或者打开一个查询数据库getWritableDatabase() 创建或者打开一个可写数据库123456789DatabaseHelper database = new DatabaseHelper(MainActivity.this);//传入一个上下文参数SQLiteDatabase db = null;db = database.getWritableDatabase();//上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。getWritableDatabase()和getReadableDatabase()方法都可以获取一个用于操作数据库的SQLiteDatabase实例。// 其中getReadableDatabase()方法则是先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，当打开失败后// 会继续尝试以只读方式打开数据库。如果该问题成功解决，则只读数据库对象就会关闭，然后返回一个可读写的数据库对象。// getWritableDatabase() 方法以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，// 使用的是getWritableDatabase() 方法就会出错。 第三步：实现查询代码1234567891011Cursor c = db.rawQuery("select * from stutb", null); if (c!=null) &#123; String [] cols = c.getColumnNames(); while (c.moveToNext()) &#123; for (String ColumnName : cols) &#123; Log.i("info ", ColumnName+":"+c.getString(c.getColumnIndex(ColumnName))); &#125; &#125; c.close(); &#125; db.close(); 效果(命令行打印) 5、两种方式的联系Context.openOrCreateDatabase 与 SQLiteDatabase.openOrCreateDatabase本质上完成的功能都一样，Context.openOrCreateDatabase最终是需要调用 SQLiteDatabase.openOrCreateDatabase来完成数据库的创建的。 也就是说， SQLiteDatabase类是android上对sqlite的最底层的封装，几乎所有的对数据库的操作最终都通过这个类来实现。对数据表的操作方式不同，SQLiteOpenHelper是SQLiteDatabase的帮助类。要如你的代码执行，你需要通过类似SQLiteOpenHelper的getWritableDatabase方法获取到SQLiteDatabase实例才可以。创建表直接可以在SQLiteOpenHelper的onCreate方法中做，那里通过参数你可以得到一个SQLiteDatabase的实例。 使用ContentProvider存储数据与SQLite数据库联系1.SQLiteOpenHelper是将对数据库和表的创建、插入、更新、删除操作进行了简单的封装；2.而ContentProvider可以说是一个对外的接口，除了可以实现对SQLiteOpenHelper的封装，还可以实现对文件操作、图片操作、对象操作等实现封装；3.在多线程中使用SQLiteOpenHelper要考虑线程同步问题，而如果使用ContentProvider的话基本不用考虑；4.使用ContentProvider存储数据可以实现不同app之间的数据共享。详见：Android实习生 —— 四大组件之ContentProvider 网络存储数据一、网络保存数据介绍可以使用网络来保存数据，在需要的时候从网络上获取数据，进而显示在App中。用网络保存数据的方法有很多种，对于不同的网络数据采用不同的上传与获取方法。本文利用LeanCloud来进行网络数据的存储。LeanCloud是一种简单高效的数据和文件存储服务。感兴趣的可以查看网址：https://leancloud.cn/。 的例子。 二、使用方法1、上传数据1234567891011121314AVObject personObject = new AVObject(TABLENAME); personObject.put(NAME, person.name); personObject.put(AGE, person.age); personObject.put(INFO, person.info); personObject.saveInBackground(new SaveCallback() &#123; @Override public void done(AVException e) &#123; if (e == null) &#123; Log.v(TAG, "put data success!"); &#125; else &#123; Log.v(TAG, "put data failed!error:" + e.getMessage()); &#125; &#125; &#125;); 2、读取数据12345678910111213141516171819AVQuery&lt;AVObject&gt; avQuery = new AVQuery&lt;&gt;(TABLENAME); avQuery.findInBackground(new FindCallback&lt;AVObject&gt;() &#123; @Override public void done(List&lt;AVObject&gt; list, AVException e) &#123; if (e == null) &#123; Log.v(TAG, "get data success!"); String message = ""; //倒着遍历后四条上传的数据 for (int i = list.size()-1; i &gt;=list.size()-4; i--) &#123; String name = list.get(i).getString(NAME); int age = list.get(i).getInt(AGE); String info = list.get(i).getString(INFO); message += "name:" + name + ",age:" + age + ",info:" + info + ".\n"; &#125; textView.setText(message); &#125; &#125; &#125;); 三、小案例1、导入jar包2、添加NetworkDBManager类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhangmiao.datastoragedemo;import android.util.Log;import android.widget.TextView;import com.avos.avoscloud.AVException;import com.avos.avoscloud.AVObject;import com.avos.avoscloud.AVQuery;import com.avos.avoscloud.FindCallback;import com.avos.avoscloud.SaveCallback;import java.util.List;/** * Created by zhangmiao on 2016/12/22. */public class NetworkDBManager &#123; private static final String TAG = "NetworkDBManager"; private final static String TABLENAME = "person"; private final static String NAME = "name"; private final static String AGE = "age"; private final static String INFO = "info"; public void putData(Person person) &#123; AVObject personObject = new AVObject(TABLENAME); personObject.put(NAME, person.name); personObject.put(AGE, person.age); personObject.put(INFO, person.info); personObject.saveInBackground(new SaveCallback() &#123; @Override public void done(AVException e) &#123; if (e == null) &#123; Log.v(TAG, "put data success!"); &#125; else &#123; Log.v(TAG, "put data failed!error:" + e.getMessage()); &#125; &#125; &#125;); &#125; public void getData(final TextView textView) &#123; AVQuery&lt;AVObject&gt; avQuery = new AVQuery&lt;&gt;(TABLENAME); avQuery.findInBackground(new FindCallback&lt;AVObject&gt;() &#123; @Override public void done(List&lt;AVObject&gt; list, AVException e) &#123; if (e == null) &#123; Log.v(TAG, "get data success!"); String message = ""; ////倒着遍历后四条上传的数据 for (int i = list.size()-1; i &gt;=list.size()-4; i--) &#123; String name = list.get(i).getString(NAME); int age = list.get(i).getInt(AGE); String info = list.get(i).getString(INFO); message += "name:" + name + ",age:" + age + ",info:" + info + ".\n"; &#125; textView.setText(message); &#125; &#125; &#125;); &#125;&#125; 3、修改AndroidManifest.xml文件12&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; 4、MainActivity12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private NetworkDBManager mNetworkDBManager; private TextView mTableInfo; private EditText et1,et2,et3; @Override protected void onCreate(Bundle savedInstanceState) &#123; Log.v("MainActivity", "onCreate"); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); AVOSCloud.initialize(this, "yMNUazdBt872mNtC9aSakjYy-gzGzoHsz", "d4vw3VYdMCjLpsXRhHTBRutC"); mNetworkDBManager = new NetworkDBManager(); et1= (EditText) findViewById(R.id.name); et2= (EditText) findViewById(R.id.age); et3= (EditText) findViewById(R.id.sex); Button networkGet = (Button) findViewById(R.id.network_get); Button networkPut = (Button) findViewById(R.id.network_put); mTableInfo = (TextView) findViewById(R.id.table_info); networkGet.setOnClickListener(this); networkPut.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.network_put: Person person3 = new Person(et1.getText().toString(), Integer.parseInt(et2.getText().toString()), et3.getText().toString()); mNetworkDBManager.putData(person3); Toast.makeText(this,"上传成功",Toast.LENGTH_SHORT).show(); break; case R.id.network_get: mNetworkDBManager.getData(mTableInfo); break; default: Log.v("MainActivity", "default"); break; &#125; &#125;&#125; #【附录】 Demo一、SharedPreferencesapp内部实现数据存储其他app实现共享数据【先安装使用第一个并登入才可以使用第二个】二、文件存储数据内部存储外部存储三、SQLite数据库存储数据SQLiteDatabase直接操作数据库继承SQLiteOpenHelper类操作数据库四、ContentProvider无五、网络存储数据网络存储 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之ContentProvider]]></title>
      <url>%2F2016%2F07%2F05%2FContentProvider%2F</url>
      <content type="text"><![CDATA[基础回顾简介ContentProvider（数据提供者）是在应用程序间共享数据的一种接口机制，虽然我们可以采用文件存储方式、sharedpreferences方式在程序间进行共享数据，但ContentProvider提供了更为高级的数据共享方法，应用程序可以指定需要共享的数据，而其他应用程序则可以在不知数据来源、路径的情况下，对共享数据进行查询、添加、删除和更新等操作，当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。 特点1、为存储和获取数据提供了统一的接口。2、可以在不同的应用程序之间共享数据。3、使用数据库表的形式来组织数据进行封装。数据库使用：Android实习生 —— 数据存储与共享4、为应用间的数据交互提供了一个安全的环境。它准许你把自己的应用数据根据需求开放给其他应用进行增、删、改、查，而不用担心直接开放数据库权限而带来的安全问题。【总的来说使用ContentProvider对外共享数据的好处是统一了数据的安全访问方式。】 使用场景Android已经为常见的一些数据提供了系统默认的ContentProvider，比如去获取通讯录信息、获取图片、视频信息。我们可以在其他应用程通过提供的ContentProvider获取这些数据。 相关概念1、Uri通用资源标志符（Universal Resource Identifier, 简称”URI”）。Uri代表了要操作的数据，它为系统的每一个资源给其一个名字，比方说通话记录。每一个ContentProvider都拥有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。URI一般主要由三部分组成：Authority：授权信息，用以区别不同的ContentProvider，外部调用者可以根据这个标识来找到它。为了保证URI标识的唯一性，它必须是一个完整的、小写的类名。这个标识在 元素的 authorities属性中说明：一般是定义该ContentProvider的包.类的名称。12&lt;provider android:name=".MyProvider" android:authorities="com.xxx.MyApp.myprovider" /&gt; Path：表名，用以区分ContentProvider中不同的数据表；Id：Id号，用以区别表中的不同数据记录；如果没有ID，就表示返回全部； “content://com.xxx.MyApp.myprovider/tablename/#” #表示数据id。【举例】1、要操作person表中id为10的记录，可以构建这样的路径:/person/102、要操作person表中id为10的记录的name字段， person/10/name3、要操作person表中的所有记录，可以构建这样的路径:/person4、如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：Uri uri = Uri.parse(“content://com.xxx.MyApp.myprovider/person”)【每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。Android所提供的ContentProvider都存放在android.provider包当中】 2、工具类：UriMatcher因为Uri代表了要操作的数据，所以我们经常需要解析Uri，并从Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher和ContentUris 。掌握它们的使用，会便于我们的开发工作。使用方法如下：第一步，初始化：12//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); 第二步，注册需要的Uri:1234//如果match()方法匹配content://com.xxx.MyApp.myprovider/person路径，返回匹配码为1matcher.addURI("com.xxx.MyApp.myprovider", "person", 1); //如果match()方法匹配content://com.xxx.MyApp.myprovider/person/230路径，返回匹配码为2matcher.addURI("com.xxx.MyApp.myprovider", "person/#", 2); //#号为通配符 第三步，与已经注册的Uri进行匹配:1234567891011Uri uri = Uri.parse("content://com.xxx.MyApp.myprovider/people"); int match = matcher.match(uri); switch (match) &#123; case 1: break; case 2: break; default: break; &#125; match方法匹配后会返回一个匹配码Code，即在使用注册方法addURI时传入的第三个参数。 3、工具类ContentUris：ContentUris类用于操作Uri路径后面的ID部分，它有两个比较实用的方法：withAppendedId(uri, id)用于为路径加上ID部分：123Uri uri = Uri.parse("content://com.xxx.MyApp.myprovider/person")Uri resultUri = ContentUris.withAppendedId(uri, 10); //生成后的Uri为：content://com.xxx.MyApp.myprovider/person/10 parseId(uri)方法用于从路径中获取ID部分：12Uri uri = Uri.parse("content://com.xxx.MyApp.myprovider/person/10")long personid = ContentUris.parseId(uri);//获取的结果为:10 使用ContentProvider共享数据(Demo，下载链接见附录)1、建立一个Provider所用到变量类1234567891011121314151617181920public class ContentData &#123; //provider唯一标示信息 protected static final String CONTENT_AUTHORITY = "com.xxx.MyApp.myprovider"; //基础Uri protected static final Uri BASE_CONTENT_URI = Uri.parse("content://" + CONTENT_AUTHORITY); //操作表的名称 protected static final String PATH_TEST = "people"; //表中记录信息 public static final class TestEntry implements BaseColumns &#123; // 完整Uri public static final Uri CONTENT_URI = BASE_CONTENT_URI.buildUpon().appendPath(PATH_TEST).build(); protected static Uri buildUri(long id) &#123; return ContentUris.withAppendedId(CONTENT_URI, id); &#125; protected static final String TABLE_NAME = "people"; public static final String COLUMN_NAME = "name"; public static final String COLUMN_SEX = "sex"; public static final String COLUMN_AGE = "age"; &#125;&#125; 2、Provider最终还要操作数据库，这里我们写数据库操作类代码数据库使用：Android实习生 —— 数据存储共享**1234567891011121314151617181920212223242526272829303132public class DBOpenHelper extends SQLiteOpenHelper &#123; //数据库版本 private static final int DATABASE_VERSION = 1; //数据库名称 private static final String DATABASE_NAME = "people.db"; //构造方法 public DBOpenHelper(Context context) &#123; super(context, DATABASE_NAME,null, DATABASE_VERSION); &#125; //通过sql语句建表并插入数据 @Override public void onCreate(SQLiteDatabase db) &#123; System.out.println("create table"); final String SQL_CREATE_CONTACT_TABLE = "CREATE TABLE " + ContentData.TestEntry.TABLE_NAME + "( " + "_id integer primary key autoincrement," + ContentData.TestEntry.COLUMN_NAME + " TEXT NOT NULL," + ContentData.TestEntry.COLUMN_SEX + " TEXT NOT NULL," + ContentData.TestEntry.COLUMN_AGE + " INTEGER NOT NULL );"; db.execSQL(SQL_CREATE_CONTACT_TABLE); db.execSQL("insert into people(name,sex,age)values('张三','女',18)"); db.execSQL("insert into people(name,sex,age)values('张四','男',20)"); db.execSQL("insert into people(name,sex,age)values('张五','女',19)"); db.execSQL("insert into people(name,sex,age)values('张六','男',22)"); &#125; //数据库升级的时候会调用的代码 @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("DROP TABLE IF EXISTS " + ContentData.TestEntry.TABLE_NAME); onCreate(db); &#125;&#125; 3、创建自己的ProviderMyProvider继承ContentProvider。默认该Provider需要实现如下六个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MyProvider extends ContentProvider &#123; private DBOpenHelper dbOpenHelper;//声明数据库操作类 private final static int TEST = 100;//匹配码 //使用UriMatcher解析Uri，如果被匹配到，返回匹配码100 static UriMatcher buildUriMatcher() &#123; final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); final String authority = ContentData.CONTENT_AUTHORITY; matcher.addURI(authority, ContentData.PATH_TEST, TEST); return matcher; &#125; @Override //该方法在ContentProvider被其它应用第一次访问它时才会被创建。 //同时我们操作数据库建表 public boolean onCreate() &#123; dbOpenHelper = new DBOpenHelper(getContext()); return true; &#125; @Override //该方法用于供外部应用往ContentProvider添加数据。 public Uri insert(Uri uri, ContentValues contentValues) &#123; //获得可写数据库 final SQLiteDatabase db = dbOpenHelper.getWritableDatabase(); Uri returnUri; long _id; switch ( buildUriMatcher().match(uri)) &#123; case TEST: //插入数据 _id = db.insert(ContentData.TestEntry.TABLE_NAME, null, values); if ( _id &gt; 0 ) returnUri = ContentData.TestEntry.buildUri(_id); else throw new android.database.SQLException("Failed to insert row into " + uri); break; default: throw new android.database.SQLException("Unknown uri: " + uri); &#125; return returnUri; &#125; @Override //该方法用于供外部应用从ContentProvider删除数据。 public int delete(Uri uri, String s, String[] strings) &#123; return 0; &#125; @Override //该方法用于供外部应用从ContentProvider中获取数据。 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; //获得可读数据库 final SQLiteDatabase db = dbOpenHelper.getReadableDatabase(); //查到的结果是游标类型。 Cursor cursor = null; switch ( buildUriMatcher().match(uri)) &#123; case TEST: cursor = db.query(ContentData.TestEntry.TABLE_NAME, projection, selection, selectionArgs, sortOrder, null, null); break; &#125; return cursor; &#125; @Override //该方法用于供外部应用从ContentProvider更新数据。 public int update(Uri uri, ContentValues contentValues, String s, String[] strings) &#123; return 0; &#125; @Override public String getType(Uri uri) &#123; return null; &#125; //该方法用于返回当前Uri所代表数据的MIME类型。 //如果操作的数据属于集合类型，那么MIME类型字符串应以vnd.android.cursor.dir/开头， //例如：要得到所有person记录的Uri为content://com.xxx.MyApp.myprovider/person， //那么返回的MIME类型字符串应该为："vnd.android.cursor.dir/person"。 //如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头， //例如：得到id为10的person记录，Uri为content://com.xxx.MyApp.myprovider/person/10， //那么返回的MIME类型字符串为："vnd.android.cursor.item/person"。&#125; 【注意】以上代码并没有实现删除，更改功能 4、注册Provider1234//应用内访问&lt;provider android:authorities="com.xxx.MyApp.myprovider" android:name=".MyProvider" /&gt; 在注册的时候需要注意几个属性：1234android:exported 设置此provider是否可以被其他应用使用。android:readPermission 该provider的读权限的标识android:writePermission 该provider的写权限标识android:permission provider读写权限标识 如何让其他应用也可以访问此应用中的数据呢，我们需要这么注册123456&lt;provider android:authorities="com.xxx.MyApp.myprovider" android:name=".MyProvider" android:readPermission="com.xxx.READ" android:exported="true"&gt;&lt;/provider&gt; 并且要在注册文件中声明一个permission1&lt;permission android:name="com.bb.READ" android:protectionLevel="normal"/&gt; 【通过以上步骤，一个ContentProvider就造好了。】 ContentResolver使用ContentResolver调用ContentProvider去操作数据库数据 为什么我们不直接访问Provider。大家要知道一台手机中可不是只有一个Provider内容，它可能安装了很多含有Provider的应用，比如联系人应用，日历应用，字典应用等等。有如此多的Provider，如果你开发一款应用要使用其中多个，如果让你去了解每个ContentProvider的不同实现，岂不是要头都大了。所以Android为我们提供了ContentResolver来统一管理与不同ContentProvider间的操作。 实现过程1、当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法通过URI进行数据操作。1ContentResolver resolver = getContentResolver(); 2、ContentResolver 类提供了与ContentProvider类相同签名的四个方法：12345678public Uri insert(Uri uri, ContentValues values)：//该方法用于往ContentProvider添加数据。public int delete(Uri uri, String selection, String[] selectionArgs)：//该方法用于从ContentProvider删除数据。public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)：//该方法用于从ContentProvider中获取数据。public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)：//该方法用于更新ContentProvider中的数据。 使用ContentResolver对我们刚才造的ContentProvider中的数据进行添加、查询操作：123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123;//声明Uri常量private static final Uri CONTENT_URI = Uri.parse("content://com.xxx.MyApp.myprovider/people");TextView tv_id, tv_name, tv_sex, tv_age; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_id = (TextView) findViewById(R.id.tv_id); tv_name = (TextView) findViewById(R.id.tv_name); tv_sex = (TextView) findViewById(R.id.tv_sex); tv_age = (TextView) findViewById(R.id.tv_age); &#125; //query()为在xml组建中定义的OnClick public void query(View view) &#123; //通过getContentResolver().query调用ContentProvider实现对数据库的查询 tv_id.setText(""); tv_name.setText(""); tv_sex.setText(""); tv_age.setText(""); Cursor cursor = getContentResolver().query(CONTENT_URI, new String[]&#123;"_id", "name", "sex", "age" &#125;, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; tv_id.append("\n" + cursor.getString(cursor.getColumnIndex("_id"))); tv_name.append("\n" + cursor.getString(cursor.getColumnIndex("name"))); tv_sex.append("\n" + cursor.getString(cursor.getColumnIndex("sex"))); tv_age.append("\n" + cursor.getString(cursor.getColumnIndex("age"))); &#125; cursor.close(); &#125; &#125; public void add(View view) &#123; //通过getContentResolver().insert调用ContentProvider实现对数据库的增加 ContentValues values = new ContentValues(); values.put("name", "新来的"); values.put("sex", "男"); values.put("age", "28"); getContentResolver().insert(CONTENT_URI, values); query(findViewById(R.id.btn_query)); &#125; &#125; 【XML布局请下载Demo】3、在注册文件中记得增加权限读取权限12&lt;uses-permission android:name="com.xxx.READ"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; 4、最终效果 【附录】相关Demo请先安装MyProvider，再安装MyResolver。MyProvider、MyResolver另赠送两个Demo，关于对系统Provider的调用（增、查联系人）增加联系人、查询联系人 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之Service]]></title>
      <url>%2F2016%2F06%2F26%2FService%2F</url>
      <content type="text"><![CDATA[基础回顾定义Service是可以在后台执行长时间（长生命周期）而又不与用户产生UI交互（没有用户界面）的操作。 注意事项1、只能在后台运行，即便用户切换了其他应用，启动的Service仍可在后台运行。2、可以和其他组件进行Service绑定并与之交互，甚至是跨进程通信（IPC）。3、不能运行在一个独立的进程当中，而是依赖与创建服务时所在的应用组件进程。4、服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务。 应用场景举例音乐播放：播放多媒体的时候用户启动了其他Activity，此时要在后台继续播放。记录检测：比如检测SD卡上文件的变化；在后台记录你的地理信息位置的改变等。其他操作：网络请求、执行文件读写操作或者与 content provider交互。 类型本地服务依附在主进程上，在一定程度上节约了资源。本地服务因为是在同一进程，因此不需要IPC，也不需要AIDL。相应bindService会方便很多。缺点是主进程被kill后，服务变会终止。远程服务是独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被kill的是偶，该服务依然在运行。缺点是该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。本文第六部分将会简单的讲述这一进程间通信方式。对于startService来说，不管是本地服务还是远程服务，我们需要做的工作都一样简单。 生命周期从Service的启动到销毁，有两种路径（两种生命周期）：startService、bindService 使用方法1、通过startService方式定义一个Service（继承Service类）核心步骤和代码：创建一个类继承android.app.Service类，实现抽象方法onBind()，重写onCreate()、onStartCommand()、onDestry()。123456789101112131415161718192021222324252627public class MyService extends Service &#123; public static final String TAG = "MyService"; //创建服务时调用 @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate"); &#125; //服务执行的操作 @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; //销毁服务时调用 @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy"); &#125; //onBind()方法是Service中唯一的一个抽象方法，所以必须要在子类里实现。 //Service有两种启动方式：一种是startService()，另一种是bindService()。第二种启动方式才会用到onBind()方法。 //我们这先用第一种方式定义Service，所以暂时忽略onBind()方法。 @Override public IBinder onBind(Intent intent) &#123; return null; &#125; 在清单文件中配置Service,和Activity标签并列。1&lt;service android:name=".MyService"&gt;&lt;/service&gt; 请注意：为了保证应用的安全，请使用显式Intent启动或绑定一个Service，请不要在标签中配置intent-filter。在Activity组件中通过onCreate()声明“启动Service和停止Service”代码。12345678910111213141516171819202122232425262728public class MainActivity extends Activity implements OnClickListener &#123; private Button button1_start_service; private Button button2_stop_service; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1_start_service = (Button)findViewById(R.id.button1_start_service); button2_stop_service = (Button)findViewById(R.id.button2_stop_service); button1_start_service.setOnClickListener(this); button2_stop_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1_start_service: Intent startIntent = new Intent(this, MyService.class); startService(startIntent); break; case R.id.button2_stop_service: Intent stopIntent = new Intent(this, MyService.class); stopService(stopIntent); break; default: break; &#125; &#125; &#125; 启动和停止服务：startService()和stopService()方法都是定义在Context类当中的，所以可以在MainActivity中直接调用这两个方法。 运行上面的程序，点击button1_start_service按钮，通过Intent实现启动服务，后台打印日志如下：说明服务启动成功。那么如果我再连续点三次button1_start_service按钮，后台增加的日志如下：onCreate()方法只会在Service第一次被创建的时候调用，而onStartCommand()方法在每次启动服务的时候都会调用。我们还可以在正在“设置–应用—运行”中找到这个服务，如下图所示：如果我们再点击button2_stop_service按钮或者点击上图中的“Stop”，MyService服务就停止掉了（多次点击stop不会再产生日志）：通过startService方式（继承Service类）总结1、启动服务对象多次启动同时只会产生一个，onCreate()方法只会在Service第一次被创建的时候调用，多次点击启动会执行多次onStartCommand()方法，onDestroy()方法只会在Service第一次被停止的时候调用，多次点击停止不会报异常，也不再执行onDestroy()方法。2、一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。3、停止一个started服务有两种方法：（1）在外部使用stopService()手动停止。（2）在服务内部(onStartCommand方法内部)使用stopSelf()方法，使服务执行完毕后自动停止。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。4、onStartCommand方法的返回值：onStartCommand方法执行时，返回的是一个int型。这个整型可以有三个返回值：START_NOT_STICKY、START_STICKY、START_REDELIVER_INTENTSTART_NOT_STICKY:“非粘性的”。使用这个返回值时，如果在执行完onStartCommand方法后，服务被异常kill掉，系统不会自动重启该服务。START_STICKY：如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。START_REDELIVER_INTENT：重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。5、默认情况下，一个started的Service与启动他的组件在同一个线程中。上面的实例中，服务就是在主线程中运行的，如果是在服务中完成耗时操作的话，容易造成主线程阻塞。所以我们可以在服务中开启一个子线程来完成耗时操作。 2、通过startService方式定义一个Service（继承IntentService类）：为什么要通过继承IntentService来定义：我们在基础回顾的注意事项3、4中就已经了解，服务中的代码默认运行在主线程中，如果直接在服务里执行一些安卓不允许的耗时操作，容易造成主线程ANR（Application Not Responding）异常，所以就需要用到多线程的知识了，需要在服务的内部手动创建子线程。所以一个比较标准的服务可以这样写：123456789101112131415161718192021public class MyService extends Service &#123; public static final String TAG = "MyService"; //服务执行的操作 @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; public void run() &#123; //在子线程中处理具体的逻辑 //在这里我们只做打印子线程id的操作 Log.i("MyService",Thread.currentThread().getId()+""); stopSelf(); //服务执行完毕后自动停止 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub return null; &#125; &#125; 在MainActivity中启动Service代码1234567891011121314151617181920212223242526272829public class MainActivity extends Activity implements OnClickListener &#123; private Button button1_start_service; private Button button2_stop_service; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1_start_service = (Button)findViewById(R.id.button1_start_service); button2_stop_service = (Button)findViewById(R.id.button2_stop_service); button1_start_service.setOnClickListener(this); button2_stop_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1_start_service: Log.i("Main",Thread.currentThread().getId()+""); Intent startIntent = new Intent(this, MyService.class); startService(startIntent); break; case R.id.button2_stop_service: Intent stopIntent = new Intent(this, MyService.class); stopService(stopIntent); break; default: break; &#125; &#125; &#125; 注册Service步骤不再赘述，当开启Service后打印日志如下：如果我们不手动开启线程，I/MyService: 177将会变成它依赖的主线程1，这就不能做耗时操作了。虽说上面的这种写法并不复杂，但总会有一些程序猿忘记开启线程，或者忘记调用stopSelf()方法。为了可以简单地创建一个可开启单独线程、会自动停止的服务，Android专门提供了一个IntentService类，这个类就很好的解决了上面所提到的两种尴尬。IntentService的作用：当我们需要这样一次性完成的任务时，就可以使用IntentService来完成。IntentService的用法： 1）新建一个MyIntentService类，继承自IntentService，并重写父类的onHandleIntent()方法，代码如下：1234567891011121314151617181920212223242526272829303132public class MyIntentService extends IntentService&#123; public MyIntentService() &#123; //第一步：重写父类的onHandleIntent()方法，这里首先要提供一个无参的构造方法， //并且必须在其内部调用父类的有参构造方法，这里我们手动给服务起个名字为：MyIntentService super("MyIntentService"); &#125; //第二步：重写父类的onHandleIntent()方法，该方法在会在一个单独的线程中执行， //来完成工作任务。任务结束后，该Service自动停止 @Override protected void onHandleIntent(Intent intent) &#123; for(int i = 0;i&lt;3;i++) &#123; //Service要执行的逻辑 //这里我们只打印当前线程的id Log.d("MyIntentService","IntentService线程的id是："+Thread.currentThread().getId()); try &#123; //线程睡眠一秒钟 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyIntentService","onDestroy"); &#125; &#125;```java 2）在清单文件中对服务进行注册服务：```xml&lt;service android:name=".MyIntentService"&gt;&lt;/service&gt; 3)在MainActivity里面加入启动IntentService的逻辑，核心代码如下：1234case R.id.button3_stop_intentservice: Log.d("MainActivity","主线程的id是："+Thread.currentThread().getId()); Intent intentService = new Intent(this,MyIntentService.class); startService(intentService); 运行程序，日志显示如下：通过startService方式（继承IntentService类） 总结1、启动一个IntentService和启动一个普通的Service，步骤是相似的。2、与直接继承Service不同在于：通过继承IntentService运行，自动开启了单独线程，而且完成任务后自动销毁了Service。【补充】Service和Thread的关系：不少Android初学者都可能会有这样的疑惑，Service和Thread到底有什么关系呢？什么时候应该用Service，什么时候又应该用Thread？答案可能会有点让你吃惊，因为Service和Thread之间没有任何关系！之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但是，Service其实是运行在主线程里的，一些比较耗时的操作需要开启单独线程。 3、通过bindService方式定义一个Service：（使用Bind Service完成Service和Activity之间的通信）：Bind Service的引入：有没有什么办法能让Service与组件的关联更多一些呢？比如说在Activity中指挥Service去干什么，Service就去干什么。当然可以，只需要让Activity和Service建立关联就好了。这时我们就可以通过bindService方式定义一个Service。Bind Service的实现原理： 应用程序组件(客户端）通过调用bindService()方法能够绑定服务，然后Android系统会调用服务的onBind()回调方法，则个方法会返回一个跟服务器端交互的Binder对象。bindService()方法立即返回，并且不给客户端返回IBinder对象。要接收IBinder对象，客户端必须创建一个ServiceConnection类的实例，并且把这个实例传递给bindService()方法。ServiceConnection对象包含了一个系统调用的传递IBinder对象的回调方法。Bind Service实现流程：1）一直有一个onBind()方法我们都没有使用到，这个方法其实就是用于和Activity建立关联的，修改MyService中的代码，如下所示：123456789101112131415161718192021222324252627282930313233343536373839public class MyBindService01 extends Service &#123; public static final String TAG = "MyBindService01"; private MyBinder mBinder = new MyBinder(); @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate"); &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; //在这里返回新建的MyBinder类 &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.d(TAG, "onUnbind"); return super.onUnbind(intent); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy"); &#125; //MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度 class MyBinder extends Binder &#123; public void startDownload() &#123; Log.d("TAG", "startDownload() executed"); // 执行具体的下载任务 &#125; public int getProgress()&#123; Log.d("TAG", "getProgress() executed"); return 0; &#125; &#125;&#125; 新建一个MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度。当然，这里只是两个模拟方法，并没有实现真正的功能，我们通过打印日志的形式来体现。接着创建MyBinder的实例，然后在onBind()方法里返回这个实例。返回这个mBinder，是一个IBinder类型，就可以把这个IBinder类型传递到MainActivity中，从而调用Service里面的方法。2）检查清单文件，是否已经对Service进行注册：1&lt;service android:name=".MyBindService01" &gt;&lt;/service&gt; 3）让我们修改MainActivity和MyBindService01之间建立关联1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends Activity implements OnClickListener &#123; private Button button1_bind_service; private Button button2_unbind_service; private MyBindService01.MyBinder myBinder; boolean mBound = false; //一开始，并没有和Service绑定.这个参数是用来显示绑定状态 //匿名内部类：服务连接对象 private ServiceConnection connection = new ServiceConnection() &#123; //当服务异常终止时会调用。注意，解除绑定服务时不会调用 @Override public void onServiceDisconnected(ComponentName name) &#123; mBound = false; //服务异常终止时，状态为未绑定 //解决了多次执行unbindService()方法引发的异常问题 &#125; //和服务绑定成功后，服务会回调该方法 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; myBinder = (MyBindService01.MyBinder) service; //在Activity中调用Service里面的方法 myBinder.startDownload(); myBinder.getProgress(); mBound = true; //true说明是绑定状态 &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1_bind_service = (Button) findViewById(R.id.button1_bind_service); button2_unbind_service = (Button) findViewById(R.id.button2_unbind_service); button1_bind_service.setOnClickListener(this); button2_unbind_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1_bind_service: Intent bindIntent = new Intent(this, MyService.class); bindService(bindIntent, connection, BIND_AUTO_CREATE);//这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后会自动创建Service（即使之前没有创建//Service也没有关系），这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。 break; case R.id.button2_unbind_service: //如果和Service是绑定的状态，就解除绑定。 if(mBound)&#123; unbindService(connection); mBound=false; &#125; break; default: break; &#125; &#125;&#125; 说明：这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，如果当前Activity与服务连接成功后，服务会回调onServiceConnected()方法在onServiceConnected()方法中，我们又通过向下转型得到了MyBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。现在我们可以在Activity中根据具体的场景来调用MyBinder中的任何public方法，即实现了Activity指挥Service干什么Service就去干什么的功能。4）执行bindService()方法。5）解除Activity和Service之间的关联。执行unbindService()。通过bindService方式 总结1、onCreate()、onBind()方法只会在Service第一次被创建的时候调用，多次点击绑定启动不会执行任何方法，onUnbind()、onDestroy()方法会在调用者执行unbindService()方法时执行或者Activity退出时自动执行。2、如果我们既通过startService()开启Service，又用通过bindService开启，必要unbindService()和stopService()都执行一次（没有先后顺序），Service才会被销毁。3、如果多次执行unbinsService()方法，程序会异常退出，我们需要在代码中加一个判断是否绑定的标记mBound来解决此问题，上面代码中有说明。1234567case R.id.button4_unbind_service://如果和Service是绑定的状态，就解除绑定。if(mBound)&#123; unbindService(connection); mBound=false;&#125;break; 4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了）。5、只有Activity、Service、Content Provider能够绑定服务；BroadcastReceiver广播接收器不能绑定服务。 4、bindService和startService混合使用：如果先startService,再bindService:在bind的Activity退出的时候,Service会执行unBind方法而不执行其onDestory方法,因为有startService方法调用过,所以Activity与Service解除绑定后会有一个与调用者没有关连的Service存在。如果先bindService,再startService,再调用Context.stopServiceService的onDestory方法不会立刻执行,因为有一个与Service绑定的Activity,但是在Activity退出的时候,会执行其(Service的)onDestory方法,如果要立刻执行stopService,就得先解除绑定。如果先是bind了，那么start的时候就直接运行Service的onStartCommand()方法，如果先是start，那么bind的时候就直接运行onBind()方法。当一个服务没被onDestory()销毁之前，只有第一个启动它的客户端能调用它的onBind()和onUnbind()。 startService、bindService区别大总结1、生命周期不同。（详见二）2、多次启动，前者会多次执行onStartCommand()方法，后者什么都不执行。多次停止，前者只会执行一次onDestroy()方法，后者报异常信息。3、当启动Service的组件已被Destroy的时候，前者不停止，后者会停止。4、前者停止直接执行onDestroy()方法（Service中的），后者则先解除绑onUnbind()定再执行onDestroy()方法（Service中的）。5、当手机屏幕在“横”“竖”变换时，前者创建的Service不会停止，后者会随着Activity的重建而停止。6、后者的onBind回调方法将返回给客户端一个IBinder接口实例，IBinder允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。而这些操作前者启动的Service是没有的。 在AndroidManifest.xml里Service元素常见选项1234567android:name -- 服务类名android:label -- 服务的名字，如果此项不设置，那么默认显示的服务名则为类名android:icon -- 服务的图标android:permission -- 申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务android:process -- 表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字android:enabled --表示是否能被系统实例化，为true表示可以，为false表示不可以，默认为trueandroid:exported -- 表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false 扩展：进程间通信说明调用者和Service如果不在一个进程内, 就需要使用android中的远程Service调用机制.android使用AIDL定义进程间的通信接口. AIDL的语法与java接口类似, 需要注意以下几点: AIDL文件必须以.aidl作为后缀名. AIDL接口中用到的数据类型, 除了基本类型, String, List, Map, CharSequence之外, 其他类型都需要导包, 即使两种在同一个包内. List和Map中的元素类型必须是AIDL支持的类型. 接口名需要和文件名相同. 方法的参数或返回值是自定义类型时, 该自定义的类型必须实现了Parcelable接口. 所有非java基本类型参数都需要加上in, out, inout标记, 以表明参数是输入参数, 输出参数, 还是输入输出参数. 接口和方法前不能使用访问修饰符和static, final等修饰. 远程通信扩展小例子远程service要在service中注册信息中加上 android:process=”:remote”12&lt;service android:name=".AIDLService" android:process=":remote"&gt;&lt;/service&gt; 远程service有什么用呢？远程service的作用只是重新建立一个新进程执行，可以独立出去。其他app可以调用这个service。因为是一个新的进程，所以也不能用bindService来建立关联了。可以用新的方式来建立关系就是下面要讲的aidl技术。AIDL实现1.首先我建立2个app工程，通过aidl实现一个app调用另一个app的service目录结构如下：service提供端app利用aidl调用service的app2.在两个app中都建立一个文件 IPerson.aidl注意 包名 要相同IPerson.aidl只是一个接口文件,用来aidl交互的，建立好之后在Studio中点Build–&gt;Rebuild会自动创建需要的java文件。IPerson.aidl代码1234package mangues.com.aidl;interface IPerson &#123; String greet(String someone);&#125; 3.在aidl_service 中建立AIDLService这个IPerson.Stub 就是通过IPerson.aidl 自动生成的binder 文件，你实现下，然后在onBind()中 return出去就好了，就和Android Service实现和activity交互一样。代码：1234567891011121314151617181920212223242526272829303132333435public class AIDLService extends Service &#123; private static final String TAG = "AIDLService"; IPerson.Stub stub = new IPerson.Stub() &#123; @Override public String greet(String someone) throws RemoteException &#123; Log.i(TAG, "greet() called"); return "hello, " + someone; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); Log.i(TAG, "onCreate() called"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(TAG, "onBind() onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(TAG, "onBind() called"); return stub; &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.i(TAG, "onUnbind() called"); return true; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.i(TAG, "onDestroy() called"); &#125;&#125; 4.aidl_service MainActivity 中启动这个service简单点就不写关闭什么的了；1234567@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent startIntent = new Intent(this, AIDLService.class); startService(startIntent); &#125; 在AndroidManifest.xml注册1234567&lt;service android:name=".AIDLService" android:process=":remote"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.AIDLService" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 作用就是把这个service暴露出去，让别的APP可以利用android.intent.action.AIDLService 字段隐形绑定这个service，获取数据。5.aidl_client 中绑定aidl_service service 获取数据代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public class MainActivity extends AppCompatActivity &#123; private IPerson person; private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.i("ServiceConnection", "onServiceConnected() called"); person = IPerson.Stub.asInterface(service); String retVal = null; try &#123; retVal = person.greet("scott"); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; Toast.makeText(MainActivity.this, retVal, Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; //This is called when the connection with the service has been unexpectedly disconnected, //that is, its process crashed. Because it is running in our same process, we should never see this happen. Log.i("ServiceConnection", "onServiceDisconnected() called"); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent mIntent = new Intent(); mIntent.setAction("android.intent.action.AIDLService"); Intent eintent = new Intent(getExplicitIntent(this,mIntent)); bindService(eintent, conn, Context.BIND_AUTO_CREATE); &#125; public static Intent getExplicitIntent(Context context, Intent implicitIntent) &#123; // Retrieve all services that can match the given intent PackageManager pm = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfo = pm.queryIntentServices(implicitIntent, 0); // Make sure only one match was found if (resolveInfo == null || resolveInfo.size() != 1) &#123; return null; &#125; // Get component info and create ComponentName ResolveInfo serviceInfo = resolveInfo.get(0); String packageName = serviceInfo.serviceInfo.packageName; String className = serviceInfo.serviceInfo.name; ComponentName component = new ComponentName(packageName, className); // Create a new intent. Use the old one for extras and such reuse Intent explicitIntent = new Intent(implicitIntent); // Set the component to be explicit explicitIntent.setComponent(component); return explicitIntent; &#125;&#125; 和Android Service 中学习的调用MyBinder获取service中数据一样，这边只是吧MyBinder 改成了aidl定义的接口IPerson 本质上还是一个Binder。因为android 5.0 不允许隐形启用service 所有用getExplicitIntent转一下 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之Broadcast Receiver]]></title>
      <url>%2F2016%2F05%2F02%2FReceiver%2F</url>
      <content type="text"><![CDATA[前言基础知识1.Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。广播可以跨进程甚至跨App直接通信。2.你的APP可以接收广播(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。3.广播接收器没有用户界面。然而，它们可以启动一个Activity或Service服务来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 实现流程Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：1.广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册；2.广播发送者通过Binder机制向AMS发送广播；3.AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；4.消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。 广播定义及类型广播定义Android系统在运行的过程中，会产生很多系统广播，比如开机、电量改变、收发短信、拨打电话、屏幕解锁。当然我们也可以发送自定义普通或有序广播。 广播类型1.普通广播：通过Context.sendBroadcast(Intent intent)发送，可以在同一时刻（逻辑上）被所有广播接收者无需等待的接收到。优点：消息传递的效率比较高。缺点：1.接收者不能修改该广播。2.无法终止广播Intent的传播，即无法阻止其他接收者的接收动作。123Intent intent = new Intent("One");intent.putExtra("msg", "这是一条普通广播");sendBroadcast(intent); 2.有序广播：通过Context.sendOrderedBroadcast(intent, receiverPermission)发送，是按照接收者声明的优先级别，被接收者依次接收广播。优点：1、广播可以通过接收者调用abortBroadcast()方法截断广播（被截断的广播不能再继续传递该广播）。2、接收者能修改处理结果（比如通过传递Bundle）传递给下一个接收者（一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播）。缺点：消息传递的效率比普通广播低。123Intent intent2 = new Intent("Two");intent2.putExtra("msg", "这是一条有序广播");sendOrderedBroadcast(intent2, null); 3.系统广播：只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开机启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，由系统自动发出。详见文章末尾附录4.异步广播：通过mContext.sendStickyBroadcast(intent)发送，此广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。其他功能与sendBroadcast相同。但是使用sendStickyBroadcast 发送广播需要获得BROADCAST_STICKY permission，如果没有这个permission则会抛出异常。优点：广播先发送，接收者后注册依然能收到广播。123Intent intent3 = new Intent("Three");intent3.putExtra("msg", "这是一条异步广播");sendStickyBroadcast(intent3); 广播接收者广播接收者定义BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播，且可以做出相关操作。 实现方法第一步：定义广播接收者，继承BroadcastReceiver，并重写onReceive()方法。1234567public class MyReceiver01 extends BroadcastReceiver &#123; @Override public void onReceive(Contextcontext, Intentintent) &#123; //abortBroadcast();//接到的广播为有序的广播则可截断 String s = intent.getStringExtra("msg"); System.out.println("MyReceiver01收到消息："+s); &#125; &#125; 【关于接收的广播类型的说明】 接收的广播为普通广播：1、不可以在onReceive里面截断广播，否则会打印异常。2、不可以处理广播。 接收的广播为有序广播：1、可以在onReceive里面通过abortBroadcast()截断广播，使广播不再传播。2、可以在onReceive里面接收广播Intent携带的数据（String字符串、Bundle对象、或者实现Serializable接口、Parcelable接口的Object对象）。3、可向低优先级接收者传递新的数据，如下代码123456789101112//我是高优先级接收者@Override public void onReceive(Contextcontext, Intentintent) &#123; Bundle bundle = new Bundle(); bundle.putString("next_receiver", "下一个广播接收者"); setResultExtras(bundle); &#125; //我是低优先级接收者@Override public void onReceive(Context context, Intent intent) &#123; Bundle bundle = getResultExtras(true); String content = bundle.getString("next_receiver"); &#125; 第二步：注册感兴趣的广播Intent，注册方法有两种：1、动态注册（在onCreate代码中进行注册）。1234IntentFilter filter = new IntentFilter("感兴趣的广播名、例如上面发送的有序广播：Two"); MyReceiver01 receiver = new MyReceiver01(); intentfilter.setPriority(200);//设置优先级registerReceiver(receiver, filter); 2、静态注册（在AndroidManifest.xml配置文件中注册）。123456&lt;!--prioritys设置优先级--&gt;&lt;receiver android:name=". MyReceiver01"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="感兴趣的广播名、例如上面发送的有序广播：Two"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 【关于优先级别的说明】 设置方法（如上面注册代码所示）：1.静态设置：声明在静态注册的广播接收者的intent-filter元素的android:priority属性中。2.动态设置：调用IntentFilter对象的setPriority()进行声明。 特别说明1.静态注册时设置优先级。数越大优先级别越高,取值范围:-1000到1000。就会先接受到消息。2.动态注册优先级高于任何静态注册。3.如果动态注册和静态注册都有注册，则会执行两次onReceive。4.同级别的接收顺序是随机的。【关于动、静态注册方式特别说明】 静态注册广播：又叫常驻型广播，当你的应用程序关闭了，如果有广播信息来，你写的广播接收器同样的能接受到，他的注册方式就是在你的应用程序中的AndroidManifast.xml进行订阅的。 动态注册广播：又叫非常驻型广播，当应用程序结束了，广播自然就没有了，比如你在Activity中的onCreate或者onResume中订阅广播，同时你必须在onDestory或者onPause中取消广播订阅。不然会报异常，这样你的广播接收器就一个非常驻型的了。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //动态注册BC2 接收者 IntentFilter intentfilter = new IntentFilter("One"); BC2 bc2 = new BC2(); registerReceiver(bc2, intentfilter); &#125;//必须在onDestory取消广播订阅protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(bc2); &#125; 注意：1、动态注册的时候使用的是隐式Intent方式，所以在发送广播的时候需要使用隐式Intent去发送，不然是广播接收者是接收不到广播。2、静态注册的时候，因为在AndroidMainfest.xml中订阅的，所以在发送广播的时候使用显示Intent和隐式Intent都可以所以以防万一，我们一般都采用隐式Intent去发送广播。3、对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext；4、对于动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context； 生命周期。它并不像 Activity 一样复杂，运行原理很简单如下图 广播接收者生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 Service， 由Service 来完成 。 这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的 广播实例为了帮助大家更好的理解，以下写了一个接收系统系统电量广播并处理的小例子。123456789101112131415161718192021222324//第一步，定义广播接收者public class BatteryChangedReceiver extends BroadcastReceiver &#123; private static final String TAG = "BatteryChangedReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0); //当前电量 int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1); //总电量 int percent = currLevel * 100 / total; Log.i(TAG, "battery: " + percent + "%"); &#125; &#125;//第二步，注册广播接收者protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //动态注册电量广播接收者 IntentFilter intentfilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED;); BatteryChangedReceiver batteryChangedReceiver = new BatteryChangedReceiver(); registerReceiver(bc2, intentfilter); &#125;//必须在onDestory取消广播订阅protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(batteryChangedReceiver); &#125; 【附录】 常见系统广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//关闭或打开飞行模式时的广播Intent.ACTION_AIRPLANE_M;//充电状态，或者电池的电量发生变化;//电池的充电状态、电荷级别改变，不能通过组建声;Intent.ACTION_BATTERY_CH;//表示电池电量低Intent.ACTION_BATTERY_LO;//表示电池电量充足Intent.ACTION_BATTERY_OK;//关闭或打开飞行模式时的广播Intent.ACTION_AIRPLANE_MODE_CHANGED;//充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册Intent.ACTION_BATTERY_CHANGED;//表示电池电量低Intent.ACTION_BATTERY_LOW;//表示电池电量充足，即从电池电量低变化到饱满时会发出广播Intent.ACTION_BATTERY_OKAY;//在系统启动完成后，这个动作被广播一次（只有一次）。Intent.ACTION_BOOT_COMPLETED;//按下照相时的拍照按键(硬件按键)时发出的广播Intent.ACTION_CAMERA_BUTTON;//当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息Intent.ACTION_CLOSE_SYSTEM_DIALOGS;//设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java)Intent.ACTION_CONFIGURATION_CHANGED;//设备日期发生改变时会发出此广播Intent.ACTION_DATE_CHANGED;//设备内存不足时发出的广播,此广播只能由系统使用，其它APP不可用Intent.ACTION_DEVICE_STORAGE_LOW;//设备内存从不足到充足时发出的广播,此广播只能由系统使用，其它APP不可用Intent.ACTION_DEVICE_STORAGE_OK;//发出此广播的地方frameworks\base\services\java\com\android\server\DockObserver.javaIntent.ACTION_DOCK_EVENT;//移动APP完成之后，发出的广播(移动是指:APP2SD)Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE;//正在移动APP时，发出的广播(移动是指:APP2SD)Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;//Gtalk已建立连接时发出的广播Intent.ACTION_GTALK_SERVICE_CONNECTED;//Gtalk已断开连接时发出的广播Intent.ACTION_GTALK_SERVICE_DISCONNECTED;//在耳机口上插入耳机时发出的广播Intent.ACTION_HEADSET_PLUG;//改变输入法时发出的广播Intent.ACTION_INPUT_METHOD_CHANGED;//设备当前区域设置已更改时发出的广播Intent.ACTION_LOCALE_CHANGED;//表示用户和包管理所承认的低内存状态通知应该开始。Intent.ACTION_MANAGE_PACKAGE_STORAGE;//未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播 ,扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)Intent.ACTION_MEDIA_BAD_REMOVAL;//按下"Media Button" 按键时发出的广播,假如有"Media Button" 按键的话(硬件按键)Intent.ACTION_MEDIA_BUTTON;//插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播?Intent.ACTION_MEDIA_CHECKING;//已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播, 用户想要移除扩展介质（拔掉扩展卡）。Intent.ACTION_MEDIA_EJECT;//插入SD卡并且已正确安装（识别）时发出的广播, 扩展介质被插入，而且已经被挂载。Intent.ACTION_MEDIA_MOUNTED;//拓展介质存在，但使用不兼容FS（或为空）的路径安装点检查介质包含在Intent.mData领域。Intent.ACTION_MEDIA_NOFS;//外部储存设备已被移除，不管有没正确卸载,都会发出此广播， 扩展介质被移除。Intent.ACTION_MEDIA_REMOVED;//广播：已经扫描完介质的一个目录Intent.ACTION_MEDIA_SCANNER_FINISHED;//请求媒体扫描仪扫描文件并将其添加到媒体数据库。Intent.ACTION_MEDIA_SCANNER_SCAN_FILE;//广播：开始扫描介质的一个目录Intent.ACTION_MEDIA_SCANNER_STARTED;// 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。Intent.ACTION_MEDIA_SHARED;Intent.ACTION_MEDIA_UNMOUNTABLE;//// 广播：扩展介质存在，但是还没有被挂载 (mount)Intent.ACTION_MEDIA_UNMOUNTEDIntent.ACTION_NEW_OUTGOING_CALL;//成功的安装APK之后//广播：设备上新安装了一个应用程序包。//一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播）Intent.ACTION_PACKAGE_ADDED;//一个已存在的应用程序包已经改变，包括包名Intent.ACTION_PACKAGE_CHANGED;//清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?)//用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播）Intent.ACTION_PACKAGE_DATA_CLEARED;//触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？Intent.ACTION_PACKAGE_INSTALL;//成功的删除某个APK之后发出的广播, 一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播）Intent.ACTION_PACKAGE_REMOVED;//替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？）Intent.ACTION_PACKAGE_REPLACED;//用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播）Intent.ACTION_PACKAGE_RESTARTED;//插上外部电源时发出的广播Intent.ACTION_POWER_CONNECTED;//已断开外部电源连接时发出的广播Intent.ACTION_POWER_DISCONNECTED;Intent.ACTION_PROVIDER_CHANGED;////重启设备时的广播Intent.ACTION_REBOOT;//屏幕被关闭之后的广播Intent.ACTION_SCREEN_OFF;//屏幕被打开之后的广播Intent.ACTION_SCREEN_ON;//关闭系统时发出的广播Intent.ACTION_SHUTDOWN;//时区发生改变时发出的广播Intent.ACTION_TIMEZONE_CHANGED;//时间被设置时发出的广播Intent.ACTION_TIME_CHANGED;//广播：当前时间已经变化（正常的时间流逝）， 当前时间改变，每分钟都发送，不能通过组件声明来接收，只有通过Context.registerReceiver()方法来注册Intent.ACTION_TIME_TICK;//一个用户ID已经从系统中移除发出的广播Intent.ACTION_UID_REMOVED;//设备已进入USB大容量储存状态时发出的广播？Intent.ACTION_UMS_CONNECTED;//设备已从USB大容量储存状态转为正常状态时发出的广播？Intent.ACTION_UMS_DISCONNECTED;Intent.ACTION_USER_PRESENT;////设备墙纸已改变时发出的广播Intent.ACTION_WALLPAPER_CHANGED; 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之Activity]]></title>
      <url>%2F2016%2F04%2F24%2FActivity%2F</url>
      <content type="text"><![CDATA[基础知识回顾定义及功能 一个Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务，例如拨号、拍照、发送email、看地图。每一个activity被给予一个窗口，在上面可以绘制用户接口。窗口通常充满屏幕，但也可以小于屏幕而浮于其它窗口之上。 启动和栈 一个应用程序通常由多个activities组成，他们通常是松耦合关系。通常，一个应用程序中的activity被指定为”main”activity，当第一次启动应用程序的时候呈现给用户的那个activity。每一个activity然后可以启动另一个activity为了完成不同的动作。每一次一个activity启动，前一个activity就停止了，但是系统保留activity在一个栈上（“back stack”）。当一个新activity启动，它被推送到栈顶，取得用户焦点。Back Stack符合简单“后进先出”原则，所以，当用户完成当前activity然后点击back按钮，它被弹出栈（并且被摧毁），然后之前的activity恢复。 基本用法 基本用法：Activity的本质是一个Java类，如：由我们创建工程生成的MainActivity；一般的每个Activity都会存在一个与它匹配的布局文件（xml文件），由它来写入我们需要Activity展示的各种控件和布局。有了布局文件之后，就需要在类里通过OnCreate方法的setContentView方法调用文件资源ID来初始化UI界面和显示。 创建和注册 每个需要显示的Activity都需要我们在工程包下的AndroidMainifest.xml文件进行注册！（注意：程序每次打开时显示的Activity我们称为主界面，它的注册和其他Activity注册有区别）12345678&lt;!--主Activity--&gt;&lt;activity Android:name=”.MainActivity”&gt; &lt;intent-filter&gt; &lt;action android:name=”android.intent.action.MAIN”/&gt; &lt;category android:name=”android.intent.category.LAUNCHER”/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 主界面显示的Activity加入了标签和内部的两句声明，这也是必须的。 元素指定这是一个”main”入口点对这个应用程序。元素指定，这个activity应该被列入系统应用程序列表中（为了允许用户启动这个activity）。此外如果你的应用程序里没有声明任何主活动，它也是可以安装的，只是你无法在启动器中看见或打开，这种程序一般作为第三方服务供其他应用在内部进行调用，如支付宝的快捷支付应用。 生命周期四种状态 运行状态：当Activity位于栈顶时，此时正好处于屏幕最前方。暂停状态：当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕）。停止状态：当Activity被其他Activity完全遮挡，此时此Activity对用户不可见。销毁状态：当Activity由于人为或系统原因（如低内存等）被销毁。 七个回调方法1.onCreate：活动第一次创建被调用。2.onStart：活动由不可见变为可见的时候调用。3.onResume：活动处于与用户交互状态时候调用。4.onPause：活动失去焦点时被调用。5.onStop：活动完全不可见的时候调用（如果新活动是一个对话框式活着半透明的活动，onPause会执行，而onStop不会执行）。6.onDestroy：在活动被销毁之前调用。7.onRestart：由停止状态变为运行状态之前调用。 生命周期图 详解 在实际应用场景中，假设A Activity位于栈顶，此时用户操作，从A Activity跳转到B Activity。那么对AB来说，具体会回调哪些生命周期中的方法呢？回调方法的具体回调顺序又是怎么样的呢？ 开始时，A被实例化，执行的回调有A:onCreate -&gt; A:onStart -&gt; A:onResume。 当用户点击A中按钮来到B时，假设B全部遮挡住了A，将依次执行A:onPause -&gt; B:onCreate -&gt; B:onStart -&gt; B:onResume -&gt; A:onStop。 此时如果点击Back键，将依次执行B:onPause -&gt; A:onRestart -&gt; A:onStart -&gt; A:onResume -&gt; B:onStop -&gt; B:onDestroy。 至此，Activity栈中只有A。在Android中，有两个按键在影响Activity生命周期这块需要格外区分下，即Back键和Home键。我们先直接看下实验结果： 此时如果按下Back键，系统返回到桌面，并依次执行A:onPause -&gt; A:onStop -&gt; A:onDestroy。 此时如果按下Home键（非长按），系统返回到桌面，并依次执行A:onPause -&gt; A:onStop。由此可见，Back键和Home键主要区别在于是否会执行onDestroy。 扩展 不少应用程序都是采取如Home键的效果，当点击了Back键，系统返回到桌面，然后点击应用程序图标，直接回到之前的Activity界面，这种效果是怎么实现的呢？ 通过重写按下Back键的回调函数，转成Home键的效果即可。123456@Overridepublic void onBackPressed() &#123; Intent home = new Intent(Intent.ACTION_MAIN); home.addCategory(Intent.CATEGORY_HOME); startActivity(home);&#125; 当然，此种方式通过Home键效果强行影响到Back键对Activity生命周期的影响。注意，此方法只是针对按Back键需要退回到桌面时的Activity且达到Home效果才重写。或者，为达到此类效果，Activity实际上提供了直接的方法。activity.moveTaskToBack(true);moveTaskToBack()此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态。 Activity跳转startActivity()。 Intent的两种用法：显示Intent和隐式Intent。 （1）显示Intent一般使用方法：123Intent intent=newIntent(FirstActivity.this,SecondActivity.class); startActivity(intent); //简单的两行就能实现第一个活动跳转到第二个活动界面。 （2）隐式Intent一般使用方法：123456789&lt;!--首先需要在注册第二个活动时加入标签--&gt;&lt;!-- 必须指定CATEGORY_DEFAULT，只有这样startActivity(intent)才能找到 --&gt; &lt;!--注意 Intent Filter顾名思义就是Intent的过滤器，组件通过定义Intent Filter可以决定哪些隐式 --&gt; &lt;activity android:name=”.SecondAcivity”&gt; &lt;intent-filter&gt; &lt;action android:name=”包名.ACTION_START”/&gt; &lt;category android:name=”android.intent.category.DEFAULT”/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 这样我们就可以用声明的标签来启动隐式Intent12Intent intent=new Intent(“包名.ACTION_START”); startActivity(intent); （3）两者的使用区别 显式意图一般在应用的内部使用，因为在应用内部已经知道了组件的名称，直接调用就可以了。当一个应用要激活另一个应用中的Activity时，只能使用隐式意图，根据Activity配置的意图过滤器建一个意图，让意图中的各项参数的值都跟过滤器匹配，这样就可以激活其他应用中的Activity。所以，隐式意图是在应用与应用之间使用的。 系统意图 Intent可以指定你希望启动或描述完成的动作（操作系统会为你选择合适的Activity，可能来自定不同的应用程序）。 你的应用程序或许希望执行一些动作，例如发送一份邮件、文件消息或者状态更新，使用你的Activity的数据。在这种情况下，你的应用程序或许没有它自己的Activity来完成这个动作，因此你可以促使设备上其它应用程序提供的Activity来完成你的动作。这才是Intent真正有价值的地方－－你可以创建一个Intent描述一个你希望执行的动作，然后系统启动一个合适的activity从其它应用程序。如果有多种Activities可以处理这个Intent，那么 用户可以选择哪一个来执行。例如，如果你希望允许用户发送邮件，你可以创建下面的Intent:123Intent intent= new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL,""); startActivity(intent); （常用意图见文章末尾附录。） 数据通信 一个Intent可以传输小量数据被启动的activity使用。 在启动活动时，Intent中提供了一系列putExtra()方法的重载，可以将我们需要传递的数据暂存在Intent中，在打开另一个活动时，从Intent中取出即可。 具体例子： （1）比如我们想要传递一个String字符串123456String data=”Hello world!”; Intent intent=newIntent(FirstActivity.this,SecondActivity.class); Intent.putExtra(“extra_data”,data);//extra_data是一个标签，data是传入的数据。 //相当于Intent对象具有Map键值对功能。startActivity(intent); 然后在SecondActivity的Oncreate方法里取出Intent存入的数据1234Intent intent=getIntent(); String data=intent.getStringExtra(“extra_data”);//用String接收带extra_data标签的数据 Log.d(“SecondActivity”,data);//打印出data （2）新建一个Bundle对象 ，想该对象中加入键值对，然后将该对象加入Intent中12345678Intent intent=new Intent();Bundle bundle = new Bundle(); bundle.putString("first", "zhang"); bundle.putInt("age", 20); intent.putExtras(bundle); intent.setClass(ActivityMain.this, SecondActivity.class);intent.putExtras(bundle);startActivity(intent); 然后在第二个Activity中接收 1234 Bundle bundle = new Bundle(); bundle = this.getIntent().getExtras();String a = bundle.getString("first");int b = Integer.parseInt(bundle.getString("age")); （3）Intent传递Object对象 Android中Intent传递类对象提供了两种方式一种是 通过实现Serializable接口传递对象，一种是通过实现Parcelable接口传递对象。要求被传递的对象必须实现上述2种接口中的一种才能通过Intent直接传递。Intent中传递这2种对象的方法：12Bundle.putSerializable(Key,Object); //实现Serializable接口的对象Bundle.putParcelable(Key, Object); //实现Parcelable接口的对象 以下以最常用的Serializable方式为例 ： 假设由登录界面（Login）跳转到主界面（MainActivity）传递的对象为登录的用户信息 User类 首先创建一个序列化类：User 123456789101112131415161718192021222324252627282930 import java.io.Serializable; public class User implements Serializable &#123; private int ID; private String UserName; private String PWD; public final void setID(int value) &#123; ID = value; &#125; public final int getID() &#123; return ID; &#125; public final void setUserName(String value) &#123; UserName = value; &#125; public final String getUserName() &#123; return UserName; &#125; public final void setPWD(String value) &#123; PWD = value; &#125; public final String getPWD() &#123; return PWD; &#125; &#125; MainActivity传递内容123456Intent intent = new Intent();intent.setClass(MainActivity.this, SecondActivity.class);Bundle bundle = new Bundle();bundle.putSerializable("user", user);intent.putExtras(bundle);this.startActivity(intent); SecondActivity接收12Intent intent = this.getIntent(); user=(User)intent.getSerializableExtra("user"); 以上就可以实现对象的传递。补充：如果传递的是List,可以把list强转成Serializable类型,而且object类型也必须实现了Serializable接口 1Intent.putExtras(key, (Serializable)list) 接收1(List&lt;YourObject&gt;)getIntent().getSerializable(key) 【补充】 parcelable和Serializable的区别又是什么呢？ Serializable的作用是保存对象的属性到本地文件，数据库，网络流等方便数据传输，也可程序之间传递。 **parcelable**的设计的目的是为了解决Serializable效率不高的问题，内存开销小，所以在内存间传递数据的方式用parcelable，缺点是不能持久化。 startActivityForResult() Activity退出时返回结果至前一个Activity1234// 1.通过startActivityForResult方式启动一个新Activity Intent intent=newIntent(FirstActivity,this,SecondActivity.class); startActivityForResult(intent, 200); //参数为intent对象， requestCode请求码 1234567// 2.新Activity设定setResult方法，通过该方法可以传递responseCode 和 Intent对象 Intent intent=new Intent(); //Intent中也可以传递BundleIntent.putExtra(“data_return”,”Helloworld!”); setResult(101,intent); //参数为responseCode响应码 和 intent对象 finish(); 123456789// 3.在MainActivity中覆写onActivityResult方法，新Activity一旦退出，就会执行该方法 protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); //如果请求标识与返回标识一样,则把数据返回到tv上 if (requestCode == 200 &amp; resultCode ==101) &#123; String s = data.getStringExtra("data_return"); tv.setText(s); &#125;&#125; 启动模式四种启动模式 standard（标准模式）：每当启动一个新活动，它都会进入返回栈并位于栈顶的位置，这种模式下，系统不会在乎这个活动是否已经存在于返回栈中，每次启动都会创建并都放在栈顶。 singleTop（栈顶复用）：在启动活动时如果发现栈中该活动已经位于栈顶，则重用该实例( 会调用实例的onNewIntent() )而不会创建新的实例。若不在栈顶，则会创建新的实例。 singleTask（栈内复用）：启动活动时如果发现栈中已经存在该活动，则重用该实例(会调用实例的 onNewIntent() )，并且将位于它之上的活动统统出栈，如果没有发现就会新建一个实例。 singleIntance（单例模式）：会有一个单独的返回栈来管理这个活动，而且栈中只有此活动，不管是任何一个程序来访问这个活动，都共用这个返回栈，也就解决了共享活动的问题。 设置方法：在AndroidMainifest.xml文件中activity标签name之下加入声明：Android:launchMode=” standard、singleTop、singleTask、singleInstance(四选一)”这样就可以配置活动的启动模式了。 详解standard standard模式是默认的启动模式，不用为配置android:launchMode属性即可，当然也可以指定值为standard。 我们将会一个Activity，命名为FirstActivity，来演示一下标准的启动模式。FirstActivity代码如下：1234567891011121314public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first); TextView textView = (TextView) findViewById(R.id.textView); textView.setText(this.toString()); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, FirstActivity.class); startActivity(intent); &#125; &#125;); &#125; 我们FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。然后我们连续点击几次按钮，将会出现下面的现象我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FristActivity。standard模式的原理如下图所示如图所示，每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。 详解singleTop 我们在上面的基础上为指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象： 我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。singleTop模式的原理如下图所示： 正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。 我们再新建一个Activity命名为SecondActivity，如下：1234567891011121314protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.second); TextView textView = (TextView) findViewById(R.id.textView); textView.setText(this.toString()); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(SecondActivity.this, FirstActivity.class); startActivity(intent); &#125; &#125;); &#125; 然后将之前的FirstActivity跳转代码改为：12Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); 是的，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。演示结果如下：我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。原理图如下：我们看到，当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。 详解singleTask 在上面的基础上我们修改FirstActivity的属性android:launchMode=”singleTask”。演示的结果如下： 我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。singleTask模式的原理图如下图所示： 在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，SecondActivity消失了，没错，在这个跳转过程中系统发现有存在的FirstActivity实例，于是不再生成新的实例，而是将FirstActivity之上的Activity实例统统出栈，将FirstActivity变为栈顶对象，显示到幕前。也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。 这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。 详解singleInstance 这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。 我们修改FirstActivity的launchMode=”standard”，SecondActivity的launchMode=”singleInstance”，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码：12TextView taskIdView = (TextView) findViewById(R.id.taskIdView); taskIdView.setText("current task id: " + this.getTaskId()); 然后我们再演示一下这个流程：我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下：我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示：singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：12345678910&lt;activity android:name=".ShareActivity" android:launchMode="singleInstance"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SINGLE_INSTANCE_SHARE" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后我们在其他应用中这样启动该Activity：12Intent intent = new Intent("android.intent.action.SINGLE_INSTANCE_SHARE"); startActivity(intent); 当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。大家可以在ShareActivity中打印一下taskId，看看效果。关于这个过程，原理图如下： 启动模式应用场景 singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。所以要从外界尽可能多的跳转到一个界面。 singleTask适合作为程序入口点。例如浏览器的主界面、联系人activity。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance适合需要与程序分离开的页面。这种模式的使用情况比较罕见，例如闹铃提醒，将闹铃提醒与闹铃设置分离。呼叫来电界面。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，再次启动，首先打开的是B。 总结 LauncherMode 分为两组： 第一组standard和SingleTop是一组用的比较多，他们二个唯一的区别就是SingleTop如果在当前Task的顶部，同时在startActivity()这个Activity的时候就不会再创建新的实例，而是执行该实例的onNewIntent()方法，其他情况下的用法是一样的； 第二组SingleTask和SingleIntance这一组用的比较少，要结合特定情况来使用，这一组的使用区别是比较大的，在我们开发APP的过程中要合理的使用Activity的启动模式来使我们的APP更加的快捷，流畅，提高用户体验。如果有写的不好的还忘指点。 其他补充Activity中finish() onDestroy() 和System.exit()的区别 Activity.finish()Call this when your activity is done and should be closed.在你的activity动作完成的时候，或者Activity需要关闭的时候，调用此方法。当你调用此方法的时候，系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory()方法，其占用的资源也没有被及时释放。因为移出了栈，所以当你点击手机上面的“back”按键的时候，也不会再找到这个Activity。 Activity.onDestory()the system is temporarily destroying this instance of the activity to save space.系统销毁了这个Activity的实例在内存中占据的空间。在Activity的生命周期中，onDestory()方法是他生命的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法。 System.exit(0)这玩意是退出整个应用程序的，是针对整个Application的。将整个进程直接KO掉。 finish函数仅仅把当前Activity退出了，但是并没有释放他的资源。安卓系统自己决定何时从内存中释放应用程序。当系统没有可用内存到时候，会按照优先级，释放部分应用。 AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别 support v4 FragmentActivity 兼容2.x模式下使用Fragmentsupport v7 AppCompatActivity 兼容2.x模式下使用Fragment和ActionBar，ActionBarActivity是AppCompatActivity过时产品如果3.0以上直接继承Activity，便可使用Fragment和ActionBar 资源内存不足导致低优先级Activity被杀死 Activity优先级前台Activity——正在和用户交互的Activity，优先级最高可见但非前台Activity——Activity中弹出的对话框导致Activity可见但无法交互后台Activity——已经被暂停的Activity，优先级最低系统内存不足是，会按照以上顺序杀死Activity，并通过onSaveInstanceState和onRestoreInstanceState这两个方法来存储和恢复数据。 ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。12345678910111213141516171819202122232425262728ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE) ; //获得系统运行的进程 List&lt;ActivityManager.RunningAppProcessInfo&gt; appList1 = mActivityManager .getRunningAppProcesses(); for (RunningAppProcessInfo running : appList1) &#123; System.out.println(running.processName); &#125; System.out.println(&quot;================&quot;); //获得当前正在运行的service List&lt;ActivityManager.RunningServiceInfo&gt; appList2 = mActivityManager .getRunningServices(100); for (ActivityManager.RunningServiceInfo running : appList2) &#123; System.out.println(running.service.getClassName()); &#125; System.out.println(&quot;================&quot;); //获得当前正在运行的activity List&lt;ActivityManager.RunningTaskInfo&gt; appList3 = mActivityManager .getRunningTasks(1000); for (ActivityManager.RunningTaskInfo running : appList3) &#123; System.out.println(running.baseActivity.getClassName()); &#125; System.out.println(&quot;================&quot;); //获得最近运行的应用 List&lt;ActivityManager.RecentTaskInfo&gt; appList4 = mActivityManager .getRecentTasks(100, 1); for (ActivityManager.RecentTaskInfo running : appList4) &#123; System.out.println(running.origActivity.getClassName()); &#125; 【附录】 常用Intent意图表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//(1).调用拨号程序Uri uri = Uri.parse("tel:10086"); Intent intent = new Intent(Intent.ACTION_DIAL, uri); startActivity(intent); //(2).发送短信或者彩信//发生短信Uri uri = Uri.parse("smsto:10086"); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); intent.putExtra("sms_body", "Hello"); startActivity(intent); //发送彩信，相当于发送带附件的短信Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra("sms_body", "Hello"); Uri uri = Uri.parse("content://media/external/images/media/23"); intent.putExtra(Intent.EXTRA_STREAM, uri); intent.setType("image/png"); startActivity(intent); //(3).通过浏览器打开网页Uri uri = Uri.parse("http://www.google.com"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent);//(4).发送电子邮件Uri uri = Uri.parse("mailto:someone@domain.com"); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); startActivity(intent); //给someone@domain.com发邮件发送内容为“Hello”的邮件 Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL, "someone@domain.com"); intent.putExtra(Intent.EXTRA_SUBJECT, "Subject"); intent.putExtra(Intent.EXTRA_TEXT, "Hello"); intent.setType("text/plain"); startActivity(intent); // 给多人发邮件 Intent intent=new Intent(Intent.ACTION_SEND); String[] tos = &#123;"1@abc.com", "2@abc.com"&#125;; // 收件人 String[] ccs = &#123;"3@abc.com", "4@abc.com"&#125;; // 抄送 String[] bccs = &#123;"5@abc.com", "6@abc.com"&#125;; // 密送 intent.putExtra(Intent.EXTRA_EMAIL, tos); intent.putExtra(Intent.EXTRA_CC, ccs); intent.putExtra(Intent.EXTRA_BCC, bccs); intent.putExtra(Intent.EXTRA_SUBJECT, "Subject"); intent.putExtra(Intent.EXTRA_TEXT, "Hello"); intent.setType("message/rfc822"); startActivity(intent); //(5).显示地图与路径规划// 打开Google地图中国北京位置（北纬39.9，东经116.3） Uri uri = Uri.parse("geo:39.9,116.3"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); // 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4） Uri uri = Uri.parse("http://maps.google.com/maps?f=d&amp;saddr=39.9 116.3&amp;daddr=31.2 121.4"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //(6).播放多媒体Intent intent = new Intent(Intent.ACTION_VIEW); Uri uri = Uri.parse("file:///sdcard/foo.mp3"); intent.setDataAndType(uri, "audio/mp3"); startActivity(intent); Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //(7).拍照// 打开拍照程序 Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(intent, 0); // 取出照片数据 Bundle extras = intent.getExtras(); Bitmap bitmap = (Bitmap) extras.get("data"); //(8).获取并剪切图片// 获取并剪切图片 Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType("image/*"); intent.putExtra("crop", "true"); // 开启剪切 intent.putExtra("aspectX", 1); // 剪切的宽高比为1：2 intent.putExtra("aspectY", 2); intent.putExtra("outputX", 20); // 保存图片的宽和高 intent.putExtra("outputY", 40); intent.putExtra("output", Uri.fromFile(new File("/mnt/sdcard/temp"))); // 保存路径 intent.putExtra("outputFormat", "JPEG");// 返回格式 startActivityForResult(intent, 0); // 剪切特定图片 Intent intent = new Intent("com.android.camera.action.CROP"); intent.setClassName("com.android.camera", "com.android.camera.CropImage"); intent.setData(Uri.fromFile(new File("/mnt/sdcard/temp"))); intent.putExtra("outputX", 1); // 剪切的宽高比为1：2 intent.putExtra("outputY", 2); intent.putExtra("aspectX", 20); // 保存图片的宽和高 intent.putExtra("aspectY", 40); intent.putExtra("scale", true); intent.putExtra("noFaceDetection", true); intent.putExtra("output", Uri.parse("file:///mnt/sdcard/temp")); startActivityForResult(intent, 0); //(9).打开Google Market// 打开Google Market直接进入该程序的详细页面 Uri uri = Uri.parse("market://details?id=" + "com.demo.app"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //(10).安装和卸载程序Uri uri = Uri.fromParts("package", "com.demo.app", null); Intent intent = new Intent(Intent.ACTION_DELETE, uri); startActivity(intent); //(11).进入设置界面// 进入无线网络设置界面（其它可以举一反三） Intent intent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);startActivityForResult(intent, 0); 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
  
  
</search>

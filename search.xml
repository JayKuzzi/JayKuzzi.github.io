<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[Java设计模式 —— 工厂模式]]></title>
      <url>%2F2017%2F07%2F09%2FFactory%2F</url>
      <content type="text"><![CDATA[简述工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。 工厂模式的作用直接目的：避免在代码中出现大量的new关键字根本目的：将对象的创建统一起来便于维护和整体把控假如你在项目中new了某个对象100次，一年后由于业务逻辑变更，构造方法多了一个参数，你会怎么办？你应该会这么做：找到这100个对象new的地方，用新的构造方法来创建对象，你重复劳动了100次，假如采用工厂模式，你只用改一次：把创建工厂给改一下就好了。这就是工厂模式最简单最直接的好处。 工厂模式的分类1）简单工厂模式（Simple Factory）：不利于产生系列产品；2）工厂方法模式（Factory Method）：又称为多形性工厂；3）抽象工厂模式（Abstract Factory）：又称为工具箱，产生产品族，但不利于产生新的产品； 简单工厂模式简单工厂模式又称静态工厂方法模式。它存在的目的很简单：定义一个用于创建对象的接口。 组成1) 工厂类角色：这是本模式的核心，含有一定的商业逻辑和判断逻辑。在java中它往往由一个具体类实现。2) 抽象产品角色：它一般是具体产品继承的父类或者实现的接口。在java中由接口或者抽象类来实现。3) 具体产品角色：工厂类所创建的对象就是此角色的实例。在java中由一个具体类实现。 实现1234567891011121314151617181920212223//抽象产品接口public interface Products &#123; void run();&#125;//具体产品类class Plane implements Products &#123; @Override public void run() &#123; System.out.println("plane...."); &#125;&#125;class Ship implements Products &#123; @Override public void run() &#123; System.out.println("ship....."); &#125;&#125;class Car implements Products &#123; @Override public void run() &#123; System.out.println("car....."); &#125;&#125; 123456789101112131415161718//工厂类public class SimpleFactory &#123; public static Products createProduct(String name)&#123; Products product = null; switch (name)&#123; case "CAR": product = new Car(); break; case "SHIP": product = new Ship(); break; case "PLANE": product = new Plane(); break; &#125; return product; &#125;&#125; 12345678//客户端public class Client &#123; public static void main(String[] args) &#123; SimpleFactory.createProduct("CAR").run(); SimpleFactory.createProduct("SHIP").run(); SimpleFactory.createProduct("PLANE").run(); &#125;&#125; 优缺点优点：1、不需要知道用户怎么创建的，只管调用就行，就是对产品类名进行了隐蔽。2、实现简单，实现了客户端与具体实现类的解耦。缺点：1、违反了“开闭原则（扩展开放，修改关闭）”，比如要新增产品，必须要修改工厂。2、指责过多，一旦工厂出问题，整个系统受影响。 工厂方法模式是简单工厂模式的进一步推广，不再只由一个工厂类决定那一个产品类应当被实例化,这个决定被交给抽象工厂的子类去做。 组成1)抽象工厂角色： 这是工厂方法模式的核心，它与应用程序无关。是具体工厂角色必须实现的接口或者必须继承的父类。在java中它由抽象类或者接口来实现。2)具体工厂角色：它含有和具体业务逻辑有关的代码。由应用程序调用以创建对应的具体产品的对象。3)抽象产品角色：它是具体产品继承的父类或者是实现的接口。在java中一般有抽象类或者接口来实现。4)具体产品角色：具体工厂角色所创建的对象就是此角色的实例。在java中由具体的类来实现。 实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//抽象产品角色public interface Products &#123; void run();&#125;//具体产品角色//具体产品类class Plane implements Products &#123; @Override public void run() &#123; System.out.println("plane...."); &#125;&#125;class Ship implements Products &#123; @Override public void run() &#123; System.out.println("ship....."); &#125;&#125;class Car implements Products &#123; @Override public void run() &#123; System.out.println("car....."); &#125;&#125;//抽象工厂public abstract class VehicleFactory &#123; public abstract Products create();&#125;//具体工厂public class PlaneFactory extends VehicleFactory&#123; @Override public Products create() &#123; return new Plane(); &#125;&#125;public class ShipFactory extends VehicleFactory&#123; @Override public Products create() &#123; return new Ship(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; VehicleFactory vehicleFactory = new PlaneFactory(); vehicleFactory.create().run(); VehicleFactory vehicleFactory1 = new ShipFactory(); vehicleFactory1.create().run(); &#125;&#125; 优缺点优点：1、相对简单工厂模式，去掉了简单工厂模式中工厂方法的静态属性，分担了工厂类对象承受的压力。2、符合“开闭原则（扩展开放，修改关闭）”，当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，而不必去修改任何已有的代码（比如抽象工厂）。缺点：在添加新产品时，需要编写新的具体产品类，且要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 抽象工厂模式抽象工厂模式是工厂方法模式的升级版本，他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在抽象工厂模式中，抽象产品 (AbstractProduct) 可能是一个或多个，从而构成一个或多个产品族(Product Family)。 在只有一个产品族的情况下，抽象工厂模式实际上退化到工厂方法模式。 组成同工厂方法模式 结构 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172//抽象食物接口public interface Food &#123; void eat();&#125;//具体食物类class ChinaFood implements Food &#123; @Override public void eat() &#123; System.out.println("ChinaFood...."); &#125;&#125;class UKFood implements Food &#123; @Override public void eat() &#123; System.out.println("UKFood....."); &#125;&#125;//抽象水果接口public interface Fruit &#123; void eat();&#125;//具体水果类class ChinaFruit implements Fruit &#123; @Override public void eat() &#123; System.out.println("ChinaFruit...."); &#125;&#125;class UKFruit implements Fruit &#123; @Override public void eat() &#123; System.out.println("UKFruit....."); &#125;&#125;//抽象工厂public abstract class AbstractFactory &#123; public abstract Food createFood(); public abstract Fruit createFruit();&#125;//具体工厂public class ChinaFactory extends AbstractFactory&#123; @Override public Food createFood() &#123; return new ChinaFood(); &#125; @Override public Fruit createFruit() &#123; return new ChinaFruit(); &#125;&#125;public class UKFactory extends AbstractFactory&#123; @Override public Food createFood() &#123; return new UKFood(); &#125; @Override public Fruit createFruit() &#123; return new UKFruit(); &#125;&#125;//测试类public class Client &#123; public static void main(String[] args) &#123; ChinaFactory chinaFactory = new ChinaFactory(); chinaFactory.createFruit().eat(); chinaFactory.createFood().eat(); UKFactory ukFactory = new UKFactory(); ukFactory.createFruit().eat(); ukFactory.createFood().eat(); &#125;&#125; 优缺点优点：1、所有的具体工厂都实现了抽象工厂中定义的公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。2、当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。缺点：1、在添加新的产品对象时，难以扩展抽象工厂来生产新种类的产品，这是因为在抽象工厂角色中规定了所有可能被创建的产品集合，要支持新种类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改，显然会带来较大的不便。2、开闭原则的倾斜性（增加新的工厂和产品族容易，增加新的产品等级结构麻烦） 使用情况以下情况下可以使用抽象工厂模式1、一个系统不依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。2、系统中有多于一个的产品族，而每次只使用其中某一产品族。3、属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。4、系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[开发面试经验总结]]></title>
      <url>%2F2017%2F04%2F05%2FJavaReview%2F</url>
      <content type="text"><![CDATA[OSI模型OSI模型基础知识速览 五层协议的体系结构 TCP协议三次握手（建立连接）TCP(Transmission Control Protocol) 传输控制协议。TCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接。TCP报文段首部格式：（1）序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。（2）确认号ack：期待收到对方下一个报文段的第一个数据字节的序号（3）标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：（A）URG：紧急指针（urgent pointer）有效。（B）确认ACK：确认序号有效。占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效。（C）PSH：接收方应该尽快将这个报文交给应用层。（D）RST：重置连接。（E）同步SYN：发起一个新连接。连接建立时用于同步序号。当SYN=1，ACK=0时表示：这是一个连接请求报文段。（F）FIN：释放一个连接。 若同意连接，则在响应报文段中使得SYN=1，ACK=1。因此，SYN=1表示这是一个连接请求，或连接接受报文。终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接 过程第一次握手：请求连接时，客户端发送SYN=1，ACK=0(连接请求报文段)、自己的seq序号x到服务器，并进入SYN_SEND状态，等待服务器确认；第二次握手：服务器收到请求，发送SYN=1，ACK=1(连接响应报文段)、自己的seq序号y、确认号ack=x+1，到客户端表示连接接受，此时服务器进入SYN_RECV状态；第三次握手：客户端收到后检查ack是否正确，即第一次发送的seq(x)+1,以及确认ACK是否为1，若正确再次回应服务器端一个确认ACK=1、确认号ack=y+1和seq(x)+1确认数据段。客户端和服务器进入ESTABLISHED状态完成三次握手，主机A与主机B开始传送数据。重点分析还要再发送一次确认是为了，防止已失效的连接请求报文段突然又传到了B，因而产生错误。已失效的报文段：正常情况下：A发出连接请求，但因为丢失了，故而不能收到B的确认。于是A重新发出请求，然后收到确认，建立连接，数据传输完毕后，释放连接，A发了2个，一个丢掉，一个到达，没有“已失效的报文段”。但是，某种情况下，A的第一个在某个节点滞留了，延误到达，本来这是一个早已失效的报文段，但是在A发送第二个，并且得到B的回应，建立了连接以后，这个报文段竟然到达了，于是B就认为，A又发送了一个新的请求，于是发送确认报文段，同意建立连接，假若没有三次的握手，那么这个连接就建立起来了（有一个请求和一个回应），此时，A收到B的确认，但A知道自己并没有发送建立连接的请求，因为不会理睬B的这个确认，于是呢，A也不会发送任何数据，而B呢却以为新的连接建立了起来，一直等待A发送数据给自己，此时B的资源就被白白浪费了。但是采用三次握手的话，A就不发送确认，那么B由于收不到确认，也就知道并没有要求建立连接。 四次握手（释放连接）终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接步骤（1）第一次挥手：客户端A发送一个FIN、自己的seq序号u用来关闭客户A到服务器B的数据传送。Client进入FIN_WAIT_1状态。（2）第二次挥手：服务器B收到这个FIN，它发回一个ACK=1、ack=u+1、自己的序号seq=v，Server进入CLOSE_WAIT状态。（3）第三次挥手：Server发送一个FIN、自己的序号seq=w，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。（4）第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发给Server一个ACK=1、ack=w+1、自己的序号seq=u+1，Server进入CLOSED状态，完成四次挥手。 总结为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。但关闭连接时，ACK却没有和FIN一起发送，原因是因为tcp是全双工模式，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可以未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的.为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？①、为了保证A发送的最后一个ACK报文段能够到达B。即最后这个确认报文段很有可能丢失，那么B会超时重传，然后A再一次确认，同时启动2MSL计时器，如此下去。如果没有等待时间，发送完确认报文段就立即释放连接的话，B就无法重传了（连接已被释放，任何数据都不能出传了），因而也就收不到确认，就无法按照步骤进入CLOSE状态，即必须收到确认才能close。②、防止“已失效的连接请求报文段”出现在连接中。经过2MSL，那些在这个连接持续的时间内，产生的所有报文段就可以都从网络中消失。即在这个连接释放的过程中会有一些无效的报文段滞留在楼阁结点，但是呢，经过2MSL这些无效报文段就肯定可以发送到目的地，不会滞留在网络中。这样的话，在下一个连接中就不会出现上一个连接遗留下来的请求报文段了。可以看出：B结束TCP连接的时间比A早一点，因为B收到确认就断开连接了，而A还得等待2MSL. 强引用、软引用、弱引用、虚引用相关链接三种类型的引用定义了三种不同层次的可达性级别，由强到弱排列如下：SoftReference &gt; WeakReference &gt; PhantomReference越弱表示对垃圾回收器的限制越少，对象越容易被回收。强引用：以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。1List&lt;String&gt; list = new Arraylist&lt;String&gt;(); list集合里的数据不会释放，即使内存不足也不会软引用：如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用通过SoftReference类来实现弱引用：如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 弱引用通过weakReference类来实现虚引用：“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。 关于内部类Java成员内部类中为什么不能定义静态变量静态变量是要占用内存的，在编译时只要是定义为静态变量了，系统就会自动分配内存给他，而内部类是在宿主类编译完编译的，也就是说，必须有宿主类存在后才能有内部类，这也就和编译时就为静态变量分配内存产生了冲突，因为系统执行：运行宿主类-&gt;静态变量内存分配-&gt;内部类，而此时内部类的静态变量先于内部类生成，这显然是不可能的，所以不能定义静态变量！ 成员内部类 与 静态内部类差别1、静态内部类和普通的类一样，内部类也可以有静态的。不过和非静态内部类相比，区别就在于静态内部类没有了指向外部的引用，正因如此 不可访问外部类的成员变量。2、静态内部类中可以拥有静态数据，静态方法。3、内部类new方式不同成员内部类获得内部类：(I)在外部类作用范围之外得到内部类对象是第一个方法(II)创建外部类对象，用外部类引用去创建内部类 原因：非静态内部类对象有着指向其外部类对象的引用（比如它为何可以访问外部类变量）要想实现这个功能，内部类对象就必须有指向外部类对象的引用。Java编译器在创建内部类对象时，隐式的把其外部类对象的引用也传了进去并一直保存着。这样就使得内部类对象始终可以访问其外部类对象，同时这也是为什么在外部类作用范围之外向要创建内部类对象必须先创建其外部类对象的原因。静态内部类获得内部类：12Outer3.Inner aaa= new Outer3.Inner();aaa.print(); 内部类的好处好处1:内部类的第一个好处就体现出来了 隐藏你不想让别人知道的操作，也即封装性。好处2:访问级别控制protected和private修饰符来控制访问级别好处3：可以访问外部类的私有成员或属性。好处4:可是实现多重继承Java只能继承一个类，它的多重继承在我们没有学习内部类之前是用接口来实现的。但使用接口有时候有很多不方便的地方。比如我们实现一个接口就必须实现它里面的所有方法。而有了内部类就不一样了。它可以使我们的类继承多个具体类或抽象类。好处5:可以避免修改接口而实现同一个类中两种同名方法的调用。如果，你的类要继承一个类，还要实现一个接口，可是你发觉你继承的类和接口里面有两个同名的方法怎么办？你怎么区分它们？？这就需要我们的内部类实现接口和外部类继承分开来就不会与外围类的方法冲突了。 匿名内部类什么时候用？当你只需要创建一个类的对象而且用不上它的名字时，使用内部类可以使代码看上去简洁清楚。Listener匿名内部类由于没有名字，所以它没有构造函数（但是如果这个匿名内部类继承了一个只含有带参数构造函数的父类，创建它的时候必须带上这些参数，并在实现的过程中使用super关键字调用相应的内容）。如果你想要初始化它的成员变量，有下面几种方法：如果是在一个方法的匿名内部类，可以利用这个方法传进你想要的参数，不过记住，这些参数必须被声明为final。为什么final？首先内部类的实例可以在方法结束后依然存活，局部变量在方法结束后却无法存活，所以在内部类中无法访问NON-final的局部变量；而成员变量的存活时间是取决于外部类的实例的，内部类实例中都会引用当前外部类实例，所以他们拥有一致的生命周期，于是可以访问成员变量。 设计模式《Head Hirst Design Pattern》《大话设计模式》 单例模式确保一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。用于如多个模块使用同一个数据源连接对象等等。优点1.对于那些比较耗内存的类，只实例化一次可以大大提高性能，尤其是在移动开发中。2.保持程序运行的时候该中始终只有一个实例存在内存中,避免多个线程操作不一致状态。注意：只能使用单例类提供的方法得到单例对象，（虽然private构造方法）但不要使用反射，否则将会实例化一个新对象。相关链接缺点1.由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。2.单例类的职责过重，在一定程度上违背了“单一职责原则”。3.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。 工厂方法模式定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。相关链接优点克服了简单工厂违背开放-封闭原则的缺点，工厂类定义成了接口,而每新增的产品,就增加该种类型对应工厂类的实现【因为每增加一种新产品，都要在工厂类中增加相应的创建业务逻辑（createBMW(int type)方法需要新增case），这显然是违背开闭原则的。】又保留了封装对象创建过程的优点,降低客户端和工厂的耦合性，所以说“工厂模式”是“简单工厂模式”的进一步抽象和推广。缺点每增加一个产品，相应的也要增加一个子工厂，加大了额外的开发量。对系统的维护和扩展非常不利 volatile与synchronizedvolatile作用Java内存模型知识相关（1）Java所有变量都存储在主内存中（2）每个线程都有自己独立的工作内存，里面保存该线程的使用到的变量副本（该副本就是主内存中该变量的一份拷贝）首先我们要先意识到有这样的现象,编译器为了加快程序运行的速度,对一些变量的写操作会先在寄存器或者是CPU缓存上进行,最后才写入内存.而在这个过程中,变量的新值对其他线程是不可见的.【volatile主要用在】多个线程感知实例变量被更改了场合，从而使得各个线程获得最新的值。它强制线程每次从主内存中讲到变量，而不是从线程的私有内存中读取变量，从而保证了数据的可见性。 与synchronized区别1）volatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住. 也可以对象锁，就是就是synchronized 给某个对象 加锁，若多个线程拥有同一个类的对象，则这些方法只能以同步的方式执行。即，执行完一个synchronized修饰的方法后，才能执行另一个synchronized修饰的方法。2）volatile仅能使用在变量级别,synchronized则可以使用在变量,方法。3）volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞线程。4）volatile仅能实现变量的修改可见性,而synchronized则可以保证变量的修改可见性和原子性.Synchronized能够实现原子性和可见性；在Java内存模型中，synchronized规定，线程在加锁时，先清空工作内存→在主内存中拷贝最新变量的副本到工作内存→执行完代码→将更改后的共享变量的值刷新到主内存中→释放互斥锁。原子性实例【Volatile：保证可见性，但不保证操作的原子性】【原子性】即不可再分了，不能分为多步操作。比如赋值或者return。比如”a = 1;”和 “return a;”这样的操作都具有原子性。类似”a += b”这样的操作不具有原子性，在某些JVM中”a += b”可能要经过这样三个步骤：①取出a和b ②计算a+b ③将计算结果写入内存 框架相关链接 MVC单来说就是通过controller（各种activity）的控制去操作model层（各种Java bean的、类似repository类）数据，并且返回给view层（layout.xml里面的xml文件）展示，用户出发事件的时候，view层会发送指令到controller层，接着controller去通知model层更新数据，model层更新完数据以后直接显示在view层上，这就是MVC的工作原理。缺点：控制能力实在太弱了，你想去动态的改变一个页面的背景，或者动态的隐藏/显示一个按钮，这些都没办法在xml中做，只能把代码写在activity中，造成了activity既是controller层，又是view层的这样一个窘境。大家回想一下自己写的代码，如果是一个逻辑很复杂的页面，activity或者fragment是不是动辄上千行呢？这样不仅写起来麻烦，维护起来更是噩梦。 MVP最明显的差别就是view层和model层不再相互可知，完全的解耦，取而代之的presenter层充当了桥梁的作用，用于操作view层发出的事件传递到presenter层中，presenter层去操作model层，并且将数据返回给view层，整个过程中view层和model层完全没有联系。activity和fragment不再是controller层，而是纯粹的view层，所有关于用户事件的转发全部交由presenter层处理。优点：解决了MVC模式中测试，维护难的问题。其他开源框架 内存相关内存溢出JVM内存过小、程序不严密，产生了过多的垃圾。导致OutOfMemoryError异常的常见原因有以下几种：1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；3.启动参数内存值设定的过小； 内存泄漏对象已经没有被应用程序使用，但是垃圾回收器没办法移除它们，因为还在被引用着。 最终导致内存溢出。比如动态注册的广播。 io流 线程相关线程同步在同一个线程运行前面的运行完在运行后面的 ，有先后顺序 。控制共享资源，多个线程一起运行，每次只有一个线程访问，其他等待。异步：是几个程序同时运行 CPU会每个程序都运行一会。 线程死锁线程的同步化可能会造成死锁，死锁发生在两个线程相互持有对方正在等待的东西（实际是两个线程共享的东西）。 线程状态1、新建状态Newnew操作符创建一个新线程时，如 new Thread(r), 该线程还没有开始运行线程中的代码2、就绪状态Runnable一旦调用start()方法，线程就处于runnable状态。状态位于“可运行线程池”中。一旦时间分片机制有空闲的CPU周期提供给一个线程，那个线程便可立即开始运行。（有可能没运行，比如被阻塞，没获得时间片）。3、运行状态(Running)就绪状态的线程获取了CPU，执行程序代码。run（）4、阻塞状态(Blocked)因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。5、死亡状态(Dead)线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 线程阻塞状态1、等待阻塞运行的线程执行wait()方法，该线程会释放占用的所有资源，JVM会把该线程放入“等待池”中。进入这个状态后，是不能自动唤醒的，必须依靠其他线程调用notify()或notifyAll()方法才能被唤醒。2、同步阻塞运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入“锁池”中。synchronized.其他阻塞运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 JVM相关链接 相关概念方法区(Method Area)用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。虽然JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap（非堆），所以大家不要搞混淆了。方法区还包含一个运行时常量池。java堆(Heap)存储java实例或者对象的地方。这块是GC的主要区域（后面解释）。从存储的内容我们可以很容易知道，方法区和堆是被所有java线程共享的。java栈(Stack)java栈总是和线程关联在一起，每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。在这个java栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈、方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在java栈中入栈到出栈的过程。所以java栈是现成私有的。程序计数器(PC Register)用于保存当前线程执行的内存地址。由于JVM程序是多线程执行的（线程轮流切换），所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见程序计数器也是线程私有的。本地方法栈(Native Method Stack)和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。 成员变量在哪里分配成员变量有静态和非静态，静态成员变量是共享数据，在共享区中，也叫方法区中。非静态成员变量在堆内存中，作用于整个类中。而局部变量在栈内存中，定义在函数中，函数结束内存释放。字符串常量池和堆一样是被所有线程共享的string、stringBuffer、线程安全线程不安全相关string、stringBuffer、线程安全线程不安全相关 类什么时候销毁销毁对象，java有很好的垃圾回收机制。当对象在内存中没有对应的地址是，如吧null赋给对象；或者对象超出作用范围时对象会被回收。当然你也可以用System.gc方法强制启动垃圾回收器，java垃圾回收机制已十分完善，这种方法一般用不到。 类会在下面三种情况下被加载第一：生成该类对象的时候，会加载该类及该类的所有父类；第二：访问该类的静态成员的时候；第三：class．forName(“类名”)；而毁灭应该是在程序中没有对它的引用时，由垃圾回收器处理的。 范型范型 :”“可以代表任意类型的。K表示键，V表示值，T表示type类型，E表示enum枚举 ? 表示不确定的类型 接口java类是单继承的。classB Extends classA java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……不允许类多重继承的主要原因是，如果A同时继承B和C，而b和c同时有一个D方法，A如何决定该继承那一个呢？ 但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。注意： 1）一个类如果实现了一个借口，则要实现该接口的所有方法。2）方法的名字、返回类型、参数必须与接口中完全一致。如果方法的返回类型不是void，则方法体必须至少有一条return语句。3）因为接口的方法默认是public类型的，所以在实现的时候一定要用public来修饰（否则默认为protected类型，缩小了方法的使用范围）。 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[安卓知识复习]]></title>
      <url>%2F2017%2F03%2F02%2FReview%2F</url>
      <content type="text"><![CDATA[【此文章仅供作者复习使用，表达含糊，看不懂正常～】 系统架构linux 内核层为安卓设备提供了底层的驱动 ——– 显示、音频、蓝牙驱动。电源管理 系统运行库层通过C++库为安卓提供主要特性支持。——– 如SQLite提供数据库支持、OpenGL库提供了3D绘图功能、webkit库提供浏览器内核。还有安卓运行时库 ——– 允许运用java语言开发android、运行时库包含了Dalvik虚拟机（5.0之后改为art运行环境）使得每个app运行在独立进程中，并拥有自己的虚拟机实例。（防止在虚拟机崩溃的时候所有程序都被关闭。）（art相对dalvik 在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time ，JIT）而在ART 环境中，应用在第一次安装的时候预编译，这样的话，应用的启动首次和执行都会变得更加快速。【应用启动更快、运行更快、体验更流畅、触感反馈更及时。3、更长的电池续航能力。4、支持更低的硬件。】（Dalvik相比jvm dalvik是专门为移动设备定制，针对内存 cpu进行优化。Dalvik运行dex文件，而JVM运行java字节码 Dalvik是基于寄存器的，而JVM是基于栈的） 应用框架层提供了编写app时可能用到的api android自带核心应用就是靠它们完成。应用框架层 应用层所有app。 自带的 开发的。 Gradle项目采用Gradle来构建项目。Gradle：是先进构建，配置简单。jcenter：开源项目可以直接引用（比如app需要依赖下面这个远程库 就去jcenter里找）apply plugin：可声明是库（依附于别的应用程序模块运行）还是app（可直接运行）。buildTypes：子包debug（生成测试版安装文件相关配置） 子包release（正式版） minifyEnabled 是否对项目代码进行混淆。本地库：compile fileTree(include: [‘.jar’], dir: ‘libs’)远程库：compile ‘com.android.support:design:24.2.1’库依赖：可是是compile projece（‘：help‘）—–比如在apply plugin：中声明的testCompile：用于测试用例库 用不大到。*logi 比sysout高级：可分等级，可控制，可添加过滤，级别 IntentIntent组件之间交互的重要方式 1、可指明动作（启动活动、服务，发广播）2、还可传递数据。3、PendingIntent将要发生的意图 可以看（通知Demo）4、intentfilter（动态注册广播 强制下线Demo）5、Activity数据交互：（博客）1、startActivity()【putExtra(“”,””)、putExtra(Bundle对象)、Intent传递Object对象 Bundle.putSerializable、Parcelable】1.1、 Serializable序列化（java自带）表示将一个对象转换成可存储或可传输的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地、又可以进程间传递对象。 简单 在对象上直接实现这个接口。并给他一个serialVersionUID1.2、Parcelable（android 专用）：原理是将一个完整的对象进行分解，而分解后的每一部分都是Intent所支持的数据类型，这样也就实现传递对象的功能了。1.3、内存的时候，Parcelable比Serializable性能高，所以推荐使用Parcelable。内存开销小缺点是不能持久化（也就是不能存本地磁盘）。2、startActivityForResult() 重写onActivityResult3、Activity四种状态运行状态 暂停状态 停止状态 销毁状态onCreate：活动初始化：布局加载 绑定事件onPause：释放消耗cpu资源、以及保存关键数据，速度要快 不然会影响新栈顶活动的使用4、三种生存期①: 完整生存期，即Activity在onCreate()方法和onDestroy();方法之间所经历的。一般情况下，一个Activity在onCreate();方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。②: 可见生存期，即Activity在onStart();方法和onStop();方法之间所经历的。此阶段即便有可能无法和用户进行交互，但Activity总数可见的。我们应该通过这两个方法中合理的管理那些对用户可见的资源，比如在onStart()方法中对资源进行加载，而在onStop()方法中对资源进行释放，从而保证处于停止状态的Activity不会对系统占用过多的内存。③: 前台生存期，级活动在onResume()方法和onPause()方法之间所经历的。在此生存期Activity总数处于运行状态的,此时的Activity可以和用户进行交互，平时我们看的最多的也就是该生存期的Activity【onSaveInstanceState 在按home键（长时间返回会执行onRestoreInstanceState进行恢复）、屏幕旋转（回会执行onRestoreInstanceState进行恢复）、处于后台被杀死（要自己写onCreate中的Bundle变量） 都会执行这个方法】5、单例启动模式举例：启动支付宝付款页面 退出栈后直接返回应用。 布局常见布局线性布局：（独有layout_weight）(weight=原来宽+屏幕剩余宽度所占百分、layout_gravity中如果现行布局为水平，则只有垂直方向生效（top、bottom、center_vertical）因为水平长度不固定相对布局：（无layout_weight、无layout_gravity）属性多。但相对好控制。针布局：（有layout_gravity、无weight）绝对布局：废弃 不同设备兼容性差劲表格布局百分比布局：因为相对布局无weight 从而生出来 app：layout_widthpercent项目中老多布局了自定义布局（Demo 项目app）布局优化：引入布局 include 限定符PadDemo （Demo） ListView适配器，加载数据源，试图加载适配器（ArrayAdapter、SimpleAdapter都继承baseAdapter）适配器：ArrayAdapter分析源码：只能有一个定义了id的TextView data);//data既可以是数组，也可以是List集合1SimpleAdapternew SimpleAdapter(this,mData,R.layout.item,new String[]&#123;"image","title","text"&#125;, new int[]&#123;R.id.image,R.id.title,R.id.text&#125;); 可以显示比较复杂的列表，包括每行显示图片、文字等若都不满足你 可以继承baseAdapter进行自定义listview中每滑动出来一个item，就会走一个getview方法，且重新加载布局，重新获取控件实例// convertView为布局缓存，通过以下设置可以避免重新加载布局，提高效率.//通过ViewHolder来进行优化，可以避免每次都加载控件实例。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MyListViewAdapter extends ArrayAdapter&lt;ItemBean&gt; &#123; private int resource; public MyListViewAdapter(@NonNull Context context, @LayoutRes int resource, @NonNull List&lt;ItemBean&gt; objects) &#123; super(context, resource, objects); this.resource = resource; &#125; @NonNull @Override //listview中每滑动出来一个item，就会走一个getview方法，且重新加载布局，重新获取控件实例 // convertView为布局缓存，通过以下设置可以避免重新加载布局，提高效率. //通过ViewHolder来进行优化，可以避免每次都加载空间实例。 // public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; // Log.i("getview","getview"); // ItemBean itemBean=getItem(position); // View view= LayoutInflater.from(getContext()).inflate(resource,parent,false); // ImageView imageView= (ImageView) view.findViewById(R.id.ImageView); // TextView textView= (TextView) view.findViewById(R.id.TextView); // imageView.setImageResource(itemBean.getImageId()); // textView.setText(itemBean.getName()); // return view; // &#125; public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) &#123; // Log.i("getview","getview"); ItemBean itemBean=getItem(position); View view; ViewHolder viewHolder ; if(convertView==null)&#123; view= LayoutInflater.from(getContext()).inflate(resource,parent,false); viewHolder =new ViewHolder(); viewHolder.imageView=(ImageView) view.findViewById(R.id.ImageView); viewHolder.textView= (TextView) view.findViewById(R.id.TextView); view.setTag(viewHolder); &#125;else &#123; view=convertView; viewHolder= (ViewHolder) view.getTag(); &#125; viewHolder.imageView.setImageResource(itemBean.getImageId()); viewHolder.textView.setText(itemBean.getName()); return view; &#125; class ViewHolder&#123; ImageView imageView; TextView textView; &#125;&#125; RecycleViewlistview若不优化效率差，扩展性不好，只能实现纵向滚动，实现item内部view点击很麻烦，recyc油然而生使用需要添加远程依赖 Fragment添加方式1、静态添加：继承Fragment 把布局转换成view 在布局中可以通过完整包名添加Fragment的类2、动态添加：继承Fragment 把布局转换成view 在布局中建立FragmentLayout ———在代码中1、通过getSupportFragmrntManager（）获取FragmentManaager———-2、开启事物。在代码中1、通过getSupportFragmrntManager（）获取FragmentTransaction ft = fm.beginTransaction 3、replace 等操作Fragment的类实例 4、commitAddToBackStack()将碎片添加到返回栈 碎片与活动通信1、活动中用碎片实例 RightFragment rf =（RightFragment）findFragmentById（R.id.right_frag）；2、碎片用活动 MainActivity activity = (MainActivity)getActivity();3、碎片用碎片 得到相关活动，然后通过活动取得另一个碎片实例。 生命周期运行状态 暂停状态（同activity） 停止状态（不可见、或通过调用FragmentTransaction的remove、replace将并添加到了返回栈，有可能被系统回收） 销毁状态：通过调用FragmentTransaction的remove、replace将没添加到返回栈onAttach():碎片与活动建立关联oncreate（Bundle savedInstance）onCreateView（Bundle savedInstance）：为碎片初始化布局、控件onActivityCreated（Bundle savedInstance）：确保碎片相关联活动已经创建完毕onStart（）onResume（）———–run————-onpause（）onstop（）onDestoryView：碎片被移除 ：【从返回栈中回到上一个碎片走onDestoryView — onCreateView（）】onDestory（）onDetach（）：碎片与活动解除 广播（可IPC）分类1.标准广播：完全异步2。有序广播：同步，同一时刻只有一个可接，可处理或截断。3。系统广播：开机 电池4、本地广播：安全高效。 在app内部传递。LocalBroadcastManager m=LocalBroadcastManager。getInstance（this）【无法通过静态注册接收，也正因为无需接收外部广播】 广播接收者静态注册：关闭程序也能收到， 无需指定category动态注册：registerReceiver（receive，intentFilter） 一定要在onDestory中取消注册。（手机内存是有限的，一个优秀的APP懂得在适当的时期释放自己所占的资源，如果不回收一般有两种结果，一种是系统强行回收，二是内存溢出。）【不可开启线程，不可做耗时操作，因为生命周期短10秒】【扮演打开程序 、创建通知、启动服务等操作】 静态注册广播接收者为什么关闭程序依然被收到在安装应用时由系统自动完成注册，具体来说是由PMS（PackageManagerService）来完成整个注册过程的。 数据存储（持久化技术）文件存储openFileOutout（文件名不可包含路径，操作模式）方法【mode_private 默认覆盖、mode_append】【mode_world_readable writeable被遗弃 因为危险容易引起安全漏洞】 SharedPreference使用键值对的方式。支持多种不同数据类型【mode_private只有这一种模式 表示当前app可操作 其他被废除】 获得对象三种方式：1、上下文.getSharedPreferences（文件名，mode）2、Activity.getSharedPreferences（mode）文件名为活动名 3、PreferencesManager中的getDefaultSharedPreferences（this）当前包名为文件名 数据库存储 【123全都保存在data／data／packagename／1、2、3中】sqlite 运行速度快 占资源少 存大量数据 可用sql语言 遵循数据库事务1、SQLiteDatabase类直接操作数据库2、继承SQLiteOpenHelper帮助类，用于对数据库进行创建和升级。：getReadableDatabase、getWritaableDatabase打开或创建一个现有数据库，如果存在则打开，不存在则创建新的，如果磁盘已满 前者打开 后者报错3、开源LitePal 数据库框架 采用对象关系映射（OMR）原理：我们使用oo语言，而使用数据库则是关系型数据库，在两者之间简历一种映射关系3.1、引入远程依赖 3.2、在mian中创建assets目录中配置一个litepal。xml文件 配置数据库名 跟版本号及映射关系 3.3、在修改app配置文件 在application标签中添加name。 3.4、创建数据库记录对象类 3.5、创建记录对象类 直接进行操作 可以连缀。方便 运行时权限（Demo更换壁纸）6.0之前权限强制安装。 6.0之后可以让用户选择权限：并不是所有权限都在运行时申请。普通权限危险权限（运行时申请，如联系人 照相机 位置 外存,一旦同意申请，则该权限组下的权限全部自动同意）、特殊权限 跨进程数据被废除的方式1、文件存储、SharedPreference 都被废弃 ContentProvider创建自己的provider：1、继承contentprovider 复写创建（对数据进行创建升级等操作 当外部使用reslover时调用） 查增删改获得类型操作2、用UriMatch 添加用来匹配Uri要操作的表和匹配码3、筛选匹配码对“对应表”进行操作4、外部那完整uri进行获取【保护数据隐私：通过uri来访问，如果我们不在urimatch中添加受保护的uri 外界也就拿不到这些数据】 多媒体运用1、通知：1、获取NotificationManager ：context.getSystemService(Context.NOTIFICATION_SERVICE);2、读取相册 网络访问HttpURLConnection（博客Demo）HttpURLConnection HttpClient(6.0之后被废弃)之前一直使用HttClient是由于HttpURLConnection不稳定导致，那么现在谷歌虽然修复了HttpURLConnection之前存在的一些问题。1、HttpUrlConnection是Android SDK的标准实现，而HttpClient是apache的开源实现；2、HttpUrlConnection直接支持GZIP压缩；HttpClient也支持，但要自己写代码处理；3、HttpUrlConnection直接在系统层面做了缓存策略处理，加快重复请求的速度。4、HttpUrlConnection直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用；HttpClient当然也能做到，但毕竟不如官方直接系统底层支持好； OkHttp开源库（大demo）：1、新建一个OKHttpClient实例2、用连缀方式build一个Request对象，3、通过response的newCall创建一个call对象，传入request并。execute4、通过response。body拿到数据okhttp中enqueue可以为我们自动开子自线程去做耗时访问 数据解析xml：pull方式 sax方式 jason：（Demo）、gson开源库 Service（大Demo 后台下载东西前台服务通知） 特点后台不需跟用户交互需长期运行。进程被杀掉服务也断掉。要做耗时操作必须开启子线程。（广播不可开，因为life短）若果不stopService或者stopSelf（） 服务将一直运行 使用继承Service 重写OnBind（抽象） 活动与进程之间进行通信1、写内部类继承Binder 在里面实现要调用方法2、创建内部类实例 并在Onbind内返回3、在活动中创建ServiceConnect实例 重写连接方法 将参数内的回掉的Ibinder进行强转4、就可以调用服务中的方法了 5、通过bindService启用service（intent，connect，BIND_AUTO_CREATE） 前台服务类似通知样式，因为服务优先级低在后台运行 若想不让GC回收 则用到前台服务 比如彩云天气用法：在继承了服务类中重写Oncreate ：内部创建一个通知 并通过StartForegroud（）调用 IntentService在service中做耗时操作需要开启子线程 并。start并且完事后stopSelf。很麻烦，IntentService就可以实现对这些事的封装。只需继承它，重写OnHandleIntent（其运行在子线程并且自动结束） IPC使用AIDL定义进程间的通信接口. AIDL文件必须以.aidl作为后缀名.接口名需要和文件名相同.方法的参数或返回值是自定义类型时, 该自定义的类型必须实现了Parcelable接口.远程service的作用只是重新建立一个新进程执行，可以独立出去。其他app可以调用这个service。因为是一个新的进程，所以也不能用bindService来建立关联了，用startService使用：1、两个app中都建立一个文件 IPerson.aidl 在里面写接口 ，build一下就变成了接口文件2、服务端创建123456IPerson.Stub stub = new IPerson.Stub() &#123; @Override public String greet(String someone) throws RemoteException &#123; Log.i(TAG, "greet() called"); return "hello, " + someone; &#125; 并且在onBind中return出去，3、在服务端startService(startIntent);4、在服务端注册123456&lt;service android:name=".AIDLService"android:process=":remote" 开启独立进程暴露出去&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.AIDLService" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 5、接收端创建ServiceConnect实例 重写连接方法 将参数内的回掉的Ibinder进行强转1IPerson person = IPerson.Stub.asInterface(binder);就可以person。方法名调用了 6、接收端启动1234Intent mIntent = new Intent(); mIntent.setAction("android.intent.action.AIDLService");Intent eintent = new Intent(getExplicitIntent(this,mIntent));bindService(eintent, conn, Context.BIND_AUTO_CREATE); ANRactivity 5秒 、BroadcastReceiver（一般为10秒）、Service—–&gt;20秒 IPC四大组件都是运行在主线程中，均能IPC.方式 ：Activity 在Intent中使用Bubdle activity（博客）， 广播reciver本身就能接收外部程序的发来的广播。 service AIDL这是需要跨进程调用服务端的方法 用到AIDL实现（Demo） Content URI 实现跨进程 Messenger方式通过Messenger对象在不同进程中以串行的方式进行传递数据。它是AIDL的轻量级表现 底层是AIDL，如果是大量消息同时请求 服务端只能一个个处理，IDL这是需要跨进程调用服务端的方法 用到AIDL实现 使用socket：网络通信，它分为 流式套接字 和 用户数据报套接字两种 对应网络传输控制层中tcp udp协议 ， tcp面向连接 提供稳定双向通讯，三次握手，为了提高稳定的数据传输，本身提供了超时重传机制，稳定性高。 Udp捂脸的，提供不稳定单向通信。 性能上udp更好效率缺点不能保证数据一定能传输正确。 viewview三大过程都是通过viewroot来完成的。ViewRoot 对应viewrootImpl类，它是连接windowsmanager 和decorview 的纽带，在ActivityThread中 activity对象被创建完毕后 将Decorview添加到windows中 同时创建viewrootImpl对象，将viewrootImpl和Decorview 关联起来。view 绘制流程是从viewroot的performTraversals方法开始。经过了measure layout draw方式。（手机 相册。 看view动画） activity工作原理模式Activity构造的时候，调用了attach，绑定了一个window；Activity的setContentView()，是window.setContentView();每个Activity内部都有一个Window对象， Window对象包含了一个DecorView（顶级view）(继承FrameLayout)，我们通过setContentView给Activity设置显示的View实际上都是加到了DecorView中。Activity—&gt;Window—&gt;DecorView。 事件处理机制: android开发艺术140页（手机相册 view demo） 一个好的app应该少bug 避免内存溢出内存泄漏，提供用户建议的窗口，灰度测试，符合官方设计风格 例如material design页面ui，代码简洁层次结构鲜明代码注释明确封装到位使读者易于管理编辑跟复用。 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 网络请求及数据解析]]></title>
      <url>%2F2017%2F02%2F12%2FJson%2F</url>
      <content type="text"><![CDATA[前言大部分andriod应用需要与服务器进行数据交互，HTTP、FTP、SMTP或者是直接基于SOCKET编程都可以进行数据交互，但是HTTP必然是使用最广泛的协议。在总结之前先来了解一下Http协议，也是对技术支持的一些补充。 1、http协议定义HTTP协议是基于TCP/IP协议之上的协议，是客户端和服务器之间的应用层的协议，是通用的、无状态的面向对象的协议。 2、客户端连接服务器实现内部的原理分析上图，步骤如下：第一步：在浏览器客户端中得到用户输入的内容。第二步：浏览器得到这个网址之后，内部会将这个域名发送到DNS上，进行域名解析。得到它的IP之后就会链接到指定的服务器上，假如服务器的地址是：221.104.13.32:80，从浏览器到服务器端口它使用到最底层的TCP/IP协议。第三步：实现TCP/IP协议用Socket来完成，使用了Socket的套接字。第四步：服务器端的80端口监听客户端的链接，这样客户端到服务器就链接上了。通俗一点讲，用户在浏览器输入网址，通过http协议发出去，网址经过DNS域名解析，解析成指定的ip地址，并在80端口上监听用户的请求。服务器监听到请求之后，会以三种方式返回给客户端：HTML、XML、JASON。 3、Http请求方式、区别根据HTTP标准，HTTP请求可以使用多种请求方法。例如：HTTP1.1支持7种请求方法：GET、POST、HEAD、OPTIONS、PUT、DELETE和TARCE。在Internet应用中，最常用的方法是GET和POST。区别：在客户端，GET方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTML HEADER内提交。对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器用Request.Form获取提交的数据。GET方式提交的数据不能大于2KB（主要是URL长度限制），而POST则没有此限制。安全性问题。使用GET的时候，参数会显示在地址栏上，而POST不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用GET；如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用POST为好。 4、HTTP返回请求数据的三种方式:以HTML代码内容返回。 以XML字符串的形式返回，在以后的android开发中这种形式返回数据比较多。 以JSON对象形式返回，在网络流量上考虑JSON要比XML方式要好一些，便于解析。在Android当中，一般使用xml和Json数据解析。 Android中的网络请求方式Android中的WebView控件已经在后台帮我们处理好了发送HTTP请求、接收服务响应、解析返回数据，以及最终的页面展示这几步工作，不过由于它封装得太好了，反而不能直观地看出HTTP协议是如何工作的。因此接下来我们通过手动发送HTTP请求的方式，来更加深入的了解这一过程。 1、在Android上发送HTTP请求的方式一般有两种：HttpURLConnection、HttpCient 2、关于HttpClient的废除在android 6.0(api 23) SDK，不再提供org.apache.http.*(只保留几个类)，HttpClient相关类移除，推荐使用HTTPURLConnection。废除原因：之前一直使用HttClient是由于HttpURLConnection不稳定导致，那么现在谷歌虽然修复了HttpURLConnection之前存在的一些问题。若还需使用该类，点击查看解决办法。 3、HttpURLConnection、HttpCient介绍。(HttpCient废除之前)HttpClient是apache的开源框架，封装了访问http的请求头，参数，内容体，响应等等，使用起来比较方便，而HttpURLConnection是java的标准类，什么都没封装，用起来太原始，不方便，比如重访问的自定义，以及一些高级功能等。从稳定性方面来说的话，HttpClient很稳定，功能强，BUG少，容易控制细节，而之前的HttpURLConnection一直存在着版本兼容的问题，不过在后续的版本中已经相继修复掉了。 4、HttpURLConnection和HttpCient区别(HttpURLConnection优势)1、HttpUrlConnection是Android SDK的标准实现，而HttpClient是apache的开源实现；2、HttpUrlConnection直接支持GZIP压缩；HttpClient也支持，但要自己写代码处理；3、HttpUrlConnection直接在系统层面做了缓存策略处理，加快重复请求的速度。4、HttpUrlConnection直接支持系统级连接池，即打开的连接不会直接关闭，在一段时间内所有程序可共用；HttpClient当然也能做到，但毕竟不如官方直接系统底层支持好； 5、Android配置网络权限因为需要访问网络，需在AndroidManifest.xml中添加如下权限1&lt;uses-permission android:name="android.permission.INTERNET" /&gt; HttpURLConnection(Demo)1、Get请求实现（Demo）由于网络请求可能造成耗时操作（网络环境差的情况下）对ui线程的阻塞，我们开启子线程去操作网络请求。【关于UI线程，请看《Android实习生 —— 异步处理之Handler》】12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void connectWithHttpURLConnection() &#123; new Thread( new Runnable() &#123; @Override public void run() &#123; Message msg =new Message(); HttpURLConnection connection = null; try &#123; // 调用URL对象的openConnection方法获取HttpURLConnection的实例 URL url = new URL("http://www.baidu.com"); connection = (HttpURLConnection) url.openConnection(); // 设置请求方式，GET或POST connection.setRequestMethod("GET"); // 设置连接超时、读取超时的时间，单位为毫秒（ms） connection.setConnectTimeout(8000); connection.setReadTimeout(8000); // 设置是否使用缓存 默认是true connection.setUseCaches(true); //设置请求头里面的属性 //connection.setRequestProperty(); // 开始连接 Log.i("HttpURLConnection.GET","开始连接"); connection.connect(); if (connection.getResponseCode() == 200) &#123; Log.i("HttpURLConnection.GET", "请求成功"); InputStream in = connection.getInputStream(); // 使用BufferedReader对象读取返回的数据流 // 按行读取，存储在StringBuider对象response中 BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; // 此处省略处理数据的代码,通过handler直接将返回的结果消息发送给UI线程列队 Bundle bundle =new Bundle(); bundle.putString("data", String.valueOf(response)); msg.setData(bundle); handler.sendMessage(msg); &#125;else&#123; Log.i("HttpURLConnection.GET", "请求失败"); &#125; &#125; catch (Exception e)&#123; e.printStackTrace(); &#125; finally &#123; if (connection != null)&#123; // 结束后，关闭连接 connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; 效果打印消息 2、Post请求实现（Demo）正如前言中第3条所述，在客户端，GET方式在通过URL提交数据，数据在URL中可以看到；POST方式，数据放在HTML HEADER内提交。在Get方法中请求参数可以直接写到地址栏中，如：12//用“&amp;”隔开不同参数 String path = "https://reg.163.com/logins.jsp?id=helloworld&amp;pwd=android"; 但在Post方式中要把“请求的参数”转换为byte数组，然后通过DataOutputStream(urlConn.getOutputStream())把参数写入。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void connectWithHttpURLConnectionPOST() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; Message msg = new Message(); String path = "https://reg.163.com/logins.jsp"; // 请求的参数转换为byte数组 String params = null; HttpURLConnection urlConn = null; try &#123; params = "id=" + URLEncoder.encode("helloworld", "UTF-8") + "&amp;pwd=" + URLEncoder.encode("android", "UTF-8"); byte[] postData = params.getBytes(); // 新建一个URL对象 URL url = new URL(path); // 打开一个HttpURLConnection连接 urlConn = (HttpURLConnection) url.openConnection(); // 设置连接超时时间 urlConn.setConnectTimeout(8 * 1000); // Post请求必须设置允许输出 urlConn.setDoOutput(true); // Post请求不能使用缓存 urlConn.setUseCaches(false); // 设置为Post请求 urlConn.setRequestMethod("POST"); urlConn.setInstanceFollowRedirects(true); // 配置请求Content-Type urlConn.setRequestProperty("Content-Type", "application/x-www-form-urlencode"); // 开始连接 urlConn.connect(); Log.i("HttpURLConnection.POST", "开始连接"); // 发送请求参数 DataOutputStream dos = new DataOutputStream(urlConn.getOutputStream()); dos.write(postData); dos.flush(); dos.close(); // 判断请求是否成功 if (urlConn.getResponseCode() == 200) &#123; // 获取返回的数据 InputStream in = urlConn.getInputStream(); // 使用BufferedReader对象读取返回的数据流 // 按行读取，存储在StringBuider对象response中 BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; Log.i("HttpURLConnection.POST", "请求成功"); // 此处省略处理数据的代码,直接将返回的结果消息发送给UI线程列队 Bundle bundle = new Bundle(); bundle.putString("data", String.valueOf(response)); msg.setData(bundle); handler.sendMessage(msg); &#125; else &#123; Log.i("HttpURLConnection.POST", "请求失败"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (urlConn != null) &#123; // 结束后，关闭连接 urlConn.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125; 效果 HttpCient(Demo)1、关于 HttpCient废除在android 6.0(api 23) SDK，不再提供org.apache.http.(只保留几个类)，HttpClient相关类移除，推荐使用HTTPURLConnection。废除原因：*之前一直使用HttClient是由于HttpURLConnection不稳定导致，那么现在谷歌虽然修复了HttpURLConnection之前存在的一些问题。若还需使用该类，点击查看解决办法。 2、HttpCient介绍HttpClient其实是一个interface类型，HttpClient封装了对象需要执行的Http请求、身份验证、连接管理和其它特性。既然HttpClient是一个接口，因此无法创建它的实例。从文档上看，HttpClient有三个已知的实现类分别是：AbstractHttpClient, AndroidHttpClient, DefaultHttpClient，会发现有一个专门为Android应用准备的实现类AndroidHttpClient，当然使用常规的DefaultHttpClient也可以实现功能。 3、HttpCient实现步骤（i）创建代表客户端的HttpClient对象。（ii）创建代表请求的对象，如果需要发送GET请求，则创建HttpGet对象，如果需要发送POST请求，则创建HttpPost对象。【对于发送请求的参数，GET和POST使用的方式不同，GET方式可以使用拼接字符串的方式，把参数拼接在URL结尾；POST方式需要使用setEntity(HttpEntity entity)方法来设置请求参数。】（iii）调用HttpClient对象的execute（HttpUriRequest request）发送请求，执行该方法后，将获得服务器返回的HttpResponse对象。服务器发还给我们的数据就在这个HttpResponse相应当中。调用HttpResponse的对应方法获取服务器的响应头、响应内容等。（iv）检查相应状态是否正常。服务器发给客户端的相应，有一个相应码：相应码为200，正常；相应码为404，客户端错误；相应码为505，服务器端错误。（v）获得相应对象当中的数据。 4、HttpCient实现实例（GET）（Demo）1234567891011121314151617181920212223242526272829private void sendRequestWithHttpClient() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //用HttpClient发送请求，分为五步 //第一步：创建HttpClient对象 HttpClient httpCient = new DefaultHttpClient(); //第二步：创建代表请求的对象,参数是访问的服务器地址 HttpGet httpGet = new HttpGet("http://www.baidu.com"); try &#123; //第三步：执行请求，获取服务器发还的相应对象 HttpResponse httpResponse = httpCient.execute(httpGet); //第四步：检查相应的状态是否正常：检查状态码的值是200表示正常 if (httpResponse.getStatusLine().getStatusCode() == 200) &#123; //第五步：从相应对象当中取出数据，放到entity当中 HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, "utf-8");//将entity当中的数据转换为字符串 //在子线程中将Message对象发出去 Message message = new Message(); message.what = SHOW_RESPONSE; message.obj = response.toString(); handler.sendMessage(message); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; 效果 5、HttpCient实现实例（POST）（Demo）123456789101112131415161718192021222324252627282930313233343536373839private void sendRequestWithHttpClientPOST() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; //用HttpClient发送请求，分为五步 //第一步：创建HttpClient对象 HttpClient httpClient = new DefaultHttpClient(); //第二步：创建代表请求的对象,参数是访问的服务器地址 HttpPost httpPost= new HttpPost("https://reg.163.com/logins.jsp"); // 使用NameValuePair（键值对）存放参数 List&lt;NameValuePair&gt; data = new ArrayList&lt;NameValuePair&gt;(); // 添加键值对 data.add(new BasicNameValuePair("id", "helloworld")); data.add(new BasicNameValuePair("pwd", "android")); try &#123; // 使用setEntity方法传入编码后的参数 httpPost.setEntity(new UrlEncodedFormEntity(data, "utf-8")); //第三步：执行请求，获取服务器发还的相应对象 HttpResponse httpResponse = httpClient.execute(httpPost); //第四步：检查相应的状态是否正常：检查状态码的值是200表示正常 if (httpResponse.getStatusLine().getStatusCode() == 200) &#123; Log.i("mm","success"); //第五步：从相应对象当中取出数据，放到entity当中 HttpEntity entity = httpResponse.getEntity(); String response = EntityUtils.toString(entity, "utf-8");//将entity当中的数据转换为字符串 //在子线程中将Message对象发出去 Message message = new Message(); message.what = 1; message.obj = response.toString(); handler.sendMessage(message); &#125;else&#123; Log.i("mm","fail"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;).start(); &#125; 效果 HttpURLConnection抽象请求方法（Demo）1、JQuery如果你使用过JQuery（一个javasript库），你一定对JQuery的网路编程印象深刻，比如一个HTTP请求只需以下几行代码。1234567891011// JQuery的post方法$.post("http://www.cnblogs.com/gzdaijie",&#123; "stu_no":12345, "stu_name":"Tom", &#125;).done(function()&#123; //...请求成功的代码 &#125;).fail(function()&#123; //...请求失败的代码 &#125;).always(function()&#123; //...总会执行的代码 &#125;) 我们当然不希望每次网络请求都写下“二”中那么繁琐的代码，那么android的HTTP请求能否像JQuery那么简单呢？当然可以！下面的代码实现了HttpURLConnection的HTTP请求方法封装 2、定义接口HttpCallbackListener，为了实现回调123456// 定义HttpCallbackListener接口// 包含两个方法，成功和失败的回调函数定义public interface HttpCallbackListener &#123; void onFinish(String response); void onError(Exception e);&#125; 3、创建HttpTool类，抽象请求方法（GET）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class HttpTool &#123; public static void sendRequest(final String address, final HttpCallbackListener listener) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpURLConnection connection = null; try &#123; // 调用URL对象的openConnection方法获取HttpURLConnection的实例 URL url = new URL(address); connection = (HttpURLConnection) url.openConnection(); // 设置请求方式，GET或POST connection.setRequestMethod("GET"); // 设置连接超时、读取超时的时间，单位为毫秒（ms） connection.setConnectTimeout(8000); connection.setReadTimeout(8000); // 设置是否使用缓存 默认是true connection.setUseCaches(true); //设置请求头里面的属性 //connection.setRequestProperty(); // 开始连接 Log.i("HttpURLConnection.GET","开始连接"); connection.connect(); if (connection.getResponseCode() == 200) &#123; Log.i("HttpURLConnection.GET", "请求chenggong"); InputStream in = connection.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) &#123; response.append(line); &#125; if (listener != null) &#123; // 回调方法 onFinish() listener.onFinish(response.toString()); &#125; &#125; else &#123; Log.i("HttpURLConnection.GET", "请求失败"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); if (listener != null) &#123; // 回调方法 onError() listener.onError(e); &#125; &#125; finally &#123; if (connection != null) &#123; connection.disconnect(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 4、调用示例123456789101112131415161718192021button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //使用该HttpTool发起GET请求 String url = "http://www.jianshu.com"; HttpTool.sendRequest(url,new HttpCallbackListener()&#123; @Override public void onFinish(String response) &#123; // ...省略对返回结果的处理代码 Message message = new Message(); message.what = 0; message.obj = response.toString(); handler.sendMessage(message); &#125; @Override public void onError(Exception e) &#123; // ...省略请求失败的处理代码 &#125; &#125;); &#125; &#125;); 效果 5、抽象请求方法（POST）1234567/* 在GET方法实现的基础上增加一个参数params即可， * 将参数转换为字符串后传入 * 也可以传入键值对集合，再处理 */public static void sendRequest(final String address, final String params, final HttpCallbackListener listener)&#123; //...&#125; 文件下载（Demo）1、DownLoadManager简介虽然我们可以通过HTTP请求的方式下载文件，在api level 9之后，android系统为我们提供了DownLoadManager类，这是android提供的系统服务，我们通过这个服务完成文件下载。整个下载过程全部交给系统负责，不需要我们过多的处理。其包含两个内部类：12DownLoadManager.Query:主要用于查询下载信息。DownLoadManager.Request:主要用于发起一个下载请求。 2、功能实现123456789101112131415161718192021222324252627//使用系统下载器下载private void downloadAPK(String versionUrl, String versionName) &#123; //创建下载任务 DownloadManager.Request request = new DownloadManager.Request(Uri.parse(versionUrl)); request.setAllowedOverRoaming(false);//漫游网络是否可以下载 request.setTitle("jar包下载");//下载是通知栏标题 //request.setAllowedNetworkTypes() 设置制定网络下下载，传入系统常量值。 //提供的网络常量有：NETWORK_BLUETOOTH、NETWORK_MOBILE、NETWORK_WIFI。 //设置文件类型，可以在下载结束后自动打开该文件 MimeTypeMap mimeTypeMap = MimeTypeMap.getSingleton(); String mimeString = mimeTypeMap.getMimeTypeFromExtension(MimeTypeMap.getFileExtensionFromUrl(versionUrl)); request.setMimeType(mimeString); //在通知栏中显示，默认就是显示的 request.setNotificationVisibility(DownloadManager.Request.VISIBILITY_VISIBLE); request.setVisibleInDownloadsUi(true); //sdcard的目录下的download文件夹，必须设置 request.setDestinationInExternalPublicDir("/download/", versionName); //request.setDestinationInExternalFilesDir(),也可以自己制定下载路径 //将下载请求加入下载队列 downloadManager = (DownloadManager) getSystemService(DOWNLOAD_SERVICE); //加入下载队列后会给该任务返回一个long型的id， //通过该id可以取消任务，重启任务等等，看上面源码中框起来的方法 mTaskId = downloadManager.enqueue(request); //注册广播接收者，监听下载状态 registerReceiver(receiver, new IntentFilter(DownloadManager.ACTION_DOWNLOAD_COMPLETE));&#125; 广播接收器123456private BroadcastReceiver receiver = new BroadcastReceiver() &#123; @Override public void onReceive(Context context, Intent intent) &#123; checkDownloadStatus();//检查下载状态 &#125; &#125;; 检查下载状态12345678910111213141516private void checkDownloadStatus() &#123; DownloadManager.Query query = new DownloadManager.Query(); query.setFilterById(mTaskId);//筛选下载任务，传入任务ID，可变参数 Cursor c = downloadManager.query(query); if (c.moveToFirst()) &#123; int status = c.getInt(c.getColumnIndex(DownloadManager.COLUMN_STATUS)); switch (status) &#123; case DownloadManager.STATUS_SUCCESSFUL: Toast.makeText(this,"下载完成",Toast.LENGTH_SHORT).show(); break; case DownloadManager.STATUS_FAILED: Toast.makeText(this,"下载失败",Toast.LENGTH_SHORT).show(); break; &#125; &#125; &#125; 效果文件下载路径 JSON数据解析（Demo）1、解析单条Json数据123456789101112131415//单条数据 private String parseItemJSONWithJSONObject(String jsonData) &#123; String status=null; String message=null; try &#123; //第一步：将从网络字符串jsonData字符串装入JSONObject JSONObject jsonObject = new JSONObject(jsonData); //第二步：因为单条数据，所以用jsonObject.getString方法直接取出对应键值 status = jsonObject.getString("status"); message = jsonObject.getString("message"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return "status: "+ status+"\n"+"message: " + message; &#125; 2、解析多条Json数据123456789101112131415161718192021//多条数据 private String parseJSONWithJSONObject(String jsonData) &#123; StringBuffer sb =new StringBuffer(); try &#123; //第一步：将从网络字符串jsonData字符串装入JSONObject，即JSONObject JSONObject jsonObject = new JSONObject(jsonData); //第二步：因为多条数据，所以将"取出来的、要遍历的"字段装入JSONArray（这里要遍历data字段） JSONArray jsonArray = jsonObject.getJSONArray("data"); //第三步：循环遍历，依次取出JSONObject对象 for (int i = 0; i &lt; jsonArray.length(); i++) &#123; JSONObject jsonObject2 = jsonArray.getJSONObject(i); String time = jsonObject2.getString("time"); String ftime = jsonObject2.getString("ftime"); String context = jsonObject2.getString("context"); sb.append("time: " + time+" "+"ftime: " + ftime+"\n"+"context: " + context+"\n\n"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; 效果 图片数据解析（Demo）使用Http请求下载网络图片并通过handler机制更新系统ui。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MainActivity extends AppCompatActivity &#123; private final String PATH = "https://www.baidu.com/img/bdlogo.png"; private Button button; private ImageView imageView; public Handler handler = new Handler() &#123; public void handleMessage(Message msg) &#123; if (msg.what == RESULT_OK) &#123; byte[] data = (byte[]) msg.obj; //使用Bitmap类解析图片 Bitmap bitmap = BitmapFactory.decodeByteArray(data, 0, data.length); imageView.setImageBitmap(bitmap); &#125; &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView = (ImageView) findViewById(R.id.imageView1); button = (Button) findViewById(R.id.btn); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; picDown(); &#125; &#125;); &#125; private void picDown() &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; HttpClient httpClient = new DefaultHttpClient(); HttpGet httpGet = new HttpGet(PATH); try &#123; HttpResponse httpResponse = httpClient.execute(httpGet); if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123; byte[] data = EntityUtils.toByteArray(httpResponse .getEntity()); Message message = Message.obtain(); message.obj = data; message.what = RESULT_OK; handler.sendMessage(message); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (httpClient != null &amp;&amp; httpClient.getConnectionManager() != null) &#123; httpClient.getConnectionManager().shutdown(); &#125; &#125; &#125; &#125;).start(); &#125;&#125; 【附录】DemoHttpURLConnectionHttpCientHttpURLConnection抽象请求方法文件下载JSON数据解析图片数据解析 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 异步处理之AsyncTask]]></title>
      <url>%2F2016%2F12%2F27%2FAsyncTask%2F</url>
      <content type="text"><![CDATA[前言在【异步处理之Handler】中我们已经了解了关于线程的相关知识，明白为什么要进行异步处理以及使用Handler进行异步处理的方式，今天我们就来了解一下异步处理的另一种方式 —— AsyncTask。 AsyncTask简介Android应用的主线程（UI 线程）肩负着绘制用户界面和及时响应用户操作的重任，为了避免在主线程中做耗时操作而产生的ANR提示，我们就要把耗时的任务移出主线程，交给工作者线程去做。工作者线程主要有AsyncTask、IntentService、HandlerThread，它们本质上都是对线程或线程池的封装。 AsyncTask和Handler对比1、AsyncTask实现的原理和适用的优缺点AsyncTask提供的轻量级的异步类,可以直接继承AsyncTask,在类中实现异步操作,并提供接口反馈当前异步执行的程度(可以通过接口实现UI进度更新),最后反馈执行的结果给UI主线程.优点:简单快捷 、过程可控。缺点:在使用多个异步操作和并需要进行Ui变更时,就变得复杂起来。只是代码上轻量一些，而实际上要比handler更耗资源。 2、Handler异步实现的原理和适用的优缺点在Handler 异步实现时,涉及到 Handler, Looper, Message,Thread四个对象，实现异步的流程是主线程启动Thread（子线程）运行并生成Message-Looper获取Message并传递给Handler，Handler逐个获取Looper中的Message，并进行UI变更。优点：结构清晰，功能定义明确，适于处理多个后台任务。缺点： 在单个后台异步处理时，显得代码过多，结构过于复杂（相对性）。【总的来说为了简化操作，Android1.5提供了工具类android.os.AsyncTask，它使创建异步任务变得更加简单，不再需要编写任务线程和Handler实例即可完成相同的任务。】 3、Android开发中立即停止AsyncTask和Thread的一些办法我们要知道在java的线程中，没有办法停止一个正在运行中的线程。在Android的AsyncTask中也是一样的。如果必须要停止一个线程，我们可以采用这个线程中设置一个标志位，然后在线程run方法或AsyncTask的doInBackground方法中的关键步骤判断这个标志位以决定是否继续执行。然后在需要终止此线程的地方改变这个标志位以达到停止线程的目的。使线程完成了数据的Loading，我们也不让数据显示出来，算是一种投机取巧的办法吧。 AsyncTask的缺陷1、生命周期很多开发者会认为一个在Activity中创建的AsyncTask会随着Activity的销毁而销毁。然而事实并非如此。AsyncTask会一直执行, 直到doInBackground()方法执行完毕。然后，如果 cancel(boolean)被调用, 那么onCancelled(Result result) 方法会被执行；否则，执行onPostExecute(Result result) 方法。如果我们的Activity销毁之前，没有取消 AsyncTask，这有可能让我们的AsyncTask崩溃(crash)。因为它想要处理的view已经不存在了。所以，我们总是必须确保在销毁活动之前取消任务。总之，我们使用AsyncTask需要确保AsyncTask正确地取消。另外，即使我们正确地调用了cancle() 也未必能真正地取消任务。因为如果在doInBackgroud里有一个不可中断的操作，比如BitmapFactory.decodeStream()，那么这个操作会继续下去。 2、内存泄漏如果AsyncTask被声明为Activity的非静态的内部类，那么AsyncTask会保留一个对创建了AsyncTask的Activity的引用。如果Activity已经被销毁，AsyncTask的后台线程还在执行，它将继续在内存里保留这个引用，导致Activity无法被回收，引起内存泄露。 3、结果丢失屏幕旋转或Activity在后台被系统杀掉等情况会导致Activity的重新创建，之前运行的AsyncTask会持有一个之前Activity的引用，这个引用已经无效，这时调用onPostExecute()再去更新界面将不再生效。 AsyncTask使用方式1、三种泛型AsyncTask直接继承于Object类，位置为android.os.AsyncTask。要使用AsyncTask工作我们要提供三个泛型参数，并重载几个方法。AsyncTask定义了三种泛型类型 Params、Progress、Result123Params ：启动任务执行的输入参数，比如HTTP请求的URL。Progress ：后台任务执行的百分比。Result ：后台执行任务最终返回的结果，比如String。 2、必要一个异步加载数据最少要重写以下这两个方法12345doInBackground(Params…) //后台(非主线程)执行比较耗时的操作,注意这里不能直接操作UI。//doInBackground在执行过程中可以调用publishProgress(Progress…)来更新任务的进度。onPostExecute(Result) //(主线程执行)，相当于Handler处理UI的方式，可以使用在doInBackground 得到的结果处理操作UI。 3、非必要有必要的话你还得重写以下这三个方法，但不是必须的123456onProgressUpdate(Progress…) //(主线程执行)可以使用进度条显示任务执行的进度。onPreExecute() //(主线程执行)当任务执行之前开始调用此方法，可以在这里显示进度对话框。onCancelled() //用户调用取消时，要做的操作。 4、准则使用AsyncTask类，以下是几条必须遵守的准则1.Task的实例必须在UI thread中创建；2.execute方法必须在UI thread中调用；3.不要手动的调用onPreExecute(), onPostExecute(Result)，doInBackground(Params…), onProgressUpdate(Progress…)这几个方法；4.该task只能被执行一次，否则多次调用时将会出现异常； AsyncTask小实例1、新建一个MyAsyncTask123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class MyAsyncTask extends AsyncTask&lt;String, Integer, String&gt; &#123; private static final String TAG = "ASYNC_TASK"; //MainActivity的进度条 ProgressBar myprogressbar = null; //MainActivity的文本 TextView textView = null; // MainActivity的上下文 Context mycontext = null; public MyAsyncTask(ProgressBar progressbar, TextView textview, Context context) &#123; myprogressbar = progressbar; mycontext = context; textView = textview; &#125; //onPreExecute方法用于在执行后台任务前做一些UI操作 @Override protected void onPreExecute() &#123; super.onPreExecute(); Log.i(TAG, "onPreExecute() called"); textView.setText("正在加载..."); myprogressbar.setProgress(0); &#125; //doInBackground方法内部执行后台任务,不可在此方法内修改UI //params 由UI线程调用execute()方法传入 //返回的String类型参数被onPostExecute()方法调用。 @Override protected String doInBackground(String... params) &#123; Log.i(TAG, "doInBackground(Params... params) called"); String ret = null; /** * 通过Begin,End演示多参数传值 */ String Begin = params[0];//取出值Begin String End = params[1];//取出值End Log.i(TAG, "doInBackground" + Begin); /** * 模拟耗时步骤 */ for (int i = 0; i &lt; 10; i++) &#123; /** * 后台线程向UI线程发布进度状态i */ publishProgress(i); try &#123; Thread.sleep(500); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; Log.i(TAG, "doInBackground" + End); ret = "更新完毕"; return ret; &#125; //onPostExecute方法用于在执行完后台任务后更新UI,显示结果 //result为doInBackground()返回的参数 @Override protected void onPostExecute(String result) &#123; super.onPostExecute(result); Log.i(TAG, "onPostExecute(Result result) called"); textView.setText(result); &#125; @Override //onProgressUpdate方法用于更新进度信息 //values为doInBackground()中publishProgress()返回的参数 protected void onProgressUpdate(Integer... values) &#123; super.onProgressUpdate(values); Log.i(TAG, "onProgressUpdate(Progress... progresses) called"); int progress = myprogressbar.getMax() / 10 * (values[0] + 1); myprogressbar.setProgress(progress); textView.setText("正在加载..." + progress + "%"); &#125; //onCancelled方法用于在取消执行中的任务时更改UI @Override protected void onCancelled() &#123; Log.i(TAG, "onCancelled() called"); textView.setText("已被取消"); myprogressbar.setProgress(0); &#125;&#125; 2、MainActivity代码1234567891011121314151617181920212223242526272829303132333435public class MainActivity extends AppCompatActivity &#123; private ProgressBar myProgressBar; private Button start, cancel; private TextView textView; private MyAsyncTask mTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); myProgressBar = (ProgressBar) findViewById(R.id.progressBar); start = (Button) findViewById(R.id.start); cancel = (Button) findViewById(R.id.cancel); textView = (TextView) findViewById(R.id.tv); start.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //注意每次需new一个实例,新建的任务只能执行一次,否则会出现异常 //启动异步任务，并传入"Begin","End"值演示UI线程向后端线程传值的情况 mTask = new MyAsyncTask(myProgressBar, textView, getApplicationContext()); mTask.execute("Begin", "End"); start.setEnabled(false); cancel.setEnabled(true); &#125; &#125;); cancel.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mTask.cancel(true); start.setEnabled(true); cancel.setEnabled(false); &#125; &#125;); &#125;&#125; 3、效果点击开始执行完毕打印结果，注意执行顺序执行取消打印结果 【附录】DemoAsyncTaskDemo 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 异步处理之Handler]]></title>
      <url>%2F2016%2F10%2F27%2FHandler%2F</url>
      <content type="text"><![CDATA[前言在学习Handler之前，我们要先了解一下ActivityThread（主线程或UI线程）。 1、简介特点管理应用进程的主线程的执行(相当于普通Java程序的main入口函数)，并根据AMS的要求负责调度和执行activities、broadcasts和其它操作。默认情况下，一个应用程序内的各个组件(如Activity、BroadcastReceiver、Service)都会在同一个进程(Process)里执行，且由此进程的【主线程】负责执行。 如果有特别指定(通过android:process)，也可以让特定组件在不同的进程中运行。 2、主要责任责任1: 快速处理UI事件只有它才处理UI事件， 其它线程还不能存取UI画面上的对象(如TextView等)，所以， 主线程也叫做UI线程。责任2: 快速处理Broadcast消息在BroadcastReceiver的onReceive()函数中，不宜占用太长的时间，否则导致【主线程】无法处理其它的Broadcast消息或UI事件。 3、特别规定（必须遵循）规定1：不可以在UI线程做耗时操作Android要求UI线程能根据用户的要求做出快速响应，如果UI事件让用户等待时间超过5秒而未处理，或者在广播接收者操作占用时间超过10秒， Android系统就会给用户显示ANR（Application is not responding）提示信息。123456789101112//产生耗时操作bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; try &#123; // 让UI线程睡上20s Thread.sleep(20000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); 规定2：不可以子线程中更新UIAndroid要求在创建了ViewRootImpl之后不可在非UI线程中更新UI。举例：1234567891011bt1.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View view) &#123; new Thread(new Runnable() &#123; @Override public void run() &#123; bt1.setText("子线程操作UI"); &#125; &#125;).start(); &#125;&#125;); 异常12Process: com.bb.handlerdemo, PID: 2531android.view.ViewRootImpl$CalledFromWrongThreadException: Only the original thread that created a view hierarchy can touch its views. 4、知识扩展如果我们把子线程操作UI的代码这样写，反而没有报异常12345678910111213141516171819202122protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); bt1= (Button) findViewById(R.id.bt1);// bt1.setOnClickListener(new View.OnClickListener() &#123;// @Override// public void onClick(View view) &#123;// new Thread(new Runnable() &#123;// @Override// public void run() &#123;// bt1.setText("子线程操作UI");// &#125;// &#125;).start();// &#125;// &#125;); new Thread(new Runnable() &#123; @Override public void run() &#123; bt1.setText("子线程操作UI1"); &#125; &#125;).start(); &#125; 解释：在onCreate方法中创建的子线程访问UI是一种极端的情况。ViewRootImpl的创建是在onResume方法回调之后，而我们是在onCreate方法中创建了子线程并访问UI，在那个时刻，ViewRootImpl是没有创建的，无法通过checkThread方法检查当前线程，所以程序没有崩溃一样能跑起来。如果我们在线程里睡眠1秒钟，程序就崩了。很明显1秒后ViewRootImpl已经创建了。 Handler简述Handler是什么若把一些类似于下载的功能（既耗时且不一定有结果）写在Activity(主线程)里，会违背“前言中写到特别规定”从而导致Activity线程阻塞，产生ANR提示。因此，需要把这些耗时的操作放在单独的子线程中。这就是Handler的使命，Handler提供异步处理的功能，接受子线程发送的数据，并用此数据配合主线程更新UI。【android在设计的时候就封装了一套消息创建、传递、处理的Handler机制。如果不遵循就不能更新UI信息，就会报出异常。】 两个作用(1)安排消息或Runnable 在某个主线程中某个地方执行；(2)安排一个动作在不同的线程中执行。 常用方法12345678910//post类方法允许你排列一个Runnable对象到主线程队列中post(Runnable)//将Runnable直接添加入队列postAtTime(Runnable，long)//延迟一定时间后，将Runnable添加入队列postDelayed(Runnable long)//定时将Runnable添加入队列//sendMessage类方法， 允许你安排一个带数据的Message对象到队列中，等待更新。sendEmptyMessage(int what)//向队列添加直接添加消息, 与sendMessage相比一个传//Message类型的msg，一个传int类型的what，传what的，最终会转为msg。sendMessage(Message)//向队列添加直接添加消息sendMessageAtTime(Message，long)//定时将消息发送到消息队列sendMessageDelayed(Message，long)//延迟一定时间后，将消息发送到消息队列 Handler实现原理1、相关概念Message消息，理解为线程间通讯的数据单元。例如后台线程在处理数据完毕后需要更新UI，则可发送一条包含更新信息的Message给UI线程。Message Queue消息队列，由Looper管理，用来存放通过Handler发布的消息，按照先进先出执行。HandlerHandler是Message的主要处理者，它把消息发送给Looper管理的MessageQueue，并负责处理Looper分发给他的消息。每个Handler实例，都会绑定到创建他的线程中(一般是位于主线程)。Looper循环器，每个线程只有一个Looper，他负责管理MessageQueue，会不断的从MessageQueue取出消息，分发给对象的handler。为了保证当前线程有Looper对象，可以有两种情况处理。（1）主ui线程启动，系统就初始化了一个Looper对象，只要在程序中直接创建handler，它就会和Looper自动绑定，然后用handler发送和处理消息。（2）我们自己创建的线程要自己手动创建一个Looper对象了，因为除主线程外，Android中的线程默认是没有开启Looper的。创建Looper对象调用它的prepare()方法 是为了保证每个线程最多一个Looper对象。然后用Looper.loop()启动它。此时loop()方法就会使用一个死循环不断地取出MessageQueue()中的消息，并将消息分给所对应的Handler处理。【注意】写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。线程UI thread 通常就是main thread，而Android启动程序时会替它建立一个Message Queue。总结 Handler负责发送消息，Loop负责接收到Message Queue容器中一个线程里只有一个Looper对象以及一个MessageQueue数据结构。在你的应用程序里，可以定义多个Handler实例 2、为什么要用handler机制更新UI最根本的目的就是为了解决多线程并发的问题！如果在一个activity中有多个线程去更新UI，并且没有加锁，就会出现界面错乱的问题。但是如果对这些更新UI的操作都加锁处理，又会导致性能下降。处于对性能的问题考虑，不用再去关系多线程的问题，所有的更新UI的操作，都是在主线程的消息队列中去轮训的。 3、handler实现流程 Handler实例（Demo） 1、安排消息或Runnable 在某个主线程中某个地方执行；123456789101112131415161718192021222324public class MainActivity extends Activity &#123; //Handler安排 Runnable 在某个主线程中某个地方执行 Handler handler = new Handler(); Runnable thread = new Runnable() &#123; @Override public void run() &#123; System.out.println("HandlerThread:" + Thread.currentThread().getId()); &#125; &#125;; private Button start; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); start = (Button) findViewById(R.id.start); start.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; handler.post(thread); &#125; &#125;); System.out.println("Activity Thread:" + Thread.currentThread().getId()); &#125;&#125; 这个程序看上去似乎实现了Handler的异步机制，handler.post(thread)似乎实现了新启线程的作用，不过通过执行我们发现，两个线程的ID相同！也就是说，实际上thread还是原来 的主线程，由此可见，handler.post()方法并未真正新建线程，只是在原线程上执行而已，我们并未实现异步机制。我们再看下面这个Demo。 2、安排一个动作在其他的线程中执行。（其他线程通过Handler机制UI线程中Button的内容）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends Activity &#123; Button button; MyHandler myHandler; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button = (Button) findViewById(R.id.start); //打印主线程id Log.d("ThreadId", "MainThreadId:"+Thread.currentThread().getId()+""); // 当创建一个新的Handler实例时，它会绑定到当前线程和消息的队列中，开始分发数据 myHandler = new MyHandler(); //开启子线程 MyThread m = new MyThread(); new Thread(m).start(); &#125; /** * 接收消息，处理消息 ，此Handler会与当前主线程一块运行 * */ class MyHandler extends Handler &#123; public MyHandler() &#123; &#125; public MyHandler(Looper L) &#123; super(L); &#125; // 子类必须重写此方法，接收数据 @Override public void handleMessage(Message msg) &#123; Log.d("MyHandler", "handleMessage。。。。。。"); super.handleMessage(msg); // 此处可以更新UI Bundle b = msg.getData(); String color = b.getString("color"); MainActivity.this.button.setText(color); &#125; &#125; class MyThread implements Runnable &#123; public void run() &#123; try &#123; //6秒执行完毕 Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Log.d("ThreadId","MainThreadId:"+Thread.currentThread().getId()+""); Message msg = new Message(); Bundle b = new Bundle();// 存放数据 b.putString("color","我的名字"); msg.setData(b); MainActivity.this.myHandler.sendMessage(msg); // 向Handler发送消息，更新UI &#125; &#125;&#125; 通过打印我们可以看到，两个ID是不同的，新的线程启动了！ 3、HandlerThread 总结使用（1）引言：我们为一个非主线程开启一个Handler时候需要这么做很明显的一点就是，我们要在子线程中调用Looper.prepare() 为一个线程开启一个消息循环，默认情况下Android中新诞生的线程是没有开启消息循环的。（主线程除外，主线程系统会自动为其创建Looper对象，开启消息循环。） Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。 然后通过Looper.loop() 让Looper开始工作，从消息队列里取消息，处理消息。注意：写在Looper.loop()之后的代码不会被执行，这个函数内部应该是一个循环，当调用mHandler.getLooper().quit()后，loop才会中止，其后的代码才能得以运行。「其实这一切都可以用HandlerThread类来帮我们做。」（2）常规用法创建一个HandlerThread1mThread = new HandlerThread("handler_thread"); 启动一个HandlerThread1mThread.start(); （3）小实例12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity &#123; private HandlerThread myHandlerThread; private Handler handler; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //创建一个线程,线程名字：handler-thread myHandlerThread = new HandlerThread("handler-thread"); //开启一个线程 myHandlerThread.start(); //在这个线程中创建一个handler对象 handler = new Handler(myHandlerThread.getLooper()) &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); //这个方法是运行在 handler-thread 线程中的 ，可以执行耗时操作 Log.d("handler ", "消息： " + msg.what + " 线程： " + Thread.currentThread().getName()); &#125; &#125;; //在主线程给handler发送消息 handler.sendEmptyMessage(1); new Thread(new Runnable() &#123; @Override public void run() &#123; //在子线程给handler发送数据 handler.sendEmptyMessage(2); &#125; &#125;).start(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); //释放资源 myHandlerThread.quit(); &#125;&#125; 运行效果：12/com.app D/handler: 消息： 1 线程： handler-thread/com.app D/handler: 消息： 2 线程： handler-thread （4）HandlerThread的特点HandlerThread将loop转到子线程中处理，说白了就是将分担MainLooper的工作量，降低了主线程的压力，使主界面更流畅。HandlerThread拥有自己的消息队列，它不会干扰或阻塞UI线程。对于网络IO操作，HandlerThread并不适合，因为它只有一个线程，还得排队一个一个等着。 【附录】Demo1、安排消息或Runnable 在某个主线程中某个地方执行；2、安排一个动作在其他的线程中执行。（其他线程通过Handler机制UI线程中Button的内容）3、HandlerThread 总结使用 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 屏幕适配及布局优化]]></title>
      <url>%2F2016%2F08%2F27%2FScreenAdaptation%2F</url>
      <content type="text"><![CDATA[为什么要进行屏幕适配为什么要进行屏幕适配、对哪些设备进行适配？在近几年的发展当中，安卓设备数量逐渐增长，由于安卓设备的开放性，导致安卓设备的屏幕尺寸大小碎片化极为严重。从【友盟+】2016年手机生态发展报告H1 中看截止16年手机分辨率使用情况：Android设备720p和1080p是主流，如果对前5中Android设备分辨率进行适配就能让app在90%的安卓设备上比较美观的兼容。 涉及重要概念及关系1.硬件属性 ── 屏幕尺寸、屏幕分辨率、屏幕像素密度【屏幕尺寸】：屏幕对角线长度。单位是英寸，1英寸=2.54厘米。【屏幕分辨率】：屏幕横纵向上的像素点数。单位是px，1px=1像素点。【像素密度】：屏幕每英寸上的像素点数，单位是dpi，即dot per inch缩写。【关系及总结】：屏幕同尺寸分辨率越高(像素点越多),像素密度越大,显示效果越好。像素密度=横向像素点数^2+纵向像素点数^2然后开方取得值,除以屏幕尺寸。【举例】：【Nexus 5 ：4.95英寸、1920*1080、445dpi】445dpi=（√(1080^2+1920^2)）px／4.95 inch 2.计量单位 ── dp、dip、dpi、sp、px。【dpi】：屏幕每英寸上的像素点数，单位是dpi，即dot per inch缩写。【px】：像素，构成图像的最小单位。（进行ui设计、官方原生api返回的数值都是以px作为计量单位的，比如获取屏幕的宽和高。）【dp、dip】：密度无关像素。即Density Independent Pixels缩写。（dp等同于dip，以160dpi为基准，1dp=1px。dp意义在于：你可以根据看到的实际大小，在应用中设置对应的dp值，而使得不同的设备上看起来一样大。）【sp】：即Scale-Independent Pixels。可以根据文字大小首选项进行缩放。推荐使用12sp以上大小的文字；推荐使用12sp、14sp、18sp、22sp；字体大小不要使用奇数和小数，在字体放缩的时候可能导致精度的丢失。【举例】： 3.像素密度 ── mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi。不同的设备上实现非常好的显示效果，因此有多种像素密，主流的5种像素：mdpi、hdpi、xhdpi、xxhdpi、xxxhdpi，以2:3:4:6:8的比例缩放，可修饰drawable和values。AndroidManifest.xml设置在中Menifest中添加子元素android:anyDensity=”true”时，应用程序安装在不同密度的终端上时，程序会分别加载xxhdpi、xhdpi、hdpi、mdpi、ldpi文件夹中的资源。相反，如果设为false，即使在文件夹下拥有相同资源，应用不会自动地去相应文件夹下寻找资源。 解决方案及布局优化适配各种屏幕尺寸(I)线性布局中使用：wrap_content、match_parent、weight属性。在设置控件长宽的时候一般有三种方案：1.直接用dp属性将控件写死。2.wrap_content内容自适应。3.match_parent填充父布局。以下如图为使用wrap_content、match_parent、weight属性实现的小例子：用weight属性将tittle栏中间控件进行拉伸适配，左右控件大小不变。123456789101112131415161718192021&lt;!--实现原理：将中间控件权重设为1--&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="左侧控件" /&gt; &lt;TextView android:layout_weight="1" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="Hello World!" android:textSize="25sp" android:background="#f5f5f5"/&gt; &lt;Button android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="右侧控件 右侧控件" /&gt; &lt;/LinearLayout&gt; [weight属性扩展]将一排所有控件都加上权重比例时，此时可以将宽度 wrap_content 改为0dp12345678910111213141516&lt;LinearLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:orientation="horizontal"&gt; &lt;Button android:layout_weight="1" android:layout_width="0dp" android:layout_height="wrap_content" android:text="左侧控件" /&gt; &lt;Button android:layout_weight="2" android:layout_width="0dp" android:layout_height="wrap_content" android:text="右侧控件" /&gt;&lt;/LinearLayout&gt; 若将layout_width属性设为match_parent的话，比例将会颠倒。[原因]weight等式为：weight计算出的宽度＝原来的宽度＋屏幕剩余控件宽度所占的百分比[解释]假设屏幕宽度为L则左侧控件宽度=L(match_parent)+[L-2L(两个控件总宽)]1/3=2/3L同理右侧控件宽度=L(match_parent)+[L-2L(两个控件总宽)]2/3=1/3L为了证明等式成立，将宽度改为0dp再算一次则左侧控件宽度=0dp+[L-0-0]1/3=1/3L则左侧控件宽度=0dp+[L-0-0]2/3=2/3L (II)使用相对布局、禁用绝对布局。绝对布局以一坐标的方式来定位在屏幕上的位置，此布局难维护，一旦屏幕分辨率发生变化，由于相对位置绝对性，控件将不会自动适配宽高，如图。线性布局优势可以用weight去适配屏幕的比例大小，但是一些比较复杂的布局，线性布局使用起来就比较麻烦，这个时候我们可以使用相对布局来适配优化，如图为官方demo，第二排的ok按钮，我们只需要让它紧贴父布局右侧。Cancel按钮只需位于OK按钮左侧。（若用线性布局去实现，则至少需要两次嵌套。）1234567891011121314151617181920212223&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" &gt; &lt;EditText android:layout_width="match_parent" android:layout_height="wrap_content" android:id="@+id/edit" /&gt; &lt;Button android:layout_alignParentRight="true" android:layout_below="@id/edit" android:text="OK" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/button2" /&gt; &lt;Button android:layout_toLeftOf="@id/button2" android:layout_below="@id/edit" android:text="CANCEL" android:layout_width="wrap_content" android:layout_height="wrap_content" android:id="@+id/button3" /&gt;&lt;/RelativeLayout&gt; (III)使用限定符适配平板设备：large限定符、最小限定符、方向限定符。[使用large限定符]分别创建layout/main.xml，layout-large/main.xml下的不同布局，以适配手机和平板。 12345678910111213141516171819202122232425//res/layout/main.xml 单面板&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/headlines" android:layout_height="fill_parent" aandroid:layout_width="match_parent" /&gt;&lt;/LinearLayout&gt;//res/layout-large/main.xml 双面板&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="horizontal"&gt; &lt;fragment android:id="@+id/headlines" android:layout_height="fill_parent" android:name="com.bb.HeadlinesFragment" android:layout_width="400dp" android:layout_marginRight="10dp"/&gt; &lt;fragment android:id="@+id/article" android:layout_height="fill_parent" android:name="com.bb.ArticleFragment" android:layout_width="fill_parent" /&gt;&lt;/LinearLayout&gt; 注意large限定符是在安卓3.2版本以前版本才会起作用的！3.2之后，为了能更精确判断平板范围，谷歌推出了[最小宽度限定符]。12345678910111213141516171819202122232425//res/layout/main.xml，单面板（默认）布局：&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="vertical" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;fragment android:id="@+id/headlines" android:layout_height="fill_parent" android:name="com.bb.HeadlinesFragment" android:layout_width="match_parent" /&gt;&lt;/LinearLayout&gt;//res/layout-sw600dp/main.xml，双面板布局： Small Width 最小宽度&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="fill_parent" android:layout_height="fill_parent" android:orientation="horizontal"&gt; &lt;fragment android:id="@+id/headlines" android:layout_height="fill_parent" android:name="com.bb.HeadlinesFragment" android:layout_width="400dp" android:layout_marginRight="10dp"/&gt; &lt;fragment android:id="@+id/article" android:layout_height="fill_parent" android:name="com.bb.ArticleFragment" android:layout_width="fill_parent" /&gt;&lt;/LinearLayout&gt; 通过以上，想要兼容安卓3.2之前的平板设备，需要设置添加这三种lyout。res/layout/main.xml: 单面板布局res/layout-large/main.xml: 多面板布局res/layout-sw600dp/main.xml: 多面板布局这样维护起来比较困难，如改变large面板布局，还要去更改sw600dp 面板。我们引入[布局别名]：将多面板相同的地方抽取出来设为main_twopanes进行统一的管理。res/layout/main.xml 单面板布局res/layout/main_twopanes.xml 双面板布局所以我们这么来操作。 12345678910111213141516setContentView(R.layout.custom-main);默认布局res/values/layout.xml:&lt;resources&gt;&lt;item name="custom-main" type="layout"&gt;@layout/main&lt;/item&gt;&lt;/resources&gt;Android3.2之前的平板布局res/values-large/layout.xml:&lt;resources&gt;&lt;item name="custom-main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt;Android3.2之后的平板布局res/values-sw600dp/layout.xml:&lt;resources&gt;&lt;item name="custom-main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt; 1234567891011最后一种限定符:[方向限定符]//平板横向res/values-sw600dp-land/layouts.xml:&lt;resources&gt;&lt;item name="custom-main" type="layout"&gt;@layout/main_twopanes&lt;/item&gt;&lt;/resources&gt;//平板竖直res/values-sw600dp-port/layouts.xml:&lt;resources&gt;&lt;item name="custom-main" type="layout"&gt;@layout/main&lt;/item&gt;&lt;/resources&gt; (IV)使用自动拉伸位图——消息气泡框在Android的设计过程中，为了适配不同的手机分辨率，图片大多需要拉伸或者压缩，这样就出现了可以任意调整大小的一种图片格式“.9.png”。这种图片是用于Android开发的一种特殊的图片格式，它的好处在于可以用简单的方式把一张图片中哪些区域可以拉伸，哪些区域不可以拉伸设定好，同时可以把显示内容区域的位置标示清楚。我们可以明显看到.9.png的外围是有一些黑色的线条的1、2、3、4，它们的作用及说明：序号1和2标识了可以拉伸的区域。（如图只可拉伸标记的一个像素点。）序号3和4标识了内容区域。 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 数据存储与共享]]></title>
      <url>%2F2016%2F07%2F15%2FDataStorage%2F</url>
      <content type="text"><![CDATA[前言Android提供了5种方式来让用户保存持久化应用程序数据。① 使用SharedPreferences存储数据 ② 文件存储数据③ SQLite数据库存储数据④ 使用ContentProvider存储数据⑤ 网络存储数据 我们可以根据需求选择对应的方式。文章根据相关Demo讲述各种方式的用法及优缺点说明，在文章末尾附录会有相关Demo的下载 。通过以上方式还可以实现数据的在不同app间的数据共享。 SharedPreferences1、适用范围保存少量的数据，且这些数据的格式非常简单：字符串型、基本类型的值。比如应用程序的各种配置信息（如是否打开音效、是否使用震动效果、小游戏的玩家积分等），解锁口令密码等。 2、核心原理保存基于XML文件存储的key-value键值对数据。通过DDMS的File Explorer面板，展开文件浏览树,很明显SharedPreferences数据总是存储在/data/data//shared_prefs目录下。SharedPreferences对象本身只能获取数据而不支持存储和修改,存储修改是通过SharedPreferences.edit()获取的内部接口Editor对象实现。SharedPreferences本身是一个接口，程序无法直接创建SharedPreferences实例，只能通过Context提供的getSharedPreferences(String name, int mode)方法来获取SharedPreferences实例，该方法中name表示要操作的xml文件名，第二个参数具体如下：1234567Context.MODE_PRIVATE: 指定该SharedPreferences数据只能被本应用程序读、写。Context.MODE_WORLD_READABLE: 指定该SharedPreferences数据能被其他应用程序读，但不能写。Context.MODE_WORLD_WRITEABLE: 指定该SharedPreferences数据能被其他应用程序读，写。//以上三种写法均已过时，可以直接用数字代替，//Context.MODE_PRIVATE = 0//Context.MODE_WORLD_READABLE = 1//Context.MODE_WORLD_WRITEABLE = 2 Editor有如下主要重要方法：12345678SharedPreferences.Editor clear()//清空SharedPreferences里所有数据SharedPreferences.Editor putXxx(String key , xxx value)://向SharedPreferences存入指定key对应的数据，其中xxx 可以是boolean,float,int等各种基本类型据SharedPreferences.Editor remove()//删除SharedPreferences中指定key对应的数据项boolean commit()//当Editor编辑完成后，使用该方法提交修改 3、app内部实现数据存储（Demo）通过点击“保存用户名”，对登陆成功的用户进行用户名键值对的保存，让用户下次启动app时自动填充用户名。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private EditText userName,userPass; private CheckBox checkBox; private Button ok,cancel; private SharedPreferences pref; private SharedPreferences.Editor editor; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //初始化SharedPreferences 及相关组建。 init(); //3、取出userInfo中的数据。 String name00=pref.getString("userName",null); if (name00==null) &#123; checkBox.setChecked(false); &#125;else &#123; checkBox.setChecked(true); //4、将取到的用户名赋给用户名编辑框。 userName.setText(name00); &#125; &#125; private void init() &#123; userName = (EditText) findViewById(R.id.userName); userPass = (EditText) findViewById(R.id.userPass); checkBox = (CheckBox) findViewById(R.id.check); ok = (Button) findViewById(R.id.join_btn); cancel = (Button) findViewById(R.id.cancel_btn); ok.setOnClickListener(this); cancel.setOnClickListener(this); //1、获取SharedPreferences对象，并把文件名设为"userInfo"。 pref =getSharedPreferences("userInfo", MODE_PRIVATE); //2、获取SharedPreferences内部接口Editor用来编辑userInfo。 editor = pref.edit(); &#125; @Override public void onClick(View v) &#123; //2.1：获取用户输入的用户名密码信息。 String name = userName.getText().toString(); String pass = userPass.getText().toString(); switch (v.getId()) &#123; case R.id.join_btn: if ("admin".equals(name)&amp;&amp;"123456".equals(pass))&#123; if(checkBox.isChecked())&#123; //2.2.1：判断成功登入并对"保存用户名"打勾之后， //将用户名的键值对添加到文件名为"userInfo"文件中并提交。 editor.putString("userName",name); editor.commit(); &#125;else&#123; //2.2.2若没打勾，则清空并提交。 editor.remove("userName"); editor.commit(); &#125; Toast.makeText(this,"登陆成功",Toast.LENGTH_SHORT).show(); &#125;else&#123; Toast.makeText(this,"登陆失败",Toast.LENGTH_SHORT).show(); &#125; break; case R.id.cancel_btn: userName.setText(null); userPass.setText(null); break; &#125; &#125; 效果登入成功第二次打开自动填充用户名。【在DDMS中依次打开data/data/&lt;包&gt;/shared_prefs，可以看到此文件内容】 4、共享其他应用的SharedPreferences在创建SharedPreferences时，指定MODE_WORLD_READABLE模式，表明该SharedPreferences数据可以被其他程序读取。1SharedPreferences pref =getSharedPreferences("userInfo", MODE_WORLD_READABLE); 创建其他应用程序对应的Context上下文引用:1234567Context otherAppContent = null; try &#123; otherAppContent = createPackageContext("com.bb.sharedpr",CONTEXT_IGNORE_SECURITY);//com.bb.sharedpr为我们要调用数据的包名 &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; 使用其他程序的Context获取对应的SharedPreferences1SharedPreferences read = otherAppContent.getSharedPreferences("userInfo",MODE_WORLD_READABLE); 如果是写入数据，使用Editor接口即可，所有其他操作均和前面一致。 5、关于android:sharedUserId通常，不同的APK会具有不同的userId，因此运行时属于不同的进程中，而不同进程中的资源是不共享的，才保障了程序运行的稳定。然后在有些时候，我们自己开发了多个APK并且需要他们之间互相共享资源，那么就需要通过设置shareUserId来实现这一目的。通过SharedUserId,拥有同一个User id的多个APK可以配置成运行在同一个进程中.所以默认就是可以通过获取上下文来互相访问任意数据. 也可以配置成运行成不同的进程, 同时可以访问其他APK的数据目录下的数据库和文件.就像访问本程序的数据一样。而上面的两个工程中并没有对Android:sharedUserId属性进行设置。这个属性是在查资料时看到的：意思是说，在manifest.xml里面将两个应用程序的android:sharedUserId属性设为相同的就可以对SharedPreferences文件进行写。（此处并没有验证） 6、SharedPreferences总结优点SharedPreferences对象与SQLite数据库相比显得格外轻量级，免去了创建数据库，创建表，写SQL语句等诸多操作，相对而言更加方便，简洁。缺点1、其职能存储boolean，int，float，long和String五种简单的数据类型。2、无法进行条件查询等。【所以不论SharedPreferences的数据存储操作是如何简单，它也只能是存储方式的一种补充，而无法完全替代如SQLite数据库这样的其他数据存储方式。】 文件存储数据1、功能介绍Android文件系统和其他平台上的类似，使用File APIs可以读写文件。这部分内容需要你已经了解了Linux文件系统的基础，并且也了解了java.io包中的标准文件输入输出APIs。 2、存储方式所有的Android设备都有两块文件存储区域：内部和外部存储。内部存储：指设备自带的非易失性存储器。永远可用，因为不可以拆卸。文件默认情况下只对你的app可用，是私有的，无论是用户或者是其他app都不能共享访问你的数据。当用户卸载你的app时，系统会自动移除app在内部存储上的所有文件。外部存储：指可拆卸的存储介质，如卫星电视SD卡。不一定一直可以访问，因为用户可以拆卸外部存储设备。文件是全局可读的，没有访问限制，不受你的控制。可以和其他app共享数据，用户使用电脑也可以访问在外部存储中的文件。当用户卸载你的app时，只有当你把文件存储在以 getExternalFilesDir().获得的路径下时，系统才会帮你自动移除。 3、使用内部存储（Demo）Context提供了两个方法来打开数据文件里的文件IO流1234FileInputStream openFileInput(String name); FileOutputStream openFileInput(String name , int mode);//name参数: 用于指定文件名称，不能包含路径分隔符“/” ,//如果文件不存在，Android 会自动创建它。 这两个方法第一个参数 用于指定文件名，第二个参数指定打开文件的模式。1234567MODE_PRIVATE：为默认操作模式，代表该文件是私有数据，只能被应用本身访问，在该模式下， 写入的内容会覆盖原文件的内容，如果想把新写入的内容追加到原文件中。可以使用Context.MODE_APPENDMODE_APPEND：模式会检查文件是否存在，存在就往文件追加内容，否则就创建新文件。MODE_WORLD_READABLE：表示当前文件可以被其他应用读取。MODE_WORLD_WRITEABLE：表示当前文件可以被其他应用写入。模式可以连用 比如可读可写 就写成：MODE_WORLD_READABLE+MODE_WORLD_WRITEABLE 除此之外，Context还提供了如下几个重要的方法：123getDir(String name , int mode):在应用程序的数据文件夹下获取或者创建name对应的子目录getFilesDir():获取该应用程序的数据文件夹得绝对路径fileList():返回该应用数据文件夹的全部文件 我们将实现的Demo为将输入的文字写入文件，并读取出来。第一步：创建和写入一个内部存储的私有文件：12345678910111213141516public void WriteFiles(String content)&#123; try &#123; //①调用Context的openFileOutput()函数，填入文件名和操作模式，它会返回一个FileOutputStream对象。 FileOutputStream fos = openFileOutput("a.txt", MODE_PRIVATE); //②通过FileOutputStream对象的write()函数写入数据。 fos.write(content.getBytes()); //③FileOutputStream对象的close ()函数关闭流。 fos.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 第二步：读取一个内部存储的私有文件：12345678910111213141516171819202122public String readFiles()&#123; String content = null; try &#123; //① 调用openFileInput( )，参数中填入文件名，会返回一个FileInputStream对象。 FileInputStream fis= openFileInput("a.txt"); StringBuilder sb = new StringBuilder(); byte [] buffer = new byte[1024]; int len = 0; //② 使用流对象的 read()方法读取字节 while ((len=fis.read(buffer))!=-1) &#123; sb.append(new String(buffer, 0, len)); &#125; content =sb.toString(); //③ 调用流的close()方法关闭流 fis.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return content; &#125; 第三步：MainActivity中实现流程：1234567891011121314protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); edt = (EditText) findViewById(R.id.editText1); but = (Button) findViewById(R.id.write); contentvalue = (TextView) findViewById(R.id.contentvalue); but.setOnClickListener(new OnClickListener() &#123; @Override public void onClick(View v) &#123; WriteFiles(edt.getText().toString()); contentvalue.setText(readFiles()); &#125; &#125;); &#125; 效果 【注意】保存内存缓存文件有时候我们只想缓存一些数据而不是持久化保存，可以使用getCacheDir()去创建或打开一个文件，文件的存储目录（ /data/data/包名/cache ）是一个应用专门来保存临时缓存文件的内存目录。12File file = this.getCacheDir();Log.i("info", file.toString(); 当设备的内部存储空间比较低的时候，Android可能会删除这些缓存文件来恢复空间，但是你不应该依赖系统来回收，要自己维护这些缓存文件把它们的大小限制在一个合理的范围内，比如1ＭＢ．当你卸载应用的时候这些缓存文件也会被移除。 4、使用外部存储（Demo）因为内部存储容量限制，有时候需要存储数据比较大的时候需要用到外部存储，使用外部存储分为以下几个步骤：第一步：添加外部存储访问限权12345&lt;!-- 在AndroidManifest.xml中加入访问SDCard的权限--&gt; &lt;!-- 在SDCard中创建与删除文件权限 --&gt; &lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS"/&gt; &lt;!-- 往SDCard写入数据权限 --&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 第二步：检测外部存储的可用性12345678910//获取外存储的状态String state = Environment.getExternalStorageState();if (Environment.MEDIA_MOUNTED.equals(state)) &#123; // 可读可写 mExternalStorageAvailable = mExternalStorageWriteable = true;&#125; else if (Environment.MEDIA_MOUNTED_READ_ONLY.equals(state)) &#123; // 可读&#125; else &#123; // 可能有很多其他的状态，但是我们只需要知道，不能读也不能写 &#125; 第三步：读写数据123456789101112131415161718192021222324252627282930313233343536public class MainActivity extends Activity &#123; private TextView textView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView= (TextView) findViewById(R.id.tv); if(Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED))&#123; File sdCardDir = Environment.getExternalStorageDirectory(); //获取SDCard目录 "/sdcard" File saveFile = new File(sdCardDir,"a.txt"); //写数据 try &#123; FileOutputStream fos= new FileOutputStream(saveFile); fos.write("bobobo".getBytes()); fos.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //读数据 try &#123; FileInputStream fis= new FileInputStream(saveFile); int len =0; byte[] buf = new byte[1024]; StringBuffer sb = new StringBuffer(); while((len=fis.read(buf))!=-1)&#123; sb.append(new String(buf, 0, len)); &#125; textView.setText(sb.toString()); fis.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 效果 SQLite数据库存储数据1、简介及特点SQLite是轻量级嵌入式数据库引擎，且只利用很少的内存就有很好的性能。在我们为移动设备开发应用程序时，使用SQLite作为复杂数据、大量数据的存储引擎。SQLite它是一个独立的，无需服务进程，无需安装和管理配置，支持事务处理，可以使用SQL语言的数据库。支持多种开发语言，C，PHP，Perl，Java，ASP.NET，Python。在Content Provider 技术中就是使用SQLite数据库来操作数据的。 2、实现原理直接通过SQLiteDatabase对象来创建一个数据库。或者继承SQLiteOpenHelper类封装创建和更新数据库使用的逻辑。它们都会在ddns 的file explorer 中的data/data/&lt;包&gt;/databases中创建这个数据库文件。 3、通过SQLiteDatabase创建（Demo）第一步：创建数据库并插入数据12345678910private SQLiteDatabase db;public void init() &#123; db = openOrCreateDatabase("user.db", MODE_PRIVATE, null); db.execSQL("create table if not exists usertb (_id integer primary key autoincrement, name text not null , age integer not null , sex text not null )"); db.execSQL("insert into usertb(name,sex,age) values('张三','女',18)"); db.execSQL("insert into usertb(name,sex,age) values('李四','男',19)"); db.execSQL("insert into usertb(name,sex,age) values('王五','女',22)"); //查询数据库并展示 query(findViewById(R.id.query)); &#125; query代码【关于查询代码的详情在本小节末尾会有详细说明】1234567891011121314151617public void query(View view) &#123; tv_id.setText(""); tv_name.setText(""); tv_sex.setText(""); tv_age.setText(""); Cursor cursor = db.rawQuery("select * from usertb", null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; tv_id.append("\n" + cursor.getString(cursor.getColumnIndex("_id"))); tv_name.append("\n" + cursor.getString(cursor.getColumnIndex("name"))); tv_sex.append("\n" + cursor.getString(cursor.getColumnIndex("sex"))); tv_age.append("\n" + cursor.getString(cursor.getColumnIndex("age"))); &#125; cursor.close(); &#125;// db.close();不要关闭，不然单独调用查询操作会空指针 &#125; 效果第二步：实现插入数据的操作（两种方式任选其一）使用insert方法12345678910public void add(View view) &#123; ContentValues cv = new ContentValues();//实例化一个ContentValues用来装载待插入的数据 cv.put("name","新来的"); cv.put("sex","女"); cv.put("age","18"); db.insert("usertb",null,cv);//执行插入操作// 使用直接执行语句添加 // db.execSQL("insert into usertb(name,sex,age) values('新来的','女',18)"); query(findViewById(R.id.query)); &#125; 使用execSQL方式来实现1db.execSQL("insert into usertb(name,sex,age) values('新来的','女',18)"); 效果 第三步：实现删除数据的操作同样有2种方式可以实现123String whereClause = "name=?";//删除的条件String[] whereArgs = &#123;"新来的"&#125;;//删除的条件参数db.delete("user",whereClause,whereArgs);//执行删除 使用execSQL方式的实现12String sql = "delete from usertb where name='新来的'";//删除操作的SQL语句db.execSQL(sql);//执行删除操作 第四步：实现修改数据的操作（将张三改成张三三）同上，仍是2种方式12345ContentValues cv = new ContentValues();//实例化ContentValuescv.put("name","张三三");//添加要更改的字段及内容String whereClause = "name=?";//修改条件String[] whereArgs = &#123;"张三"&#125;;//修改条件的参数db.update("usertb",cv,whereClause,whereArgs);//执行修改 使用execSQL方式的实现12String sql = "update usertb set name = '张三三' where username='张三'";//修改的SQL语句db.execSQL(sql);//执行修改 【关于查询操作】查询操作相对于上面的几种操作要复杂些，因为我们经常要面对着各种各样的查询条件，所以系统也考虑到这种复杂性，为我们提供了较为丰富的查询形式：1234db.rawQuery(String sql, String[] selectionArgs); db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy); db.query(String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit); db.query(String distinct, String table, String[] columns, String selection, String[] selectionArgs, String groupBy, String having, String orderBy, String limit); 各参数说明：12345678910table：表名称colums：表示要查询的列所有名称集selection：表示WHERE之后的条件语句，可以使用占位符selectionArgs：条件语句的参数数组groupBy：指定分组的列名having：指定分组条件,配合groupBy使用orderBy：y指定排序的列名limit：指定分页参数distinct：指定“true”或“false”表示要不要过滤重复值Cursor：返回值，相当于结果集ResultSet 最后，他们同时返回一个Cursor对象，代表数据集的游标，有点类似于JavaSE中的ResultSet。下面是Cursor对象的常用方法：12345678910111213141516c.move(int offset); //以当前位置为参考,移动到指定行 c.moveToFirst(); //移动到第一行 c.moveToLast(); //移动到最后一行 c.moveToPosition(int position); //移动到指定行 c.moveToPrevious(); //移动到前一行 c.moveToNext(); //移动到下一行 c.isFirst(); //是否指向第一条 c.isLast(); //是否指向最后一条 c.isBeforeFirst(); //是否指向第一条之前 c.isAfterLast(); //是否指向最后一条之后 c.isNull(int columnIndex); //指定列是否为空(列基数为0) c.isClosed(); //游标是否已关闭 c.getCount(); //总数据项数 c.getPosition(); //返回当前游标所指向的行数 c.getColumnIndex(String columnName);//返回某列名对应的列索引值 c.getString(int columnIndex); //返回当前行指定列的值 举例1234db.update("stutb", values, "_id&gt;?", new String[]&#123;"3"&#125;);//把id&gt;3的性别更新成"女"db.delete("stutb", "name like ?", new String[]&#123;"%丰%"&#125;);//删掉名字中带有"丰"的记录//使用游标类 进行查询Cursor c = db.query("stutb", null, "_id&gt;?", new String[]&#123;"0"&#125;, null, null, "_id"); 4、通过继承SQLiteOpenHelper类创建Android 提供了 SQLiteOpenHelper，其是SQLiteDatabase的一个帮助类，用来管理数据库的创建和版本的更新。你只要继承 SQLiteOpenHelper 类根据开发应用程序的需要，封装创建和更新数据库使用的逻辑就行了。第一步：写一个子类继承SQLiteOpenHelper并复写三个方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class DatabaseHelper extends SQLiteOpenHelper &#123; /** * @param context 上下文环境（例如，一个 Activity） * @param name 数据库名字 * @param factory 一个可选的游标工厂（通常是 Null） * @param version 数据库模型版本的整数 * * 会调用父类 SQLiteOpenHelper的构造函数 */ // public DatabaseHelper(Context context, String name, CursorFactory factory, int version) &#123; // super(context, name, factory, version); // &#125; //这里我们直接定义数据库名字根版本号 private static final String DATABASE_NAME = "stu.db"; private static final int VERSION = 1; private static final String TABLE_NAME = "stutb"; // 步骤2：重载构造方法 public DatabaseHelper(Context context) &#123; super(context, DATABASE_NAME, null, VERSION); &#125; /** * 在数据库第一次创建的时候会调用这个方法 * *根据需要对传入的SQLiteDatabase 对象填充表和初始化数据。 */ //在这里进行建表 @Override public void onCreate(SQLiteDatabase db) &#123; db.execSQL("create table if not exists stutb(_id integer primary key autoincrement,name text not null,sex text not null,age integer not null)"); db.execSQL("insert into stutb(name,sex,age)values('张三','男',18)"); db.execSQL("insert into stutb(name,sex,age)values('张四','女',20)"); &#125; /** * 当数据库需要修改的时候（两个数据库版本不同），Android系统会主动的调用这个方法。 * 一般我们在这个方法里边删除数据库表，并建立新的数据库表. */ @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; //三个参数，一个 SQLiteDatabase 对象，一个旧的版本号和一个新的版本号 &#125; @Override public void onOpen(SQLiteDatabase db) &#123; // 每次成功打开数据库后首先被执行 super.onOpen(db); &#125;&#125; 第二步：继承SQLiteOpenHelper之后就拥有了以下两个方法getReadableDatabase() 创建或者打开一个查询数据库getWritableDatabase() 创建或者打开一个可写数据库123456789DatabaseHelper database = new DatabaseHelper(MainActivity.this);//传入一个上下文参数SQLiteDatabase db = null;db = database.getWritableDatabase();//上面这段代码会返回一个 SQLiteDatabase 类的实例，使用这个对象，你就可以查询或者修改数据库。getWritableDatabase()和getReadableDatabase()方法都可以获取一个用于操作数据库的SQLiteDatabase实例。// 其中getReadableDatabase()方法则是先以读写方式打开数据库，如果数据库的磁盘空间满了，就会打开失败，当打开失败后// 会继续尝试以只读方式打开数据库。如果该问题成功解决，则只读数据库对象就会关闭，然后返回一个可读写的数据库对象。// getWritableDatabase() 方法以读写方式打开数据库，一旦数据库的磁盘空间满了，数据库就只能读而不能写，// 使用的是getWritableDatabase() 方法就会出错。 第三步：实现查询代码1234567891011Cursor c = db.rawQuery("select * from stutb", null); if (c!=null) &#123; String [] cols = c.getColumnNames(); while (c.moveToNext()) &#123; for (String ColumnName : cols) &#123; Log.i("info ", ColumnName+":"+c.getString(c.getColumnIndex(ColumnName))); &#125; &#125; c.close(); &#125; db.close(); 效果(命令行打印) 5、两种方式的联系Context.openOrCreateDatabase 与 SQLiteDatabase.openOrCreateDatabase本质上完成的功能都一样，Context.openOrCreateDatabase最终是需要调用 SQLiteDatabase.openOrCreateDatabase来完成数据库的创建的。 也就是说， SQLiteDatabase类是android上对sqlite的最底层的封装，几乎所有的对数据库的操作最终都通过这个类来实现。对数据表的操作方式不同，SQLiteOpenHelper是SQLiteDatabase的帮助类。要如你的代码执行，你需要通过类似SQLiteOpenHelper的getWritableDatabase方法获取到SQLiteDatabase实例才可以。创建表直接可以在SQLiteOpenHelper的onCreate方法中做，那里通过参数你可以得到一个SQLiteDatabase的实例。 使用ContentProvider存储数据与SQLite数据库联系1.SQLiteOpenHelper是将对数据库和表的创建、插入、更新、删除操作进行了简单的封装；2.而ContentProvider可以说是一个对外的接口，除了可以实现对SQLiteOpenHelper的封装，还可以实现对文件操作、图片操作、对象操作等实现封装；3.在多线程中使用SQLiteOpenHelper要考虑线程同步问题，而如果使用ContentProvider的话基本不用考虑；4.使用ContentProvider存储数据可以实现不同app之间的数据共享。详见：Android实习生 —— 四大组件之ContentProvider 网络存储数据一、网络保存数据介绍可以使用网络来保存数据，在需要的时候从网络上获取数据，进而显示在App中。用网络保存数据的方法有很多种，对于不同的网络数据采用不同的上传与获取方法。本文利用LeanCloud来进行网络数据的存储。LeanCloud是一种简单高效的数据和文件存储服务。感兴趣的可以查看网址：https://leancloud.cn/。 的例子。 二、使用方法1、上传数据1234567891011121314AVObject personObject = new AVObject(TABLENAME); personObject.put(NAME, person.name); personObject.put(AGE, person.age); personObject.put(INFO, person.info); personObject.saveInBackground(new SaveCallback() &#123; @Override public void done(AVException e) &#123; if (e == null) &#123; Log.v(TAG, "put data success!"); &#125; else &#123; Log.v(TAG, "put data failed!error:" + e.getMessage()); &#125; &#125; &#125;); 2、读取数据12345678910111213141516171819AVQuery&lt;AVObject&gt; avQuery = new AVQuery&lt;&gt;(TABLENAME); avQuery.findInBackground(new FindCallback&lt;AVObject&gt;() &#123; @Override public void done(List&lt;AVObject&gt; list, AVException e) &#123; if (e == null) &#123; Log.v(TAG, "get data success!"); String message = ""; //倒着遍历后四条上传的数据 for (int i = list.size()-1; i &gt;=list.size()-4; i--) &#123; String name = list.get(i).getString(NAME); int age = list.get(i).getInt(AGE); String info = list.get(i).getString(INFO); message += "name:" + name + ",age:" + age + ",info:" + info + ".\n"; &#125; textView.setText(message); &#125; &#125; &#125;); 三、小案例1、导入jar包2、添加NetworkDBManager类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.zhangmiao.datastoragedemo;import android.util.Log;import android.widget.TextView;import com.avos.avoscloud.AVException;import com.avos.avoscloud.AVObject;import com.avos.avoscloud.AVQuery;import com.avos.avoscloud.FindCallback;import com.avos.avoscloud.SaveCallback;import java.util.List;/** * Created by zhangmiao on 2016/12/22. */public class NetworkDBManager &#123; private static final String TAG = "NetworkDBManager"; private final static String TABLENAME = "person"; private final static String NAME = "name"; private final static String AGE = "age"; private final static String INFO = "info"; public void putData(Person person) &#123; AVObject personObject = new AVObject(TABLENAME); personObject.put(NAME, person.name); personObject.put(AGE, person.age); personObject.put(INFO, person.info); personObject.saveInBackground(new SaveCallback() &#123; @Override public void done(AVException e) &#123; if (e == null) &#123; Log.v(TAG, "put data success!"); &#125; else &#123; Log.v(TAG, "put data failed!error:" + e.getMessage()); &#125; &#125; &#125;); &#125; public void getData(final TextView textView) &#123; AVQuery&lt;AVObject&gt; avQuery = new AVQuery&lt;&gt;(TABLENAME); avQuery.findInBackground(new FindCallback&lt;AVObject&gt;() &#123; @Override public void done(List&lt;AVObject&gt; list, AVException e) &#123; if (e == null) &#123; Log.v(TAG, "get data success!"); String message = ""; ////倒着遍历后四条上传的数据 for (int i = list.size()-1; i &gt;=list.size()-4; i--) &#123; String name = list.get(i).getString(NAME); int age = list.get(i).getInt(AGE); String info = list.get(i).getString(INFO); message += "name:" + name + ",age:" + age + ",info:" + info + ".\n"; &#125; textView.setText(message); &#125; &#125; &#125;); &#125;&#125; 3、修改AndroidManifest.xml文件12&lt;uses-permission android:name="android.permission.INTERNET" /&gt;&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; 4、MainActivity12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends AppCompatActivity implements View.OnClickListener &#123; private NetworkDBManager mNetworkDBManager; private TextView mTableInfo; private EditText et1,et2,et3; @Override protected void onCreate(Bundle savedInstanceState) &#123; Log.v("MainActivity", "onCreate"); super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); AVOSCloud.initialize(this, "yMNUazdBt872mNtC9aSakjYy-gzGzoHsz", "d4vw3VYdMCjLpsXRhHTBRutC"); mNetworkDBManager = new NetworkDBManager(); et1= (EditText) findViewById(R.id.name); et2= (EditText) findViewById(R.id.age); et3= (EditText) findViewById(R.id.sex); Button networkGet = (Button) findViewById(R.id.network_get); Button networkPut = (Button) findViewById(R.id.network_put); mTableInfo = (TextView) findViewById(R.id.table_info); networkGet.setOnClickListener(this); networkPut.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.network_put: Person person3 = new Person(et1.getText().toString(), Integer.parseInt(et2.getText().toString()), et3.getText().toString()); mNetworkDBManager.putData(person3); Toast.makeText(this,"上传成功",Toast.LENGTH_SHORT).show(); break; case R.id.network_get: mNetworkDBManager.getData(mTableInfo); break; default: Log.v("MainActivity", "default"); break; &#125; &#125;&#125; #【附录】 Demo一、SharedPreferencesapp内部实现数据存储其他app实现共享数据【先安装使用第一个并登入才可以使用第二个】二、文件存储数据内部存储外部存储三、SQLite数据库存储数据SQLiteDatabase直接操作数据库继承SQLiteOpenHelper类操作数据库四、ContentProvider无五、网络存储数据网络存储 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之ContentProvider]]></title>
      <url>%2F2016%2F07%2F05%2FContentProvider%2F</url>
      <content type="text"><![CDATA[基础回顾简介ContentProvider（数据提供者）是在应用程序间共享数据的一种接口机制，虽然我们可以采用文件存储方式、sharedpreferences方式在程序间进行共享数据，但ContentProvider提供了更为高级的数据共享方法，应用程序可以指定需要共享的数据，而其他应用程序则可以在不知数据来源、路径的情况下，对共享数据进行查询、添加、删除和更新等操作，当应用继承ContentProvider类，并重写该类用于提供数据和存储数据的方法，就可以向其他应用共享其数据。 特点1、为存储和获取数据提供了统一的接口。2、可以在不同的应用程序之间共享数据。3、使用数据库表的形式来组织数据进行封装。数据库使用：Android实习生 —— 数据存储与共享4、为应用间的数据交互提供了一个安全的环境。它准许你把自己的应用数据根据需求开放给其他应用进行增、删、改、查，而不用担心直接开放数据库权限而带来的安全问题。【总的来说使用ContentProvider对外共享数据的好处是统一了数据的安全访问方式。】 使用场景Android已经为常见的一些数据提供了系统默认的ContentProvider，比如去获取通讯录信息、获取图片、视频信息。我们可以在其他应用程通过提供的ContentProvider获取这些数据。 相关概念1、Uri通用资源标志符（Universal Resource Identifier, 简称”URI”）。Uri代表了要操作的数据，它为系统的每一个资源给其一个名字，比方说通话记录。每一个ContentProvider都拥有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。URI一般主要由三部分组成：Authority：授权信息，用以区别不同的ContentProvider，外部调用者可以根据这个标识来找到它。为了保证URI标识的唯一性，它必须是一个完整的、小写的类名。这个标识在 元素的 authorities属性中说明：一般是定义该ContentProvider的包.类的名称。12&lt;provider android:name=".MyProvider" android:authorities="com.xxx.MyApp.myprovider" /&gt; Path：表名，用以区分ContentProvider中不同的数据表；Id：Id号，用以区别表中的不同数据记录；如果没有ID，就表示返回全部； “content://com.xxx.MyApp.myprovider/tablename/#” #表示数据id。【举例】1、要操作person表中id为10的记录，可以构建这样的路径:/person/102、要操作person表中id为10的记录的name字段， person/10/name3、要操作person表中的所有记录，可以构建这样的路径:/person4、如果要把一个字符串转换成Uri，可以使用Uri类中的parse()方法，如下：Uri uri = Uri.parse(“content://com.xxx.MyApp.myprovider/person”)【每个ContentProvider都有一个公共的URI，这个URI用于表示这个ContentProvider所提供的数据。Android所提供的ContentProvider都存放在android.provider包当中】 2、工具类：UriMatcher因为Uri代表了要操作的数据，所以我们经常需要解析Uri，并从Uri中获取数据。Android系统提供了两个用于操作Uri的工具类，分别为UriMatcher和ContentUris 。掌握它们的使用，会便于我们的开发工作。使用方法如下：第一步，初始化：12//常量UriMatcher.NO_MATCH表示不匹配任何路径的返回码UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); 第二步，注册需要的Uri:1234//如果match()方法匹配content://com.xxx.MyApp.myprovider/person路径，返回匹配码为1matcher.addURI("com.xxx.MyApp.myprovider", "person", 1); //如果match()方法匹配content://com.xxx.MyApp.myprovider/person/230路径，返回匹配码为2matcher.addURI("com.xxx.MyApp.myprovider", "person/#", 2); //#号为通配符 第三步，与已经注册的Uri进行匹配:1234567891011Uri uri = Uri.parse("content://com.xxx.MyApp.myprovider/people"); int match = matcher.match(uri); switch (match) &#123; case 1: break; case 2: break; default: break; &#125; match方法匹配后会返回一个匹配码Code，即在使用注册方法addURI时传入的第三个参数。 3、工具类ContentUris：ContentUris类用于操作Uri路径后面的ID部分，它有两个比较实用的方法：withAppendedId(uri, id)用于为路径加上ID部分：123Uri uri = Uri.parse("content://com.xxx.MyApp.myprovider/person")Uri resultUri = ContentUris.withAppendedId(uri, 10); //生成后的Uri为：content://com.xxx.MyApp.myprovider/person/10 parseId(uri)方法用于从路径中获取ID部分：12Uri uri = Uri.parse("content://com.xxx.MyApp.myprovider/person/10")long personid = ContentUris.parseId(uri);//获取的结果为:10 使用ContentProvider共享数据(Demo，下载链接见附录)1、建立一个Provider所用到变量类1234567891011121314151617181920public class ContentData &#123; //provider唯一标示信息 protected static final String CONTENT_AUTHORITY = "com.xxx.MyApp.myprovider"; //基础Uri protected static final Uri BASE_CONTENT_URI = Uri.parse("content://" + CONTENT_AUTHORITY); //操作表的名称 protected static final String PATH_TEST = "people"; //表中记录信息 public static final class TestEntry implements BaseColumns &#123; // 完整Uri public static final Uri CONTENT_URI = BASE_CONTENT_URI.buildUpon().appendPath(PATH_TEST).build(); protected static Uri buildUri(long id) &#123; return ContentUris.withAppendedId(CONTENT_URI, id); &#125; protected static final String TABLE_NAME = "people"; public static final String COLUMN_NAME = "name"; public static final String COLUMN_SEX = "sex"; public static final String COLUMN_AGE = "age"; &#125;&#125; 2、Provider最终还要操作数据库，这里我们写数据库操作类代码数据库使用：Android实习生 —— 数据存储共享1234567891011121314151617181920212223242526272829303132public class DBOpenHelper extends SQLiteOpenHelper &#123; //数据库版本 private static final int DATABASE_VERSION = 1; //数据库名称 private static final String DATABASE_NAME = "people.db"; //构造方法 public DBOpenHelper(Context context) &#123; super(context, DATABASE_NAME,null, DATABASE_VERSION); &#125; //通过sql语句建表并插入数据 @Override public void onCreate(SQLiteDatabase db) &#123; System.out.println("create table"); final String SQL_CREATE_CONTACT_TABLE = "CREATE TABLE " + ContentData.TestEntry.TABLE_NAME + "( " + "_id integer primary key autoincrement," + ContentData.TestEntry.COLUMN_NAME + " TEXT NOT NULL," + ContentData.TestEntry.COLUMN_SEX + " TEXT NOT NULL," + ContentData.TestEntry.COLUMN_AGE + " INTEGER NOT NULL );"; db.execSQL(SQL_CREATE_CONTACT_TABLE); db.execSQL("insert into people(name,sex,age)values('张三','女',18)"); db.execSQL("insert into people(name,sex,age)values('张四','男',20)"); db.execSQL("insert into people(name,sex,age)values('张五','女',19)"); db.execSQL("insert into people(name,sex,age)values('张六','男',22)"); &#125; //数据库升级的时候会调用的代码 @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) &#123; db.execSQL("DROP TABLE IF EXISTS " + ContentData.TestEntry.TABLE_NAME); onCreate(db); &#125;&#125; 3、创建自己的ProviderMyProvider继承ContentProvider。默认该Provider需要实现如下六个方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class MyProvider extends ContentProvider &#123; private DBOpenHelper dbOpenHelper;//声明数据库操作类 private final static int TEST = 100;//匹配码 //使用UriMatcher解析Uri，如果被匹配到，返回匹配码100 static UriMatcher buildUriMatcher() &#123; final UriMatcher matcher = new UriMatcher(UriMatcher.NO_MATCH); final String authority = ContentData.CONTENT_AUTHORITY; matcher.addURI(authority, ContentData.PATH_TEST, TEST); return matcher; &#125; @Override //该方法在ContentProvider被其它应用第一次访问它时才会被创建。 //同时我们操作数据库建表 public boolean onCreate() &#123; dbOpenHelper = new DBOpenHelper(getContext()); return true; &#125; @Override //该方法用于供外部应用往ContentProvider添加数据。 public Uri insert(Uri uri, ContentValues contentValues) &#123; //获得可写数据库 final SQLiteDatabase db = dbOpenHelper.getWritableDatabase(); Uri returnUri; long _id; switch ( buildUriMatcher().match(uri)) &#123; case TEST: //插入数据 _id = db.insert(ContentData.TestEntry.TABLE_NAME, null, values); if ( _id &gt; 0 ) returnUri = ContentData.TestEntry.buildUri(_id); else throw new android.database.SQLException("Failed to insert row into " + uri); break; default: throw new android.database.SQLException("Unknown uri: " + uri); &#125; return returnUri; &#125; @Override //该方法用于供外部应用从ContentProvider删除数据。 public int delete(Uri uri, String s, String[] strings) &#123; return 0; &#125; @Override //该方法用于供外部应用从ContentProvider中获取数据。 public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) &#123; //获得可读数据库 final SQLiteDatabase db = dbOpenHelper.getReadableDatabase(); //查到的结果是游标类型。 Cursor cursor = null; switch ( buildUriMatcher().match(uri)) &#123; case TEST: cursor = db.query(ContentData.TestEntry.TABLE_NAME, projection, selection, selectionArgs, sortOrder, null, null); break; &#125; return cursor; &#125; @Override //该方法用于供外部应用从ContentProvider更新数据。 public int update(Uri uri, ContentValues contentValues, String s, String[] strings) &#123; return 0; &#125; @Override public String getType(Uri uri) &#123; return null; &#125; //该方法用于返回当前Uri所代表数据的MIME类型。 //如果操作的数据属于集合类型，那么MIME类型字符串应以vnd.android.cursor.dir/开头， //例如：要得到所有person记录的Uri为content://com.xxx.MyApp.myprovider/person， //那么返回的MIME类型字符串应该为："vnd.android.cursor.dir/person"。 //如果要操作的数据属于非集合类型数据，那么MIME类型字符串应该以vnd.android.cursor.item/开头， //例如：得到id为10的person记录，Uri为content://com.xxx.MyApp.myprovider/person/10， //那么返回的MIME类型字符串为："vnd.android.cursor.item/person"。&#125; 【注意】以上代码并没有实现删除，更改功能 4、注册Provider1234//应用内访问&lt;provider android:authorities="com.xxx.MyApp.myprovider" android:name=".MyProvider" /&gt; 在注册的时候需要注意几个属性：1234android:exported 设置此provider是否可以被其他应用使用。android:readPermission 该provider的读权限的标识android:writePermission 该provider的写权限标识android:permission provider读写权限标识 如何让其他应用也可以访问此应用中的数据呢，我们需要这么注册123456&lt;provider android:authorities="com.xxx.MyApp.myprovider" android:name=".MyProvider" android:readPermission="com.xxx.READ" android:exported="true"&gt;&lt;/provider&gt; 并且要在注册文件中声明一个permission1&lt;permission android:name="com.bb.READ" android:protectionLevel="normal"/&gt; 【通过以上步骤，一个ContentProvider就造好了。】 ContentResolver使用ContentResolver调用ContentProvider去操作数据库数据 为什么我们不直接访问Provider。大家要知道一台手机中可不是只有一个Provider内容，它可能安装了很多含有Provider的应用，比如联系人应用，日历应用，字典应用等等。有如此多的Provider，如果你开发一款应用要使用其中多个，如果让你去了解每个ContentProvider的不同实现，岂不是要头都大了。所以Android为我们提供了ContentResolver来统一管理与不同ContentProvider间的操作。 实现过程1、当外部应用需要对ContentProvider中的数据进行添加、删除、修改和查询操作时，要获取ContentResolver 对象，可以使用Activity提供的getContentResolver()方法通过URI进行数据操作。1ContentResolver resolver = getContentResolver(); 2、ContentResolver 类提供了与ContentProvider类相同签名的四个方法：12345678public Uri insert(Uri uri, ContentValues values)：//该方法用于往ContentProvider添加数据。public int delete(Uri uri, String selection, String[] selectionArgs)：//该方法用于从ContentProvider删除数据。public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder)：//该方法用于从ContentProvider中获取数据。public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs)：//该方法用于更新ContentProvider中的数据。 使用ContentResolver对我们刚才造的ContentProvider中的数据进行添加、查询操作：123456789101112131415161718192021222324252627282930313233343536373839404142public class MainActivity extends AppCompatActivity &#123;//声明Uri常量private static final Uri CONTENT_URI = Uri.parse("content://com.xxx.MyApp.myprovider/people");TextView tv_id, tv_name, tv_sex, tv_age; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_id = (TextView) findViewById(R.id.tv_id); tv_name = (TextView) findViewById(R.id.tv_name); tv_sex = (TextView) findViewById(R.id.tv_sex); tv_age = (TextView) findViewById(R.id.tv_age); &#125; //query()为在xml组建中定义的OnClick public void query(View view) &#123; //通过getContentResolver().query调用ContentProvider实现对数据库的查询 tv_id.setText(""); tv_name.setText(""); tv_sex.setText(""); tv_age.setText(""); Cursor cursor = getContentResolver().query(CONTENT_URI, new String[]&#123;"_id", "name", "sex", "age" &#125;, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; tv_id.append("\n" + cursor.getString(cursor.getColumnIndex("_id"))); tv_name.append("\n" + cursor.getString(cursor.getColumnIndex("name"))); tv_sex.append("\n" + cursor.getString(cursor.getColumnIndex("sex"))); tv_age.append("\n" + cursor.getString(cursor.getColumnIndex("age"))); &#125; cursor.close(); &#125; &#125; public void add(View view) &#123; //通过getContentResolver().insert调用ContentProvider实现对数据库的增加 ContentValues values = new ContentValues(); values.put("name", "新来的"); values.put("sex", "男"); values.put("age", "28"); getContentResolver().insert(CONTENT_URI, values); query(findViewById(R.id.btn_query)); &#125; &#125; 【XML布局请下载Demo】3、在注册文件中记得增加权限读取权限12&lt;uses-permission android:name="com.xxx.READ"/&gt;&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" /&gt; 4、最终效果 【附录】相关Demo请先安装MyProvider，再安装MyResolver。MyProvider、MyResolver另赠送两个Demo，关于对系统Provider的调用（增、查联系人）增加联系人、查询联系人 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之Service]]></title>
      <url>%2F2016%2F06%2F26%2FService%2F</url>
      <content type="text"><![CDATA[基础回顾定义Service是可以在后台执行长时间（长生命周期）而又不与用户产生UI交互（没有用户界面）的操作。 注意事项1、只能在后台运行，即便用户切换了其他应用，启动的Service仍可在后台运行。2、可以和其他组件进行Service绑定并与之交互，甚至是跨进程通信（IPC）。3、不能运行在一个独立的进程当中，而是依赖与创建服务时所在的应用组件进程。4、服务不会自动开启线程，我们需要在服务的内部手动创建子线程，并在这里执行具体的任务。 应用场景举例音乐播放：播放多媒体的时候用户启动了其他Activity，此时要在后台继续播放。记录检测：比如检测SD卡上文件的变化；在后台记录你的地理信息位置的改变等。其他操作：网络请求、执行文件读写操作或者与 content provider交互。 类型本地服务依附在主进程上，在一定程度上节约了资源。本地服务因为是在同一进程，因此不需要IPC，也不需要AIDL。相应bindService会方便很多。缺点是主进程被kill后，服务变会终止。远程服务是独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被kill的是偶，该服务依然在运行。缺点是该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。本文第六部分将会简单的讲述这一进程间通信方式。对于startService来说，不管是本地服务还是远程服务，我们需要做的工作都一样简单。 生命周期从Service的启动到销毁，有两种路径（两种生命周期）：startService、bindService 使用方法1、通过startService方式定义一个Service（继承Service类）核心步骤和代码：创建一个类继承android.app.Service类，实现抽象方法onBind()，重写onCreate()、onStartCommand()、onDestry()。123456789101112131415161718192021222324252627public class MyService extends Service &#123; public static final String TAG = "MyService"; //创建服务时调用 @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate"); &#125; //服务执行的操作 @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; //销毁服务时调用 @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy"); &#125; //onBind()方法是Service中唯一的一个抽象方法，所以必须要在子类里实现。 //Service有两种启动方式：一种是startService()，另一种是bindService()。第二种启动方式才会用到onBind()方法。 //我们这先用第一种方式定义Service，所以暂时忽略onBind()方法。 @Override public IBinder onBind(Intent intent) &#123; return null; &#125; 在清单文件中配置Service,和Activity标签并列。1&lt;service android:name=".MyService"&gt;&lt;/service&gt; 请注意：为了保证应用的安全，请使用显式Intent启动或绑定一个Service，请不要在标签中配置intent-filter。在Activity组件中通过onCreate()声明“启动Service和停止Service”代码。12345678910111213141516171819202122232425262728public class MainActivity extends Activity implements OnClickListener &#123; private Button button1_start_service; private Button button2_stop_service; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1_start_service = (Button)findViewById(R.id.button1_start_service); button2_stop_service = (Button)findViewById(R.id.button2_stop_service); button1_start_service.setOnClickListener(this); button2_stop_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1_start_service: Intent startIntent = new Intent(this, MyService.class); startService(startIntent); break; case R.id.button2_stop_service: Intent stopIntent = new Intent(this, MyService.class); stopService(stopIntent); break; default: break; &#125; &#125; &#125; 启动和停止服务：startService()和stopService()方法都是定义在Context类当中的，所以可以在MainActivity中直接调用这两个方法。 运行上面的程序，点击button1_start_service按钮，通过Intent实现启动服务，后台打印日志如下：说明服务启动成功。那么如果我再连续点三次button1_start_service按钮，后台增加的日志如下：onCreate()方法只会在Service第一次被创建的时候调用，而onStartCommand()方法在每次启动服务的时候都会调用。我们还可以在正在“设置–应用—运行”中找到这个服务，如下图所示：如果我们再点击button2_stop_service按钮或者点击上图中的“Stop”，MyService服务就停止掉了（多次点击stop不会再产生日志）：通过startService方式（继承Service类）总结1、启动服务对象多次启动同时只会产生一个，onCreate()方法只会在Service第一次被创建的时候调用，多次点击启动会执行多次onStartCommand()方法，onDestroy()方法只会在Service第一次被停止的时候调用，多次点击停止不会报异常，也不再执行onDestroy()方法。2、一旦启动，Service将一直运行在后台（run in the background indefinitely）即便启动Service的组件已被destroy。3、停止一个started服务有两种方法：（1）在外部使用stopService()手动停止。（2）在服务内部(onStartCommand方法内部)使用stopSelf()方法，使服务执行完毕后自动停止。比如说，一个start的Service执行在后台下载或上传一个文件的操作，完成之后，Service应自己停止。4、onStartCommand方法的返回值：onStartCommand方法执行时，返回的是一个int型。这个整型可以有三个返回值：START_NOT_STICKY、START_STICKY、START_REDELIVER_INTENTSTART_NOT_STICKY:“非粘性的”。使用这个返回值时，如果在执行完onStartCommand方法后，服务被异常kill掉，系统不会自动重启该服务。START_STICKY：如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。START_REDELIVER_INTENT：重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。5、默认情况下，一个started的Service与启动他的组件在同一个线程中。上面的实例中，服务就是在主线程中运行的，如果是在服务中完成耗时操作的话，容易造成主线程阻塞。所以我们可以在服务中开启一个子线程来完成耗时操作。 2、通过startService方式定义一个Service（继承IntentService类）：为什么要通过继承IntentService来定义：我们在基础回顾的注意事项3、4中就已经了解，服务中的代码默认运行在主线程中，如果直接在服务里执行一些安卓不允许的耗时操作，容易造成主线程ANR（Application Not Responding）异常，所以就需要用到多线程的知识了，需要在服务的内部手动创建子线程。所以一个比较标准的服务可以这样写：123456789101112131415161718192021public class MyService extends Service &#123; public static final String TAG = "MyService"; //服务执行的操作 @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; new Thread(new Runnable() &#123; public void run() &#123; //在子线程中处理具体的逻辑 //在这里我们只做打印子线程id的操作 Log.i("MyService",Thread.currentThread().getId()+""); stopSelf(); //服务执行完毕后自动停止 &#125; &#125;).start(); return super.onStartCommand(intent, flags, startId); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO Auto-generated method stub return null; &#125; &#125; 在MainActivity中启动Service代码1234567891011121314151617181920212223242526272829public class MainActivity extends Activity implements OnClickListener &#123; private Button button1_start_service; private Button button2_stop_service; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1_start_service = (Button)findViewById(R.id.button1_start_service); button2_stop_service = (Button)findViewById(R.id.button2_stop_service); button1_start_service.setOnClickListener(this); button2_stop_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1_start_service: Log.i("Main",Thread.currentThread().getId()+""); Intent startIntent = new Intent(this, MyService.class); startService(startIntent); break; case R.id.button2_stop_service: Intent stopIntent = new Intent(this, MyService.class); stopService(stopIntent); break; default: break; &#125; &#125; &#125; 注册Service步骤不再赘述，当开启Service后打印日志如下：如果我们不手动开启线程，I/MyService: 177将会变成它依赖的主线程1，这就不能做耗时操作了。虽说上面的这种写法并不复杂，但总会有一些程序猿忘记开启线程，或者忘记调用stopSelf()方法。为了可以简单地创建一个可开启单独线程、会自动停止的服务，Android专门提供了一个IntentService类，这个类就很好的解决了上面所提到的两种尴尬。IntentService的作用：当我们需要这样一次性完成的任务时，就可以使用IntentService来完成。IntentService的用法： 1）新建一个MyIntentService类，继承自IntentService，并重写父类的onHandleIntent()方法，代码如下：1234567891011121314151617181920212223242526272829303132public class MyIntentService extends IntentService&#123; public MyIntentService() &#123; //第一步：重写父类的onHandleIntent()方法，这里首先要提供一个无参的构造方法， //并且必须在其内部调用父类的有参构造方法，这里我们手动给服务起个名字为：MyIntentService super("MyIntentService"); &#125; //第二步：重写父类的onHandleIntent()方法，该方法在会在一个单独的线程中执行， //来完成工作任务。任务结束后，该Service自动停止 @Override protected void onHandleIntent(Intent intent) &#123; for(int i = 0;i&lt;3;i++) &#123; //Service要执行的逻辑 //这里我们只打印当前线程的id Log.d("MyIntentService","IntentService线程的id是："+Thread.currentThread().getId()); try &#123; //线程睡眠一秒钟 Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d("MyIntentService","onDestroy"); &#125; &#125;```java 2）在清单文件中对服务进行注册服务：```xml&lt;service android:name=".MyIntentService"&gt;&lt;/service&gt; 3)在MainActivity里面加入启动IntentService的逻辑，核心代码如下：1234case R.id.button3_stop_intentservice: Log.d("MainActivity","主线程的id是："+Thread.currentThread().getId()); Intent intentService = new Intent(this,MyIntentService.class); startService(intentService); 运行程序，日志显示如下：通过startService方式（继承IntentService类） 总结1、启动一个IntentService和启动一个普通的Service，步骤是相似的。2、与直接继承Service不同在于：通过继承IntentService运行，自动开启了单独线程，而且完成任务后自动销毁了Service。【补充】Service和Thread的关系：不少Android初学者都可能会有这样的疑惑，Service和Thread到底有什么关系呢？什么时候应该用Service，什么时候又应该用Thread？答案可能会有点让你吃惊，因为Service和Thread之间没有任何关系！之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但是，Service其实是运行在主线程里的，一些比较耗时的操作需要开启单独线程。 3、通过bindService方式定义一个Service：（使用Bind Service完成Service和Activity之间的通信）：Bind Service的引入：有没有什么办法能让Service与组件的关联更多一些呢？比如说在Activity中指挥Service去干什么，Service就去干什么。当然可以，只需要让Activity和Service建立关联就好了。这时我们就可以通过bindService方式定义一个Service。Bind Service的实现原理： 应用程序组件(客户端）通过调用bindService()方法能够绑定服务，然后Android系统会调用服务的onBind()回调方法，则个方法会返回一个跟服务器端交互的Binder对象。bindService()方法立即返回，并且不给客户端返回IBinder对象。要接收IBinder对象，客户端必须创建一个ServiceConnection类的实例，并且把这个实例传递给bindService()方法。ServiceConnection对象包含了一个系统调用的传递IBinder对象的回调方法。Bind Service实现流程：1）一直有一个onBind()方法我们都没有使用到，这个方法其实就是用于和Activity建立关联的，修改MyService中的代码，如下所示：123456789101112131415161718192021222324252627282930313233343536373839public class MyBindService01 extends Service &#123; public static final String TAG = "MyBindService01"; private MyBinder mBinder = new MyBinder(); @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG, "onCreate"); &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; //在这里返回新建的MyBinder类 &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.d(TAG, "onUnbind"); return super.onUnbind(intent); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG, "onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG, "onDestroy"); &#125; //MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度 class MyBinder extends Binder &#123; public void startDownload() &#123; Log.d("TAG", "startDownload() executed"); // 执行具体的下载任务 &#125; public int getProgress()&#123; Log.d("TAG", "getProgress() executed"); return 0; &#125; &#125;&#125; 新建一个MyBinder类，继承Binder：让里面的方法执行下载任务，并获取下载进度。当然，这里只是两个模拟方法，并没有实现真正的功能，我们通过打印日志的形式来体现。接着创建MyBinder的实例，然后在onBind()方法里返回这个实例。返回这个mBinder，是一个IBinder类型，就可以把这个IBinder类型传递到MainActivity中，从而调用Service里面的方法。2）检查清单文件，是否已经对Service进行注册：1&lt;service android:name=".MyBindService01" &gt;&lt;/service&gt; 3）让我们修改MainActivity和MyBindService01之间建立关联1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public class MainActivity extends Activity implements OnClickListener &#123; private Button button1_bind_service; private Button button2_unbind_service; private MyBindService01.MyBinder myBinder; boolean mBound = false; //一开始，并没有和Service绑定.这个参数是用来显示绑定状态 //匿名内部类：服务连接对象 private ServiceConnection connection = new ServiceConnection() &#123; //当服务异常终止时会调用。注意，解除绑定服务时不会调用 @Override public void onServiceDisconnected(ComponentName name) &#123; mBound = false; //服务异常终止时，状态为未绑定 //解决了多次执行unbindService()方法引发的异常问题 &#125; //和服务绑定成功后，服务会回调该方法 @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; myBinder = (MyBindService01.MyBinder) service; //在Activity中调用Service里面的方法 myBinder.startDownload(); myBinder.getProgress(); mBound = true; //true说明是绑定状态 &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1_bind_service = (Button) findViewById(R.id.button1_bind_service); button2_unbind_service = (Button) findViewById(R.id.button2_unbind_service); button1_bind_service.setOnClickListener(this); button2_unbind_service.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.button1_bind_service: Intent bindIntent = new Intent(this, MyService.class); bindService(bindIntent, connection, BIND_AUTO_CREATE);//这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后会自动创建Service（即使之前没有创建//Service也没有关系），这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。 break; case R.id.button2_unbind_service: //如果和Service是绑定的状态，就解除绑定。 if(mBound)&#123; unbindService(connection); mBound=false; &#125; break; default: break; &#125; &#125;&#125; 说明：这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，如果当前Activity与服务连接成功后，服务会回调onServiceConnected()方法在onServiceConnected()方法中，我们又通过向下转型得到了MyBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。现在我们可以在Activity中根据具体的场景来调用MyBinder中的任何public方法，即实现了Activity指挥Service干什么Service就去干什么的功能。4）执行bindService()方法。5）解除Activity和Service之间的关联。执行unbindService()。通过bindService方式 总结1、onCreate()、onBind()方法只会在Service第一次被创建的时候调用，多次点击绑定启动不会执行任何方法，onUnbind()、onDestroy()方法会在调用者执行unbindService()方法时执行或者Activity退出时自动执行。2、如果我们既通过startService()开启Service，又用通过bindService开启，必要unbindService()和stopService()都执行一次（没有先后顺序），Service才会被销毁。3、如果多次执行unbinsService()方法，程序会异常退出，我们需要在代码中加一个判断是否绑定的标记mBound来解决此问题，上面代码中有说明。1234567case R.id.button4_unbind_service://如果和Service是绑定的状态，就解除绑定。if(mBound)&#123; unbindService(connection); mBound=false;&#125;break; 4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了）。5、只有Activity、Service、Content Provider能够绑定服务；BroadcastReceiver广播接收器不能绑定服务。 4、bindService和startService混合使用：如果先startService,再bindService:在bind的Activity退出的时候,Service会执行unBind方法而不执行其onDestory方法,因为有startService方法调用过,所以Activity与Service解除绑定后会有一个与调用者没有关连的Service存在。如果先bindService,再startService,再调用Context.stopServiceService的onDestory方法不会立刻执行,因为有一个与Service绑定的Activity,但是在Activity退出的时候,会执行其(Service的)onDestory方法,如果要立刻执行stopService,就得先解除绑定。如果先是bind了，那么start的时候就直接运行Service的onStartCommand()方法，如果先是start，那么bind的时候就直接运行onBind()方法。当一个服务没被onDestory()销毁之前，只有第一个启动它的客户端能调用它的onBind()和onUnbind()。 startService、bindService区别大总结1、生命周期不同。（详见二）2、多次启动，前者会多次执行onStartCommand()方法，后者什么都不执行。多次停止，前者只会执行一次onDestroy()方法，后者报异常信息。3、当启动Service的组件已被Destroy的时候，前者不停止，后者会停止。4、前者停止直接执行onDestroy()方法（Service中的），后者则先解除绑onUnbind()定再执行onDestroy()方法（Service中的）。5、当手机屏幕在“横”“竖”变换时，前者创建的Service不会停止，后者会随着Activity的重建而停止。6、后者的onBind回调方法将返回给客户端一个IBinder接口实例，IBinder允许客户端回调服务的方法，比如得到Service运行的状态或其他操作。而这些操作前者启动的Service是没有的。 在AndroidManifest.xml里Service元素常见选项1234567android:name -- 服务类名android:label -- 服务的名字，如果此项不设置，那么默认显示的服务名则为类名android:icon -- 服务的图标android:permission -- 申明此服务的权限，这意味着只有提供了该权限的应用才能控制或连接此服务android:process -- 表示该服务是否运行在另外一个进程，如果设置了此项，那么将会在包名后面加上这段字符串表示另一进程的名字android:enabled --表示是否能被系统实例化，为true表示可以，为false表示不可以，默认为trueandroid:exported -- 表示该服务是否能够被其他应用程序所控制或连接，不设置默认此项为 false 扩展：进程间通信说明调用者和Service如果不在一个进程内, 就需要使用android中的远程Service调用机制.android使用AIDL定义进程间的通信接口. AIDL的语法与java接口类似, 需要注意以下几点: AIDL文件必须以.aidl作为后缀名. AIDL接口中用到的数据类型, 除了基本类型, String, List, Map, CharSequence之外, 其他类型都需要导包, 即使两种在同一个包内. List和Map中的元素类型必须是AIDL支持的类型. 接口名需要和文件名相同. 方法的参数或返回值是自定义类型时, 该自定义的类型必须实现了Parcelable接口. 所有非java基本类型参数都需要加上in, out, inout标记, 以表明参数是输入参数, 输出参数, 还是输入输出参数. 接口和方法前不能使用访问修饰符和static, final等修饰. 远程通信扩展小例子远程service要在service中注册信息中加上 android:process=”:remote”12&lt;service android:name=".AIDLService" android:process=":remote"&gt;&lt;/service&gt; 远程service有什么用呢？远程service的作用只是重新建立一个新进程执行，可以独立出去。其他app可以调用这个service。因为是一个新的进程，所以也不能用bindService来建立关联了。可以用新的方式来建立关系就是下面要讲的aidl技术。AIDL实现1.首先我建立2个app工程，通过aidl实现一个app调用另一个app的service目录结构如下：service提供端app利用aidl调用service的app2.在两个app中都建立一个文件 IPerson.aidl注意 包名 要相同IPerson.aidl只是一个接口文件,用来aidl交互的，建立好之后在Studio中点Build–&gt;Rebuild会自动创建需要的java文件。IPerson.aidl代码1234package mangues.com.aidl;interface IPerson &#123; String greet(String someone);&#125; 3.在aidl_service 中建立AIDLService这个IPerson.Stub 就是通过IPerson.aidl 自动生成的binder 文件，你实现下，然后在onBind()中 return出去就好了，就和Android Service实现和activity交互一样。代码：1234567891011121314151617181920212223242526272829303132333435public class AIDLService extends Service &#123; private static final String TAG = "AIDLService"; IPerson.Stub stub = new IPerson.Stub() &#123; @Override public String greet(String someone) throws RemoteException &#123; Log.i(TAG, "greet() called"); return "hello, " + someone; &#125; &#125;; @Override public void onCreate() &#123; super.onCreate(); Log.i(TAG, "onCreate() called"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.i(TAG, "onBind() onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; @Override public IBinder onBind(Intent intent) &#123; Log.i(TAG, "onBind() called"); return stub; &#125; @Override public boolean onUnbind(Intent intent) &#123; Log.i(TAG, "onUnbind() called"); return true; &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.i(TAG, "onDestroy() called"); &#125;&#125; 4.aidl_service MainActivity 中启动这个service简单点就不写关闭什么的了；1234567@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent startIntent = new Intent(this, AIDLService.class); startService(startIntent); &#125; 在AndroidManifest.xml注册1234567&lt;service android:name=".AIDLService" android:process=":remote"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.AIDLService" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/service&gt; 作用就是把这个service暴露出去，让别的APP可以利用android.intent.action.AIDLService 字段隐形绑定这个service，获取数据。5.aidl_client 中绑定aidl_service service 获取数据代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051 public class MainActivity extends AppCompatActivity &#123; private IPerson person; private ServiceConnection conn = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.i("ServiceConnection", "onServiceConnected() called"); person = IPerson.Stub.asInterface(service); String retVal = null; try &#123; retVal = person.greet("scott"); &#125; catch (RemoteException e) &#123; e.printStackTrace(); &#125; Toast.makeText(MainActivity.this, retVal, Toast.LENGTH_SHORT).show(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; //This is called when the connection with the service has been unexpectedly disconnected, //that is, its process crashed. Because it is running in our same process, we should never see this happen. Log.i("ServiceConnection", "onServiceDisconnected() called"); &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent mIntent = new Intent(); mIntent.setAction("android.intent.action.AIDLService"); Intent eintent = new Intent(getExplicitIntent(this,mIntent)); bindService(eintent, conn, Context.BIND_AUTO_CREATE); &#125; public static Intent getExplicitIntent(Context context, Intent implicitIntent) &#123; // Retrieve all services that can match the given intent PackageManager pm = context.getPackageManager(); List&lt;ResolveInfo&gt; resolveInfo = pm.queryIntentServices(implicitIntent, 0); // Make sure only one match was found if (resolveInfo == null || resolveInfo.size() != 1) &#123; return null; &#125; // Get component info and create ComponentName ResolveInfo serviceInfo = resolveInfo.get(0); String packageName = serviceInfo.serviceInfo.packageName; String className = serviceInfo.serviceInfo.name; ComponentName component = new ComponentName(packageName, className); // Create a new intent. Use the old one for extras and such reuse Intent explicitIntent = new Intent(implicitIntent); // Set the component to be explicit explicitIntent.setComponent(component); return explicitIntent; &#125;&#125; 和Android Service 中学习的调用MyBinder获取service中数据一样，这边只是吧MyBinder 改成了aidl定义的接口IPerson 本质上还是一个Binder。因为android 5.0 不允许隐形启用service 所有用getExplicitIntent转一下 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之Broadcast Receiver]]></title>
      <url>%2F2016%2F05%2F02%2FReceiver%2F</url>
      <content type="text"><![CDATA[前言基础知识1.Android广播分为两个方面：广播发送者和广播接收者，通常情况下，BroadcastReceiver指的就是广播接收者（广播接收器）。广播可以跨进程甚至跨App直接通信。2.你的APP可以接收广播(如当电话呼入时，或者数据网络可用时)进行接收并做出响应。3.广播接收器没有用户界面。然而，它们可以启动一个Activity或Service服务来响应它们收到的信息，或者用NotificationManager 来通知用户。通知可以用很多种方式来吸引用户的注意力──闪动背灯、震动、播放声音等。一般来说是在状态栏上放一个持久的图标，用户可以打开它并获取消息。 实现流程Android中的广播将广播的发送者和接受者极大程度上解耦，使得系统能够方便集成，更易扩展。具体实现流程要点粗略概括如下：1.广播接收者BroadcastReceiver通过Binder机制向AMS(Activity Manager Service)进行注册；2.广播发送者通过Binder机制向AMS发送广播；3.AMS查找符合相应条件（IntentFilter/Permission等）的BroadcastReceiver，将广播发送到BroadcastReceiver（一般情况下是Activity）相应的消息循环队列中；4.消息循环执行拿到此广播，回调BroadcastReceiver中的onReceive()方法。 广播定义及类型广播定义Android系统在运行的过程中，会产生很多系统广播，比如开机、电量改变、收发短信、拨打电话、屏幕解锁。当然我们也可以发送自定义普通或有序广播。 广播类型1.普通广播：通过Context.sendBroadcast(Intent intent)发送，可以在同一时刻（逻辑上）被所有广播接收者无需等待的接收到。优点：消息传递的效率比较高。缺点：1.接收者不能修改该广播。2.无法终止广播Intent的传播，即无法阻止其他接收者的接收动作。123Intent intent = new Intent("One");intent.putExtra("msg", "这是一条普通广播");sendBroadcast(intent); 2.有序广播：通过Context.sendOrderedBroadcast(intent, receiverPermission)发送，是按照接收者声明的优先级别，被接收者依次接收广播。优点：1、广播可以通过接收者调用abortBroadcast()方法截断广播（被截断的广播不能再继续传递该广播）。2、接收者能修改处理结果（比如通过传递Bundle）传递给下一个接收者（一般情况下，不建议对有序广播进行此类操作，尤其是针对系统中的有序广播）。缺点：消息传递的效率比普通广播低。123Intent intent2 = new Intent("Two");intent2.putExtra("msg", "这是一条有序广播");sendOrderedBroadcast(intent2, null); 3.系统广播：只要涉及到手机的基本操作，基本上都会发出相应的系统广播。如：开机启动，网络状态改变，拍照，屏幕关闭与开启，点亮不足等等。每个系统广播都具有特定的intent-filter，其中主要包括具体的action，系统广播发出后，将被相应的BroadcastReceiver接收。系统广播在系统内部当特定事件发生时，由系统自动发出。详见文章末尾附录4.异步广播：通过mContext.sendStickyBroadcast(intent)发送，此广播会一直滞留（等待），以便有人注册这则广播消息后能尽快的收到这条广播。其他功能与sendBroadcast相同。但是使用sendStickyBroadcast 发送广播需要获得BROADCAST_STICKY permission，如果没有这个permission则会抛出异常。优点：广播先发送，接收者后注册依然能收到广播。123Intent intent3 = new Intent("Three");intent3.putExtra("msg", "这是一条异步广播");sendStickyBroadcast(intent3); 广播接收者广播接收者定义BroadcastReceiver也就是“广播接收者”的意思，顾名思义，它就是用来接收来自系统和应用中的广播，且可以做出相关操作。 实现方法第一步：定义广播接收者，继承BroadcastReceiver，并重写onReceive()方法。1234567public class MyReceiver01 extends BroadcastReceiver &#123; @Override public void onReceive(Contextcontext, Intentintent) &#123; //abortBroadcast();//接到的广播为有序的广播则可截断 String s = intent.getStringExtra("msg"); System.out.println("MyReceiver01收到消息："+s); &#125; &#125; 【关于接收的广播类型的说明】 接收的广播为普通广播：1、不可以在onReceive里面截断广播，否则会打印异常。2、不可以处理广播。 接收的广播为有序广播：1、可以在onReceive里面通过abortBroadcast()截断广播，使广播不再传播。2、可以在onReceive里面接收广播Intent携带的数据（String字符串、Bundle对象、或者实现Serializable接口、Parcelable接口的Object对象）。3、可向低优先级接收者传递新的数据，如下代码123456789101112//我是高优先级接收者@Override public void onReceive(Contextcontext, Intentintent) &#123; Bundle bundle = new Bundle(); bundle.putString("next_receiver", "下一个广播接收者"); setResultExtras(bundle); &#125; //我是低优先级接收者@Override public void onReceive(Context context, Intent intent) &#123; Bundle bundle = getResultExtras(true); String content = bundle.getString("next_receiver"); &#125; 第二步：注册感兴趣的广播Intent，注册方法有两种：1、动态注册（在onCreate代码中进行注册）。1234IntentFilter filter = new IntentFilter("感兴趣的广播名、例如上面发送的有序广播：Two"); MyReceiver01 receiver = new MyReceiver01(); intentfilter.setPriority(200);//设置优先级registerReceiver(receiver, filter); 2、静态注册（在AndroidManifest.xml配置文件中注册）。123456&lt;!--prioritys设置优先级--&gt;&lt;receiver android:name=". MyReceiver01"&gt; &lt;intent-filter android:priority="100"&gt; &lt;action android:name="感兴趣的广播名、例如上面发送的有序广播：Two"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 【关于优先级别的说明】 设置方法（如上面注册代码所示）：1.静态设置：声明在静态注册的广播接收者的intent-filter元素的android:priority属性中。2.动态设置：调用IntentFilter对象的setPriority()进行声明。 特别说明1.静态注册时设置优先级。数越大优先级别越高,取值范围:-1000到1000。就会先接受到消息。2.动态注册优先级高于任何静态注册。3.如果动态注册和静态注册都有注册，则会执行两次onReceive。4.同级别的接收顺序是随机的。【关于动、静态注册方式特别说明】 静态注册广播：又叫常驻型广播，当你的应用程序关闭了，如果有广播信息来，你写的广播接收器同样的能接受到，他的注册方式就是在你的应用程序中的AndroidManifast.xml进行订阅的。 动态注册广播：又叫非常驻型广播，当应用程序结束了，广播自然就没有了，比如你在Activity中的onCreate或者onResume中订阅广播，同时你必须在onDestory或者onPause中取消广播订阅。不然会报异常，这样你的广播接收器就一个非常驻型的了。 123456789101112protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //动态注册BC2 接收者 IntentFilter intentfilter = new IntentFilter("One"); BC2 bc2 = new BC2(); registerReceiver(bc2, intentfilter); &#125;//必须在onDestory取消广播订阅protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(bc2); &#125; 注意：1、动态注册的时候使用的是隐式Intent方式，所以在发送广播的时候需要使用隐式Intent去发送，不然是广播接收者是接收不到广播。2、静态注册的时候，因为在AndroidMainfest.xml中订阅的，所以在发送广播的时候使用显示Intent和隐式Intent都可以所以以防万一，我们一般都采用隐式Intent去发送广播。3、对于静态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是ReceiverRestrictedContext；4、对于动态注册的ContextReceiver，回调onReceive(context, intent)中的context具体指的是Activity Context； 生命周期。它并不像 Activity 一样复杂，运行原理很简单如下图 广播接收者生命周期只有十秒左右，如果在 onReceive() 内做超过十秒内的事情，就会报ANR(Application No Response) 程序无响应的错误信息，如果需要完成一项比较耗时的工作 , 应该通过发送 Intent 给 Service， 由Service 来完成 。 这里不能使用子线程来解决 , 因为 BroadcastReceiver 的生命周期很短 , 子线程可能还没有结束BroadcastReceiver 就先结束了 .BroadcastReceiver 一旦结束 , 此时 BroadcastReceiver 的所在进程很容易在系统需要内存时被优先杀死 , 因为它属于空进程 ( 没有任何活动组件的进程 ). 如果它的宿主进程被杀死 , 那么正在工作的子线程也会被杀死 . 所以采用子线程来解决是不可靠的 广播实例为了帮助大家更好的理解，以下写了一个接收系统系统电量广播并处理的小例子。123456789101112131415161718192021222324//第一步，定义广播接收者public class BatteryChangedReceiver extends BroadcastReceiver &#123; private static final String TAG = "BatteryChangedReceiver"; @Override public void onReceive(Context context, Intent intent) &#123; int currLevel = intent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0); //当前电量 int total = intent.getIntExtra(BatteryManager.EXTRA_SCALE, 1); //总电量 int percent = currLevel * 100 / total; Log.i(TAG, "battery: " + percent + "%"); &#125; &#125;//第二步，注册广播接收者protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //动态注册电量广播接收者 IntentFilter intentfilter = new IntentFilter(Intent.ACTION_BATTERY_CHANGED;); BatteryChangedReceiver batteryChangedReceiver = new BatteryChangedReceiver(); registerReceiver(bc2, intentfilter); &#125;//必须在onDestory取消广播订阅protected void onDestroy() &#123; super.onDestroy(); unregisterReceiver(batteryChangedReceiver); &#125; 【附录】 常见系统广播 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176//关闭或打开飞行模式时的广播Intent.ACTION_AIRPLANE_M;//充电状态，或者电池的电量发生变化;//电池的充电状态、电荷级别改变，不能通过组建声;Intent.ACTION_BATTERY_CH;//表示电池电量低Intent.ACTION_BATTERY_LO;//表示电池电量充足Intent.ACTION_BATTERY_OK;//关闭或打开飞行模式时的广播Intent.ACTION_AIRPLANE_MODE_CHANGED;//充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册Intent.ACTION_BATTERY_CHANGED;//表示电池电量低Intent.ACTION_BATTERY_LOW;//表示电池电量充足，即从电池电量低变化到饱满时会发出广播Intent.ACTION_BATTERY_OKAY;//在系统启动完成后，这个动作被广播一次（只有一次）。Intent.ACTION_BOOT_COMPLETED;//按下照相时的拍照按键(硬件按键)时发出的广播Intent.ACTION_CAMERA_BUTTON;//当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息Intent.ACTION_CLOSE_SYSTEM_DIALOGS;//设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java)Intent.ACTION_CONFIGURATION_CHANGED;//设备日期发生改变时会发出此广播Intent.ACTION_DATE_CHANGED;//设备内存不足时发出的广播,此广播只能由系统使用，其它APP不可用Intent.ACTION_DEVICE_STORAGE_LOW;//设备内存从不足到充足时发出的广播,此广播只能由系统使用，其它APP不可用Intent.ACTION_DEVICE_STORAGE_OK;//发出此广播的地方frameworks\base\services\java\com\android\server\DockObserver.javaIntent.ACTION_DOCK_EVENT;//移动APP完成之后，发出的广播(移动是指:APP2SD)Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE;//正在移动APP时，发出的广播(移动是指:APP2SD)Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;//Gtalk已建立连接时发出的广播Intent.ACTION_GTALK_SERVICE_CONNECTED;//Gtalk已断开连接时发出的广播Intent.ACTION_GTALK_SERVICE_DISCONNECTED;//在耳机口上插入耳机时发出的广播Intent.ACTION_HEADSET_PLUG;//改变输入法时发出的广播Intent.ACTION_INPUT_METHOD_CHANGED;//设备当前区域设置已更改时发出的广播Intent.ACTION_LOCALE_CHANGED;//表示用户和包管理所承认的低内存状态通知应该开始。Intent.ACTION_MANAGE_PACKAGE_STORAGE;//未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播 ,扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)Intent.ACTION_MEDIA_BAD_REMOVAL;//按下"Media Button" 按键时发出的广播,假如有"Media Button" 按键的话(硬件按键)Intent.ACTION_MEDIA_BUTTON;//插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播?Intent.ACTION_MEDIA_CHECKING;//已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播, 用户想要移除扩展介质（拔掉扩展卡）。Intent.ACTION_MEDIA_EJECT;//插入SD卡并且已正确安装（识别）时发出的广播, 扩展介质被插入，而且已经被挂载。Intent.ACTION_MEDIA_MOUNTED;//拓展介质存在，但使用不兼容FS（或为空）的路径安装点检查介质包含在Intent.mData领域。Intent.ACTION_MEDIA_NOFS;//外部储存设备已被移除，不管有没正确卸载,都会发出此广播， 扩展介质被移除。Intent.ACTION_MEDIA_REMOVED;//广播：已经扫描完介质的一个目录Intent.ACTION_MEDIA_SCANNER_FINISHED;//请求媒体扫描仪扫描文件并将其添加到媒体数据库。Intent.ACTION_MEDIA_SCANNER_SCAN_FILE;//广播：开始扫描介质的一个目录Intent.ACTION_MEDIA_SCANNER_STARTED;// 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。Intent.ACTION_MEDIA_SHARED;Intent.ACTION_MEDIA_UNMOUNTABLE;//// 广播：扩展介质存在，但是还没有被挂载 (mount)Intent.ACTION_MEDIA_UNMOUNTEDIntent.ACTION_NEW_OUTGOING_CALL;//成功的安装APK之后//广播：设备上新安装了一个应用程序包。//一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播）Intent.ACTION_PACKAGE_ADDED;//一个已存在的应用程序包已经改变，包括包名Intent.ACTION_PACKAGE_CHANGED;//清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?)//用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播）Intent.ACTION_PACKAGE_DATA_CLEARED;//触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？Intent.ACTION_PACKAGE_INSTALL;//成功的删除某个APK之后发出的广播, 一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播）Intent.ACTION_PACKAGE_REMOVED;//替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？）Intent.ACTION_PACKAGE_REPLACED;//用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播）Intent.ACTION_PACKAGE_RESTARTED;//插上外部电源时发出的广播Intent.ACTION_POWER_CONNECTED;//已断开外部电源连接时发出的广播Intent.ACTION_POWER_DISCONNECTED;Intent.ACTION_PROVIDER_CHANGED;////重启设备时的广播Intent.ACTION_REBOOT;//屏幕被关闭之后的广播Intent.ACTION_SCREEN_OFF;//屏幕被打开之后的广播Intent.ACTION_SCREEN_ON;//关闭系统时发出的广播Intent.ACTION_SHUTDOWN;//时区发生改变时发出的广播Intent.ACTION_TIMEZONE_CHANGED;//时间被设置时发出的广播Intent.ACTION_TIME_CHANGED;//广播：当前时间已经变化（正常的时间流逝）， 当前时间改变，每分钟都发送，不能通过组件声明来接收，只有通过Context.registerReceiver()方法来注册Intent.ACTION_TIME_TICK;//一个用户ID已经从系统中移除发出的广播Intent.ACTION_UID_REMOVED;//设备已进入USB大容量储存状态时发出的广播？Intent.ACTION_UMS_CONNECTED;//设备已从USB大容量储存状态转为正常状态时发出的广播？Intent.ACTION_UMS_DISCONNECTED;Intent.ACTION_USER_PRESENT;////设备墙纸已改变时发出的广播Intent.ACTION_WALLPAPER_CHANGED; 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Android实习生 —— 四大组件之Activity]]></title>
      <url>%2F2016%2F04%2F24%2FActivity%2F</url>
      <content type="text"><![CDATA[基础知识回顾定义及功能 一个Activity是一个应用程序组件，提供一个屏幕，用户可以用来交互为了完成某项任务，例如拨号、拍照、发送email、看地图。每一个activity被给予一个窗口，在上面可以绘制用户接口。窗口通常充满屏幕，但也可以小于屏幕而浮于其它窗口之上。 启动和栈 一个应用程序通常由多个activities组成，他们通常是松耦合关系。通常，一个应用程序中的activity被指定为”main”activity，当第一次启动应用程序的时候呈现给用户的那个activity。每一个activity然后可以启动另一个activity为了完成不同的动作。每一次一个activity启动，前一个activity就停止了，但是系统保留activity在一个栈上（“back stack”）。当一个新activity启动，它被推送到栈顶，取得用户焦点。Back Stack符合简单“后进先出”原则，所以，当用户完成当前activity然后点击back按钮，它被弹出栈（并且被摧毁），然后之前的activity恢复。 基本用法 基本用法：Activity的本质是一个Java类，如：由我们创建工程生成的MainActivity；一般的每个Activity都会存在一个与它匹配的布局文件（xml文件），由它来写入我们需要Activity展示的各种控件和布局。有了布局文件之后，就需要在类里通过OnCreate方法的setContentView方法调用文件资源ID来初始化UI界面和显示。 创建和注册 每个需要显示的Activity都需要我们在工程包下的AndroidMainifest.xml文件进行注册！（注意：程序每次打开时显示的Activity我们称为主界面，它的注册和其他Activity注册有区别）12345678&lt;!--主Activity--&gt;&lt;activity Android:name=”.MainActivity”&gt; &lt;intent-filter&gt; &lt;action android:name=”android.intent.action.MAIN”/&gt; &lt;category android:name=”android.intent.category.LAUNCHER”/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 主界面显示的Activity加入了标签和内部的两句声明，这也是必须的。 元素指定这是一个”main”入口点对这个应用程序。元素指定，这个activity应该被列入系统应用程序列表中（为了允许用户启动这个activity）。此外如果你的应用程序里没有声明任何主活动，它也是可以安装的，只是你无法在启动器中看见或打开，这种程序一般作为第三方服务供其他应用在内部进行调用，如支付宝的快捷支付应用。 生命周期四种状态 运行状态：当Activity位于栈顶时，此时正好处于屏幕最前方。暂停状态：当Activity失去了焦点但仍然对用于可见（如栈顶的Activity是透明的或者栈顶Activity并不是铺满整个手机屏幕）。停止状态：当Activity被其他Activity完全遮挡，此时此Activity对用户不可见。销毁状态：当Activity由于人为或系统原因（如低内存等）被销毁。 七个回调方法1.onCreate：活动第一次创建被调用。2.onStart：活动由不可见变为可见的时候调用。3.onResume：活动处于与用户交互状态时候调用。4.onPause：活动失去焦点时被调用。5.onStop：活动完全不可见的时候调用（如果新活动是一个对话框式活着半透明的活动，onPause会执行，而onStop不会执行）。6.onDestroy：在活动被销毁之前调用。7.onRestart：由停止状态变为运行状态之前调用。 生命周期图 详解 在实际应用场景中，假设A Activity位于栈顶，此时用户操作，从A Activity跳转到B Activity。那么对AB来说，具体会回调哪些生命周期中的方法呢？回调方法的具体回调顺序又是怎么样的呢？ 开始时，A被实例化，执行的回调有A:onCreate -&gt; A:onStart -&gt; A:onResume。 当用户点击A中按钮来到B时，假设B全部遮挡住了A，将依次执行A:onPause -&gt; B:onCreate -&gt; B:onStart -&gt; B:onResume -&gt; A:onStop。 此时如果点击Back键，将依次执行B:onPause -&gt; A:onRestart -&gt; A:onStart -&gt; A:onResume -&gt; B:onStop -&gt; B:onDestroy。 至此，Activity栈中只有A。在Android中，有两个按键在影响Activity生命周期这块需要格外区分下，即Back键和Home键。我们先直接看下实验结果： 此时如果按下Back键，系统返回到桌面，并依次执行A:onPause -&gt; A:onStop -&gt; A:onDestroy。 此时如果按下Home键（非长按），系统返回到桌面，并依次执行A:onPause -&gt; A:onStop。由此可见，Back键和Home键主要区别在于是否会执行onDestroy。 扩展 不少应用程序都是采取如Home键的效果，当点击了Back键，系统返回到桌面，然后点击应用程序图标，直接回到之前的Activity界面，这种效果是怎么实现的呢？ 通过重写按下Back键的回调函数，转成Home键的效果即可。123456@Overridepublic void onBackPressed() &#123; Intent home = new Intent(Intent.ACTION_MAIN); home.addCategory(Intent.CATEGORY_HOME); startActivity(home);&#125; 当然，此种方式通过Home键效果强行影响到Back键对Activity生命周期的影响。注意，此方法只是针对按Back键需要退回到桌面时的Activity且达到Home效果才重写。或者，为达到此类效果，Activity实际上提供了直接的方法。activity.moveTaskToBack(true);moveTaskToBack()此方法直接将当前Activity所在的Task移到后台，同时保留activity顺序和状态。 Activity跳转startActivity()。 Intent的两种用法：显示Intent和隐式Intent。 （1）显示Intent一般使用方法：123Intent intent=newIntent(FirstActivity.this,SecondActivity.class); startActivity(intent); //简单的两行就能实现第一个活动跳转到第二个活动界面。 （2）隐式Intent一般使用方法：123456789&lt;!--首先需要在注册第二个活动时加入标签--&gt;&lt;!-- 必须指定CATEGORY_DEFAULT，只有这样startActivity(intent)才能找到 --&gt; &lt;!--注意 Intent Filter顾名思义就是Intent的过滤器，组件通过定义Intent Filter可以决定哪些隐式 --&gt; &lt;activity android:name=”.SecondAcivity”&gt; &lt;intent-filter&gt; &lt;action android:name=”包名.ACTION_START”/&gt; &lt;category android:name=”android.intent.category.DEFAULT”/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 这样我们就可以用声明的标签来启动隐式Intent12Intent intent=new Intent(“包名.ACTION_START”); startActivity(intent); （3）两者的使用区别 显式意图一般在应用的内部使用，因为在应用内部已经知道了组件的名称，直接调用就可以了。当一个应用要激活另一个应用中的Activity时，只能使用隐式意图，根据Activity配置的意图过滤器建一个意图，让意图中的各项参数的值都跟过滤器匹配，这样就可以激活其他应用中的Activity。所以，隐式意图是在应用与应用之间使用的。 系统意图 Intent可以指定你希望启动或描述完成的动作（操作系统会为你选择合适的Activity，可能来自定不同的应用程序）。 你的应用程序或许希望执行一些动作，例如发送一份邮件、文件消息或者状态更新，使用你的Activity的数据。在这种情况下，你的应用程序或许没有它自己的Activity来完成这个动作，因此你可以促使设备上其它应用程序提供的Activity来完成你的动作。这才是Intent真正有价值的地方－－你可以创建一个Intent描述一个你希望执行的动作，然后系统启动一个合适的activity从其它应用程序。如果有多种Activities可以处理这个Intent，那么 用户可以选择哪一个来执行。例如，如果你希望允许用户发送邮件，你可以创建下面的Intent:123Intent intent= new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL,""); startActivity(intent); （常用意图见文章末尾附录。） 数据通信 一个Intent可以传输小量数据被启动的activity使用。 在启动活动时，Intent中提供了一系列putExtra()方法的重载，可以将我们需要传递的数据暂存在Intent中，在打开另一个活动时，从Intent中取出即可。 具体例子： （1）比如我们想要传递一个String字符串123456String data=”Hello world!”; Intent intent=newIntent(FirstActivity.this,SecondActivity.class); Intent.putExtra(“extra_data”,data);//extra_data是一个标签，data是传入的数据。 //相当于Intent对象具有Map键值对功能。startActivity(intent); 然后在SecondActivity的Oncreate方法里取出Intent存入的数据1234Intent intent=getIntent(); String data=intent.getStringExtra(“extra_data”);//用String接收带extra_data标签的数据 Log.d(“SecondActivity”,data);//打印出data （2）新建一个Bundle对象 ，想该对象中加入键值对，然后将该对象加入Intent中12345678Intent intent=new Intent();Bundle bundle = new Bundle(); bundle.putString("first", "zhang"); bundle.putInt("age", 20); intent.putExtras(bundle); intent.setClass(ActivityMain.this, SecondActivity.class);intent.putExtras(bundle);startActivity(intent); 然后在第二个Activity中接收 1234 Bundle bundle = new Bundle(); bundle = this.getIntent().getExtras();String a = bundle.getString("first");int b = Integer.parseInt(bundle.getString("age")); （3）Intent传递Object对象 Android中Intent传递类对象提供了两种方式一种是 通过实现Serializable接口传递对象，一种是通过实现Parcelable接口传递对象。要求被传递的对象必须实现上述2种接口中的一种才能通过Intent直接传递。Intent中传递这2种对象的方法：12Bundle.putSerializable(Key,Object); //实现Serializable接口的对象Bundle.putParcelable(Key, Object); //实现Parcelable接口的对象 以下以最常用的Serializable方式为例 ： 假设由登录界面（Login）跳转到主界面（MainActivity）传递的对象为登录的用户信息 User类 首先创建一个序列化类：User 123456789101112131415161718192021222324252627282930 import java.io.Serializable; public class User implements Serializable &#123; private int ID; private String UserName; private String PWD; public final void setID(int value) &#123; ID = value; &#125; public final int getID() &#123; return ID; &#125; public final void setUserName(String value) &#123; UserName = value; &#125; public final String getUserName() &#123; return UserName; &#125; public final void setPWD(String value) &#123; PWD = value; &#125; public final String getPWD() &#123; return PWD; &#125; &#125; MainActivity传递内容123456Intent intent = new Intent();intent.setClass(MainActivity.this, SecondActivity.class);Bundle bundle = new Bundle();bundle.putSerializable("user", user);intent.putExtras(bundle);this.startActivity(intent); SecondActivity接收12Intent intent = this.getIntent(); user=(User)intent.getSerializableExtra("user"); 以上就可以实现对象的传递。补充：如果传递的是List,可以把list强转成Serializable类型,而且object类型也必须实现了Serializable接口 1Intent.putExtras(key, (Serializable)list) 接收1(List&lt;YourObject&gt;)getIntent().getSerializable(key) 【补充】 parcelable和Serializable的区别又是什么呢？ Serializable的作用是保存对象的属性到本地文件，数据库，网络流等方便数据传输，也可程序之间传递。 **parcelable**的设计的目的是为了解决Serializable效率不高的问题，内存开销小，所以在内存间传递数据的方式用parcelable，缺点是不能持久化。 startActivityForResult() Activity退出时返回结果至前一个Activity1234// 1.通过startActivityForResult方式启动一个新Activity Intent intent=newIntent(FirstActivity,this,SecondActivity.class); startActivityForResult(intent, 200); //参数为intent对象， requestCode请求码 1234567// 2.新Activity设定setResult方法，通过该方法可以传递responseCode 和 Intent对象 Intent intent=new Intent(); //Intent中也可以传递BundleIntent.putExtra(“data_return”,”Helloworld!”); setResult(101,intent); //参数为responseCode响应码 和 intent对象 finish(); 123456789// 3.在MainActivity中覆写onActivityResult方法，新Activity一旦退出，就会执行该方法 protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); //如果请求标识与返回标识一样,则把数据返回到tv上 if (requestCode == 200 &amp; resultCode ==101) &#123; String s = data.getStringExtra("data_return"); tv.setText(s); &#125;&#125; 启动模式四种启动模式 standard（标准模式）：每当启动一个新活动，它都会进入返回栈并位于栈顶的位置，这种模式下，系统不会在乎这个活动是否已经存在于返回栈中，每次启动都会创建并都放在栈顶。 singleTop（栈顶复用）：在启动活动时如果发现栈中该活动已经位于栈顶，则重用该实例( 会调用实例的onNewIntent() )而不会创建新的实例。若不在栈顶，则会创建新的实例。 singleTask（栈内复用）：启动活动时如果发现栈中已经存在该活动，则重用该实例(会调用实例的 onNewIntent() )，并且将位于它之上的活动统统出栈，如果没有发现就会新建一个实例。 singleIntance（单例模式）：会有一个单独的返回栈来管理这个活动，而且栈中只有此活动，不管是任何一个程序来访问这个活动，都共用这个返回栈，也就解决了共享活动的问题。 设置方法：在AndroidMainifest.xml文件中activity标签name之下加入声明：Android:launchMode=” standard、singleTop、singleTask、singleInstance(四选一)”这样就可以配置活动的启动模式了。 详解standard standard模式是默认的启动模式，不用为配置android:launchMode属性即可，当然也可以指定值为standard。 我们将会一个Activity，命名为FirstActivity，来演示一下标准的启动模式。FirstActivity代码如下：1234567891011121314public void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.first); TextView textView = (TextView) findViewById(R.id.textView); textView.setText(this.toString()); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(FirstActivity.this, FirstActivity.class); startActivity(intent); &#125; &#125;); &#125; 我们FirstActivity界面中的TextView用于显示当前Activity实例的序列号，Button用于跳转到下一个FirstActivity界面。然后我们连续点击几次按钮，将会出现下面的现象我们注意到都是FirstActivity的实例，但序列号不同，并且我们需要连续按后退键两次，才能回到第一个FristActivity。standard模式的原理如下图所示如图所示，每次跳转系统都会在task中生成一个新的FirstActivity实例，并且放于栈结构的顶部，当我们按下后退键时，才能看到原来的FirstActivity实例。这就是standard启动模式，不管有没有已存在的实例，都生成新的实例。 详解singleTop 我们在上面的基础上为指定属性android:launchMode=”singleTop”，系统就会按照singleTop启动模式处理跳转行为。我们重复上面几个动作，将会出现下面的现象： 我们看到这个结果跟standard有所不同，三个序列号是相同的，也就是说使用的都是同一个FirstActivity实例；如果按一下后退键，程序立即退出，说明当前栈结构中只有一个Activity实例。singleTop模式的原理如下图所示： 正如上图所示，跳转时系统会先在栈结构中寻找是否有一个FirstActivity实例正位于栈顶，如果有则不再生成新的，而是直接使用。也许朋友们会有疑问，我只看到栈内只有一个Activity，如果是多个Activity怎么办，如果不是在栈顶会如何？我们接下来再通过一个示例来证实一下大家的疑问。 我们再新建一个Activity命名为SecondActivity，如下：1234567891011121314protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.second); TextView textView = (TextView) findViewById(R.id.textView); textView.setText(this.toString()); Button button = (Button) findViewById(R.id.button); button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(SecondActivity.this, FirstActivity.class); startActivity(intent); &#125; &#125;); &#125; 然后将之前的FirstActivity跳转代码改为：12Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); 是的，FirstActivity会跳转到SecondActivity，SecondActivity又会跳转到FirstActivity。演示结果如下：我们看到，两个FirstActivity的序列号是不同的，证明从SecondActivity跳转到FirstActivity时生成了新的FirstActivity实例。原理图如下：我们看到，当从SecondActivity跳转到FirstActivity时，系统发现存在有FirstActivity实例,但不是位于栈顶，于是重新生成一个实例。这就是singleTop启动模式，如果发现有对应的Activity实例正位于栈顶，则重复利用，不再生成新的实例。 详解singleTask 在上面的基础上我们修改FirstActivity的属性android:launchMode=”singleTask”。演示的结果如下： 我们注意到，在上面的过程中，FirstActivity的序列号是不变的，SecondActivity的序列号却不是唯一的，说明从SecondActivity跳转到FirstActivity时，没有生成新的实例，但是从FirstActivity跳转到SecondActivity时生成了新的实例。singleTask模式的原理图如下图所示： 在图中的下半部分是SecondActivity跳转到FirstActivity后的栈结构变化的结果，我们注意到，SecondActivity消失了，没错，在这个跳转过程中系统发现有存在的FirstActivity实例，于是不再生成新的实例，而是将FirstActivity之上的Activity实例统统出栈，将FirstActivity变为栈顶对象，显示到幕前。也许朋友们有疑问，如果将SecondActivity也设置为singleTask模式，那么SecondActivity实例是不是可以唯一呢？在我们这个示例中是不可能的，因为每次从SecondActivity跳转到FirstActivity时，SecondActivity实例都被迫出栈，下次等FirstActivity跳转到SecondActivity时，找不到存在的SecondActivity实例，于是必须生成新的实例。但是如果我们有ThirdActivity，让SecondActivity和ThirdActivity互相跳转，那么SecondActivity实例就可以保证唯一。 这就是singleTask模式，如果发现有对应的Activity实例，则使此Activity实例之上的其他Activity实例统统出栈，使此Activity实例成为栈顶对象，显示到幕前。 详解singleInstance 这种启动模式比较特殊，因为它会启用一个新的栈结构，将Acitvity放置于这个新的栈结构中，并保证不再有其他Activity实例进入。 我们修改FirstActivity的launchMode=”standard”，SecondActivity的launchMode=”singleInstance”，由于涉及到了多个栈结构，我们需要在每个Activity中显示当前栈结构的id，所以我们为每个Activity添加如下代码：12TextView taskIdView = (TextView) findViewById(R.id.taskIdView); taskIdView.setText("current task id: " + this.getTaskId()); 然后我们再演示一下这个流程：我们发现这两个Activity实例分别被放置在不同的栈结构中，关于singleInstance的原理图如下：我们看到从FirstActivity跳转到SecondActivity时，重新启用了一个新的栈结构，来放置SecondActivity实例，然后按下后退键，再次回到原始栈结构；图中下半部分显示的在SecondActivity中再次跳转到FirstActivity，这个时候系统会在原始栈结构中生成一个FirstActivity实例，然后回退两次，注意，并没有退出，而是回到了SecondActivity，为什么呢？是因为从SecondActivity跳转到FirstActivity的时候，我们的起点变成了SecondActivity实例所在的栈结构，这样一来，我们需要“回归”到这个栈结构。如果我们修改FirstActivity的launchMode值为singleTop、singleTask、singleInstance中的任意一个，流程将会如图所示：singleInstance启动模式可能是最复杂的一种模式，为了帮助大家理解，我举一个例子，假如我们有一个share应用，其中的ShareActivity是入口Activity，也是可供其他应用调用的Activity，我们把这个Activity的启动模式设置为singleInstance，然后在其他应用中调用。我们编辑ShareActivity的配置：12345678910&lt;activity android:name=".ShareActivity" android:launchMode="singleInstance"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.SINGLE_INSTANCE_SHARE" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后我们在其他应用中这样启动该Activity：12Intent intent = new Intent("android.intent.action.SINGLE_INSTANCE_SHARE"); startActivity(intent); 当我们打开ShareActivity后再按后退键回到原来界面时，ShareActivity做为一个独立的个体存在，如果这时我们打开share应用，无需创建新的ShareActivity实例即可看到结果，因为系统会自动查找，存在则直接利用。大家可以在ShareActivity中打印一下taskId，看看效果。关于这个过程，原理图如下： 启动模式应用场景 singleTop适合接收通知启动的内容显示页面。例如，某个新闻客户端的新闻内容页面，如果收到10个新闻推送，每次都打开一个新闻内容页面是很烦人的。所以要从外界尽可能多的跳转到一个界面。 singleTask适合作为程序入口点。例如浏览器的主界面、联系人activity。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance适合需要与程序分离开的页面。这种模式的使用情况比较罕见，例如闹铃提醒，将闹铃提醒与闹铃设置分离。呼叫来电界面。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -&gt; B (singleInstance) -&gt; C，完全退出后，再次启动，首先打开的是B。 总结 LauncherMode 分为两组： 第一组standard和SingleTop是一组用的比较多，他们二个唯一的区别就是SingleTop如果在当前Task的顶部，同时在startActivity()这个Activity的时候就不会再创建新的实例，而是执行该实例的onNewIntent()方法，其他情况下的用法是一样的； 第二组SingleTask和SingleIntance这一组用的比较少，要结合特定情况来使用，这一组的使用区别是比较大的，在我们开发APP的过程中要合理的使用Activity的启动模式来使我们的APP更加的快捷，流畅，提高用户体验。如果有写的不好的还忘指点。 其他补充Activity中finish() onDestroy() 和System.exit()的区别 Activity.finish()Call this when your activity is done and should be closed.在你的activity动作完成的时候，或者Activity需要关闭的时候，调用此方法。当你调用此方法的时候，系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory()方法，其占用的资源也没有被及时释放。因为移出了栈，所以当你点击手机上面的“back”按键的时候，也不会再找到这个Activity。 Activity.onDestory()the system is temporarily destroying this instance of the activity to save space.系统销毁了这个Activity的实例在内存中占据的空间。在Activity的生命周期中，onDestory()方法是他生命的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法。 System.exit(0)这玩意是退出整个应用程序的，是针对整个Application的。将整个进程直接KO掉。 finish函数仅仅把当前Activity退出了，但是并没有释放他的资源。安卓系统自己决定何时从内存中释放应用程序。当系统没有可用内存到时候，会按照优先级，释放部分应用。 AppCompatActivity、ActionBarActivity、FragmentActivity和Activity的区别 support v4 FragmentActivity 兼容2.x模式下使用Fragmentsupport v7 AppCompatActivity 兼容2.x模式下使用Fragment和ActionBar，ActionBarActivity是AppCompatActivity过时产品如果3.0以上直接继承Activity，便可使用Fragment和ActionBar 资源内存不足导致低优先级Activity被杀死 Activity优先级前台Activity——正在和用户交互的Activity，优先级最高可见但非前台Activity——Activity中弹出的对话框导致Activity可见但无法交互后台Activity——已经被暂停的Activity，优先级最低系统内存不足是，会按照以上顺序杀死Activity，并通过onSaveInstanceState和onRestoreInstanceState这两个方法来存储和恢复数据。 ActivityManager–获得正在运行的activity、service、进程、最近运行的应用。12345678910111213141516171819202122232425262728ActivityManager mActivityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE) ; //获得系统运行的进程 List&lt;ActivityManager.RunningAppProcessInfo&gt; appList1 = mActivityManager .getRunningAppProcesses(); for (RunningAppProcessInfo running : appList1) &#123; System.out.println(running.processName); &#125; System.out.println(&quot;================&quot;); //获得当前正在运行的service List&lt;ActivityManager.RunningServiceInfo&gt; appList2 = mActivityManager .getRunningServices(100); for (ActivityManager.RunningServiceInfo running : appList2) &#123; System.out.println(running.service.getClassName()); &#125; System.out.println(&quot;================&quot;); //获得当前正在运行的activity List&lt;ActivityManager.RunningTaskInfo&gt; appList3 = mActivityManager .getRunningTasks(1000); for (ActivityManager.RunningTaskInfo running : appList3) &#123; System.out.println(running.baseActivity.getClassName()); &#125; System.out.println(&quot;================&quot;); //获得最近运行的应用 List&lt;ActivityManager.RecentTaskInfo&gt; appList4 = mActivityManager .getRecentTasks(100, 1); for (ActivityManager.RecentTaskInfo running : appList4) &#123; System.out.println(running.origActivity.getClassName()); &#125; 【附录】 常用Intent意图表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//(1).调用拨号程序Uri uri = Uri.parse("tel:10086"); Intent intent = new Intent(Intent.ACTION_DIAL, uri); startActivity(intent); //(2).发送短信或者彩信//发生短信Uri uri = Uri.parse("smsto:10086"); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); intent.putExtra("sms_body", "Hello"); startActivity(intent); //发送彩信，相当于发送带附件的短信Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra("sms_body", "Hello"); Uri uri = Uri.parse("content://media/external/images/media/23"); intent.putExtra(Intent.EXTRA_STREAM, uri); intent.setType("image/png"); startActivity(intent); //(3).通过浏览器打开网页Uri uri = Uri.parse("http://www.google.com"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent);//(4).发送电子邮件Uri uri = Uri.parse("mailto:someone@domain.com"); Intent intent = new Intent(Intent.ACTION_SENDTO, uri); startActivity(intent); //给someone@domain.com发邮件发送内容为“Hello”的邮件 Intent intent = new Intent(Intent.ACTION_SEND); intent.putExtra(Intent.EXTRA_EMAIL, "someone@domain.com"); intent.putExtra(Intent.EXTRA_SUBJECT, "Subject"); intent.putExtra(Intent.EXTRA_TEXT, "Hello"); intent.setType("text/plain"); startActivity(intent); // 给多人发邮件 Intent intent=new Intent(Intent.ACTION_SEND); String[] tos = &#123;"1@abc.com", "2@abc.com"&#125;; // 收件人 String[] ccs = &#123;"3@abc.com", "4@abc.com"&#125;; // 抄送 String[] bccs = &#123;"5@abc.com", "6@abc.com"&#125;; // 密送 intent.putExtra(Intent.EXTRA_EMAIL, tos); intent.putExtra(Intent.EXTRA_CC, ccs); intent.putExtra(Intent.EXTRA_BCC, bccs); intent.putExtra(Intent.EXTRA_SUBJECT, "Subject"); intent.putExtra(Intent.EXTRA_TEXT, "Hello"); intent.setType("message/rfc822"); startActivity(intent); //(5).显示地图与路径规划// 打开Google地图中国北京位置（北纬39.9，东经116.3） Uri uri = Uri.parse("geo:39.9,116.3"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); // 路径规划：从北京某地（北纬39.9，东经116.3）到上海某地（北纬31.2，东经121.4） Uri uri = Uri.parse("http://maps.google.com/maps?f=d&amp;saddr=39.9 116.3&amp;daddr=31.2 121.4"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //(6).播放多媒体Intent intent = new Intent(Intent.ACTION_VIEW); Uri uri = Uri.parse("file:///sdcard/foo.mp3"); intent.setDataAndType(uri, "audio/mp3"); startActivity(intent); Uri uri = Uri.withAppendedPath(MediaStore.Audio.Media.INTERNAL_CONTENT_URI, "1"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //(7).拍照// 打开拍照程序 Intent intent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE); startActivityForResult(intent, 0); // 取出照片数据 Bundle extras = intent.getExtras(); Bitmap bitmap = (Bitmap) extras.get("data"); //(8).获取并剪切图片// 获取并剪切图片 Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType("image/*"); intent.putExtra("crop", "true"); // 开启剪切 intent.putExtra("aspectX", 1); // 剪切的宽高比为1：2 intent.putExtra("aspectY", 2); intent.putExtra("outputX", 20); // 保存图片的宽和高 intent.putExtra("outputY", 40); intent.putExtra("output", Uri.fromFile(new File("/mnt/sdcard/temp"))); // 保存路径 intent.putExtra("outputFormat", "JPEG");// 返回格式 startActivityForResult(intent, 0); // 剪切特定图片 Intent intent = new Intent("com.android.camera.action.CROP"); intent.setClassName("com.android.camera", "com.android.camera.CropImage"); intent.setData(Uri.fromFile(new File("/mnt/sdcard/temp"))); intent.putExtra("outputX", 1); // 剪切的宽高比为1：2 intent.putExtra("outputY", 2); intent.putExtra("aspectX", 20); // 保存图片的宽和高 intent.putExtra("aspectY", 40); intent.putExtra("scale", true); intent.putExtra("noFaceDetection", true); intent.putExtra("output", Uri.parse("file:///mnt/sdcard/temp")); startActivityForResult(intent, 0); //(9).打开Google Market// 打开Google Market直接进入该程序的详细页面 Uri uri = Uri.parse("market://details?id=" + "com.demo.app"); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); //(10).安装和卸载程序Uri uri = Uri.fromParts("package", "com.demo.app", null); Intent intent = new Intent(Intent.ACTION_DELETE, uri); startActivity(intent); //(11).进入设置界面// 进入无线网络设置界面（其它可以举一反三） Intent intent = new Intent(android.provider.Settings.ACTION_WIRELESS_SETTINGS);startActivityForResult(intent, 0); 整理作者：汪博个人名言：少壮不努力，老大徒悲伤。]]></content>
    </entry>

    
  
  
</search>
